{
    "contents" : "#' Get variable name of the NetCDF file.\n#' \n#' Get variable name in the NetCDF file. After knowning the name, you can use \\code{loadNcdf} to load\n#' the target variable.\n#' \n#' @param filePath A path pointing to the netCDF file.\n#' @return The names of the varialbes in the file.\n#' @examples \n#' # First open the test NETcDF file.\n#' filePath <- system.file(\"extdata\", \"tnc.nc\", package = \"hyfo\")\n#' \n#' # Then if you don't know the variable name, you can use \\code{getNcdfVar} to get variable name\n#' varname <- getNcdfVar(filePath)\n#' \n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' @import ncdf4\n#' @references \n#' \n#' \\itemize{\n#' \\item David Pierce (2015). ncdf4: Interface to Unidata netCDF (Version 4 or\n#' Earlier) Format Data Files. R package version 1.14.1.\n#' http://CRAN.R-project.org/package=ncdf4\n#' }\n#' \n#' \n#' \n#' @export\ngetNcdfVar <- function(filePath) {\n  nc <- nc_open(filePath)\n  names <- names(nc$var)\n  return(names)\n}\n\n\n#' Load NetCDF file\n#' \n#' @param filePath A path pointing to the NetCDF file, version3.\n#' @param varname A character representing the variable name, you can use \\code{getNcdfVar} to\n#' get the basic information about the variables and select the target.\n#' @param tz A string representing the time zone, default is GMT, if you know what time zone is \n#' you can assign it in the argument. If \\code{tz = ''}, current time zone will be taken.\n# @param drop When the time dimension only have one value, the output data will drop\n# this dimension automatically (\\code{drop = TRUE}), default value is \\code{drop = FALSE}, then time dimension will be added.\n# This argument mainly applies to the later calculations based on hyfo file. If the dimension\n# is dropped, than some calculations may not be processed afterwards. \n#' @param ... Several arguments including Year, month, lon, lat \n#' type in \\code{?downscaleNcdf} for details.You can load while downscale, \n#' and also first load than use \\code{downscaleNcdf} to downscale.\n#' @return A list object from \\code{hyfo} containing the information to be used in the analysis, \n#' or biascorrection.\n#' @examples \n#' # First open the test NETcDF file.\n#' filePath <- system.file(\"extdata\", \"tnc.nc\", package = \"hyfo\")\n#' \n#' # Then if you don't know the variable name, you can use \\code{getNcdfVar} to get variable name\n#' varname <- getNcdfVar(filePath)\n#' \n#' nc <- loadNcdf(filePath, varname)\n#' \n#' # you can directly add your downscale information to the argument.\n#' nc1 <- loadNcdf(filePath, varname, year = 2006, lon = c(-2, -0.5), lat = c(43.2, 43.7))\n#' nc2 <- loadNcdf(filePath, varname, year = 2005, month = 3:8, lon = c(-2, -0.5), \n#' lat = c(43.2, 43.7))\n#' \n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' @export\n#' @import ncdf4\n#' @references \n#' \n#' \\itemize{\n#' \\item David Pierce (2015). ncdf4: Interface to Unidata netCDF (Version 4 or\n#' Earlier) Format Data Files. R package version 1.14.1.\n#' http://CRAN.R-project.org/package=ncdf4\n#' \n#' \\item Santander MetGroup (2015). ecomsUDG.Raccess: R interface to the ECOMS User Data Gateway. R package\n#' version 2.2-6. http://meteo.unican.es/ecoms-udg\n#' }\n#' \n#' \nloadNcdf <- function(filePath, varname, tz = 'GMT', ...) {\n  nc <- nc_open(filePath)\n  \n  var <- nc$var\n  # Use name to locate the variable\n  call_1 <- as.call(c(\n    list(as.name('$'), var, varname)\n  ))\n  var <- eval(call_1)\n  if(is.null(var)) stop('No such variable name, check source file.')\n  \n  dimNames <- unlist(lapply(1:length(var$dim), function(x) var$dim[[x]]$name))\n  \n  # Only deals with the most common dimensions, futher dimensions will be added in future.\n  dimIndex <- grepAndMatch(c('lon', 'lat', 'time', 'member'), dimNames)\n  if (length(dimIndex) < 3) stop('Your file has less than 3 dimensions.')\n  \n  # First needs to identify the variable name, load the right data\n  message('Loading data...')\n  nc_data <- ncvar_get(nc, var)\n  message('Processing...')\n  \n  gridData <- list()\n  gridData$Variable$varName <- varname\n  gridData$xyCoords$x <- var$dim[[dimIndex[1]]]$vals\n  attributes(gridData$xyCoords$x)$name <- dimNames[dimIndex[1]]\n  \n  gridData$xyCoords$y <- var$dim[[dimIndex[2]]]$vals\n  attributes(gridData$xyCoords$y)$name <- dimNames[dimIndex[2]]\n  \n  # Time part needs to be taken seperately\n  \n  timeUnit <- strsplit(var$dim[[dimIndex[3]]]$units, split = ' since')[[1]][1]\n  timeDiff <- var$dim[[dimIndex[3]]]$vals\n  # To get real time, time since when has to be grabbed from the dataset.\n  timeSince <- as.POSIXlt(strsplit(var$dim[[dimIndex[3]]]$units, split = 'since')[[1]][2], tz = tz)\n  \n  \n#  Date <- rep(timeSince, length(timeDiff))\n  \n  \n  unitDic <- data.frame(weeks = 'weeks', days = 'days', hours = 'hours',\n                        minutes = 'mins', seconds = 'secs')\n  \n  timeDiff <- as.difftime(timeDiff, units = as.character(unitDic[1, timeUnit]))\n  \n#   if (grepl('day', timeUnit)) {\n#     Date$mday <- Date$mday + timeDiff\n#   } else if (grepl('second', timeUnit)) {\n#     Date$sec <- Date$sec + timeDiff\n#   }\n  Date <- timeSince + timeDiff\n  \n  # data directly loaded from ncdf4 will drop the dimension with only one value.\n  # the varsize shows the real dimension, without any dropping.\n  dim(nc_data) <- var$varsize \n  \n  # Right now there is no need to add end Date, in furture, may be added as needed.\n  gridData$Dates$start <- as.character(Date)\n  \n  # Assing data to grid data\n  # At leaset should be 3 dimensions, lon, lat, time. So if less than 3, \n  \n  gridData$Data <- nc_data\n  \n  attributes(gridData$Data)$dimensions <- dimNames\n  \n  if (!is.na(dimIndex[4])) gridData$Members <- var$dim[[dimIndex[4]]]$vals\n  \n  gridData$Loaded <- 'by hyfo package, http://yuanchao-xu.github.io/hyfo/'\n  nc_close(nc)\n  \n  output <- downscaleNcdf(gridData, ...)\n  \n  return(output)\n  \n}\n\n\n\n\n#' Downscale NetCDF file\n#' @param gridData A hyfo list file from \\code{\\link{loadNcdf}}\n#' @param year A vector of the target year. e.g. \\code{year = 2000}, \\code{year = 1980:2000}\n#' @param month A vector of the target month. e.g. \\code{month = 2}, \\code{month = 3:12}\n#' @param lon A vector of the range of the downscaled longitude, should contain a max value\n#' and a min value. e.g. \\code{lon = c(-1.5, 2,5)}\n#' @param lat A vector of the range of the downscaled latitude, should contain a max value\n#' and a min value. e.g. \\code{lat = c(32,2, 36)}\n#' @return A downscaled hyfo list file.\n#' @examples \n#' # First open the test NETcDF file.\n#' filePath <- system.file(\"extdata\", \"tnc.nc\", package = \"hyfo\")\n#' \n#' \n#' # Then if you don't know the variable name, you can use \\code{getNcdfVar} to get variable name\n#' varname <- getNcdfVar(filePath)\n#' \n#' nc <- loadNcdf(filePath, varname)\n#' \n#' # Then write to your work directory\n#' \n#' nc1 <- downscaleNcdf(nc, year = 2006, lon = c(-2, -0.5), lat = c(43.2, 43.7))\n#' nc2 <- downscaleNcdf(nc, year = 2005, month = 3:8, lon = c(-2, -0.5), lat = c(43.2, 43.7))\n#' \n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' @export \n#' @references \n#' \n#' \\itemize{\n#' \n#' \\item Santander MetGroup (2015). ecomsUDG.Raccess: R interface to the ECOMS User Data Gateway. R package\n#' version 2.2-6. http://meteo.unican.es/ecoms-udg\n#' }\n#' \n#' \ndownscaleNcdf <- function(gridData, year = NULL, month = NULL, lon = NULL, lat = NULL) {\n  \n  \n  if (!is.null(year)) {\n    Dates <- as.POSIXlt(gridData$Dates$start)\n    yearIndex <- Dates$year + 1900\n    monIndex <- Dates$mon + 1\n    timeDim <- match('time', attributes(gridData$Data)$dimensions)\n    \n    \n    if (is.null(month) || !any(sort(month) != month)) {\n      targetYearIndex <- which(yearIndex %in% year)\n      if (length(targetYearIndex) == 0) stop('No input years in the input ts, check your input.')\n      \n      \n      # if year crossing  than sort(month) != month\n    } else {\n      \n      startIndex <- intersect(which(yearIndex == year[1] - 1), which(monIndex == month[1]))[1]\n      endIndex <- tail(intersect(which(yearIndex == tail(year, 1)), which(monIndex == tail(month, 1))), 1)\n      \n      if (is.na(startIndex) || length(endIndex) == 0 || startIndex > endIndex) {\n        stop('Cannot find input months and input years in the input time series.')\n      } else {\n        \n        targetYearIndex <- startIndex:endIndex\n        \n        if (any(diff(year) != 1)) {\n          # if year is not continuous, like 1999, 2003, 2005, than we have to sift again.\n          # Only for special cases.\n          Dates <- Dates[targetYearIndex]\n          yea <- Dates$year + 1900\n          mon <- Dates$mon + 1\n          \n          DateIndex <- unlist(sapply(year, function(x) {\n            startIndex <- intersect(which(yea == x - 1), which(mon == month[1]))[1]\n            endIndex <- tail(intersect(which(yea == x), which(mon == tail(month, 1))), 1)\n            index <- startIndex:endIndex\n            return(index)\n          }))\n          \n          \n          targetYearIndex <- targetYearIndex[DateIndex]\n          # cannot directly return output here, because sometimes, month can be incontinuous,\n          # we still need the next process to sift month.\n        }\n      }\n    }\n    \n    gridData$Dates$start <- gridData$Dates$start[targetYearIndex]\n    gridData$Dates$end <- gridData$Dates$end[targetYearIndex]\n    \n    gridData$Data <- chooseDim(gridData$Data, timeDim, targetYearIndex)\n  }  \n    \n  if (!is.null(month)) {\n    Dates <- as.POSIXlt(gridData$Dates$start)\n    monIndex <- Dates$mon + 1\n    \n    targetMonIndex <- which(monIndex %in% month)\n    if (length(targetMonIndex) == 0) stop('Check your input year, it may exceed the years \n                                          in the input dataset.')\n    gridData$Dates$start <- gridData$Dates$start[targetMonIndex]\n    gridData$Dates$end <- gridData$Dates$end[targetMonIndex]\n    \n    timeDim <- match('time', attributes(gridData$Data)$dimensions)\n    \n    gridData$Data <- chooseDim(gridData$Data, timeDim, targetMonIndex)\n    \n  }\n  \n  if (!is.null(lon)) {\n    \n    lonIndex <- gridData$xyCoords$x\n    \n    lonI1 <- which(abs(lonIndex - min(lon)) == min(abs(lonIndex - min(lon)), na.rm = TRUE)) \n    lonI2 <- which(abs(lonIndex - max(lon)) == min(abs(lonIndex - max(lon)), na.rm = TRUE)) \n    \n    # take the as large as possible range\n    targetLonIndex <- lonI1[length(lonI1)]:lonI2[length(lonI2)]\n    if (length(targetLonIndex) == 0) stop('Your input lon is too small, try to expand the \n                                          longitude range.') \n    gridData$xyCoords$x <- gridData$xyCoords$x[targetLonIndex]\n    lonDim <- grepAndMatch('lon', attributes(gridData$Data)$dimensions)\n    \n    gridData$Data <- chooseDim(gridData$Data, lonDim, targetLonIndex)\n  }\n  \n  \n  if (!is.null(lat)) {\n    latIndex <- gridData$xyCoords$y\n    \n    latI1 <- which(abs(latIndex - min(lat)) == min(abs(latIndex - min(lat)), na.rm = TRUE)) \n    latI2 <- which(abs(latIndex - max(lat)) == min(abs(latIndex - max(lat)), na.rm = TRUE)) \n    \n    targetLatIndex <- latI1[length(latI1)]:latI2[length(latI2)]\n    \n    if (length(targetLonIndex) == 0) stop('Your input lat is too small, try to expand the \n                                          latitude range.') \n    gridData$xyCoords$y <- gridData$xyCoords$y[targetLatIndex]\n    latDim <- grepAndMatch('lat', attributes(gridData$Data)$dimensions)\n    gridData$Data <- chooseDim(gridData$Data, latDim, targetLatIndex)\n  }\n  \n  return(gridData)\n  \n}\n\n\n\n\n\n\n\n\n\n\n#' Write to NetCDF file using hyfo list file\n#' @param gridData A hyfo list file from \\code{\\link{loadNcdf}}\n#' @param filePath A path of the new NetCDF file, should end with \".nc\"\n#' @param missingValue A number representing the missing value in the NetCDF file, default\n#' is 1e20\n#' #' @param tz A string representing the time zone, default is GMT, if you know what time zone is \n#' you can assign it in the argument. If \\code{tz = ''}, current time zone will be taken.\n#' @param units A string showing in which unit you are putting in the NetCDF file, it can be \n#' seconds or days and so on. If not specified, the function will pick up the possible largest \n#' time units from \\code{c('weeks', 'days', 'hours', 'mins', 'secs')}\n#' @param version ncdf file versions, default is 3, if 4 is chosen, output file will be foreced to version 4.\n#' @return An NetCDF version 3 file.\n#' @examples \n#' # First open the test NETcDF file.\n#' filePath <- system.file(\"extdata\", \"tnc.nc\", package = \"hyfo\")\n#' \n#' \n#' # Then if you don't know the variable name, you can use \\code{getNcdfVar} to get variable name\n#' varname <- getNcdfVar(filePath)\n#' \n#' nc <- loadNcdf(filePath, varname)\n#' \n#' # Then write to your work directory\n#' \n#' writeNcdf(nc, 'test.nc')\n#' \n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' @export \n#' @import ncdf4\n#' @references \n#' \n#' \\itemize{\n#' \\item David Pierce (2015). ncdf4: Interface to Unidata netCDF (Version 4 or\n#' Earlier) Format Data Files. R package version 1.14.1.\n#' http://CRAN.R-project.org/package=ncdf4\n#' \n#' \\item Santander MetGroup (2015). ecomsUDG.Raccess: R interface to the ECOMS User Data Gateway. R package\n#' version 2.2-6. http://meteo.unican.es/ecoms-udg\n#' \n#' }\n#' \n#' \nwriteNcdf <- function(gridData, filePath, missingValue = 1e20, tz = 'GMT', units = NULL, version = 3) {\n  \n  name <- gridData$Variable$varName\n  # First defines dimensions.\n  lonName <- attributes(gridData$xyCoords$x)$name\n  latName <- attributes(gridData$xyCoords$y)$name\n  dimLon <- ncdim_def(lonName, 'degree', gridData$xyCoords$x)\n  dimLat <- ncdim_def(latName, 'degree', gridData$xyCoords$y)\n  dimMem <- NULL\n  if (!is.null(gridData$Members)) {\n    dimMem <- ncdim_def('member', 'members', 1:length(gridData$Members))\n  }\n  \n  \n  # Time needs to be treated seperately\n  dates <- as.POSIXlt(gridData$Dates$start, tz = tz)\n  if (is.null(units)) {\n    units <- getTimeUnit(dates)\n    time <- difftime(dates, dates[1], units = units)\n  } else {\n    time <- difftime(dates, dates[1], units = units)\n  }\n  timeUnits <- paste(units, 'since', dates[1])\n  # Here time needs to be numeric, as required by ncdf4 package, which is not the same\n  # with ncdf\n  dimTime <- ncdim_def('time', timeUnits, as.numeric(time))\n  \n  \n  # Depending on whether there is a member part of the dataset.\n  # default list\n  dimList <- list(dimLon, dimLat, dimTime, dimMem)\n  \n  # In order to keep the dim list exactly the same with the original one, it needs to be changed.\n  dimIndex <- grepAndMatch(c('lon', 'lat', 'time', 'member'), attributes(gridData$Data)$dimensions)\n  dimIndex <- na.omit(dimIndex)\n  \n  # Here order is needed, cuz in the procesure above, c('lon', 'lat', 'time', 'member')\n  # is the pattern, while actually, attributes(gridData$Data)$dimensions should be the pattern.\n  # So here needs an order() to get the wanted result.\n  dimList <- dimList[order(dimIndex)]\n  \n  # delete the NULL list, in order that there is no member part in the data.\n  dimList <- Filter(Negate(is.null), dimList)\n  # Then difines data\n  var <- ncvar_def( name, \"units\", dimList, missingValue)\n  \n  \n  # Here for ncdf4, there is an option to create version 4 ncdf, in future, it\n  # may added here.\n  if (version == 3) {\n    nc <- nc_create(filePath, var) \n  } else if (version == 4) {\n    nc <- nc_create(filePath, var, force_v4 = TRUE)\n  } else {\n    stop(\"Which ncdf version you want? Only 3 and 4 can be selected!\")\n  }\n  \n  # This part comes from the library downscaleR, can be deleted if you don't \n  # use {ecomsUDG.Raccess}, by adding this, the file can be read by the package {ecomsUDG.Raccess}\n  ncatt_put(nc, \"time\", \"standard_name\",\"time\")\n  ncatt_put(nc, \"time\", \"axis\",\"T\")\n  ncatt_put(nc, \"time\", \"_CoordinateAxisType\",\"Time\")\n  #ncatt_put(nc, \"time\", \"_ChunkSize\",1)\n  ncatt_put(nc, lonName, \"standard_name\",\"longitude\")\n  ncatt_put(nc, lonName, \"_CoordinateAxisType\",\"Lon\")\n  ncatt_put(nc, latName, \"standard_name\",\"latitude\")\n  ncatt_put(nc, latName, \"_CoordinateAxisType\",\"Lat\")\n  if (!is.null(dimMem)){\n    ncatt_put(nc, \"member\", \"standard_name\",\"realization\")\n    ncatt_put(nc, \"member\", \"_CoordinateAxisType\",\"Ensemble\")\n    #att.put.ncdf(nc, \"member\", \"ref\",\"http://www.uncertml.org/samples/realisation\")\n  }\n  \n  \n  # This part has to be put\n  ncatt_put(nc, 0, \"Conventions\",\"CF-1.4\")\n  ncatt_put(nc, 0, 'WrittenBy', 'hyfo(http://yuanchao-xu.github.io/hyfo/)')\n  \n  #data <- aperm(gridData$Data, dimIndex) no need to do this, in the process above\n  # when you define the dimlist, the order of the dimension was fixed.\n  data <- gridData$Data\n  ncvar_put(nc, name, data)\n  nc_close(nc)\n  \n}\n\n# For internaluse by writeNcdf\ngetTimeUnit <- function(dates) {\n  units <- c('weeks', 'days', 'hours', 'mins', 'secs')\n  output <- NULL\n  for (unit in units) {\n    time <- difftime(dates, dates[1], units = unit)\n    rem <- sapply(time, function(x) x%%1)\n    if (!any(rem != 0)) {\n      output <- unit\n      break\n    }\n  } \n  return(output)\n}\n\n\n# Save for future use. \n#' @import ncdf4\n#' @references \n#' David Pierce (2014). ncdf: Interface to Unidata netCDF data files. R package version 1.6.8.\n#' http://CRAN.R-project.org/package=ncdf\ngetExtralDim <- function(...) {\n  dimList <- list(...)\n  \n  \n}\n\n# in order to first grep than match.\n# match only provides for exactly match, \n# dimIndex <- grepAndMatch(c('lon', 'lat', 'time', 'member'), dimNames)\ngrepAndMatch <- function(x, table) {\n  index <- unlist(lapply(x, function(x) {\n    a <- grep(x, table)\n  }))\n  return(index)\n}",
    "created" : 1449680737769.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "3683291925",
    "id" : "39BBA10B",
    "lastKnownWriteTime" : 1450178194,
    "path" : "E:/1/R/hyfo/R/ncdf.R",
    "project_path" : "R/ncdf.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "type" : "r_source"
}