{
    "contents" : "\n\n\n\n#' Get bias factor for multi/operational/real time bias correction.\n#' \n#' When you do multi/operational/real time bias correction. It's too expensive\n#' to input hindcast and obs every time. Especially when you have a long period of hindcast\n#' and obs, but only a short period of frc, it's too unecessary to read and compute hindcast\n#' and obs everytime. Therefore, biasFactor is designed. Using \\code{getBiasFactor}, you can\n#' get the biasFactor with hindcast and observation, then you can use \\code{applyBiasFactor} to \n#' apply the biasFactor to different forecasts. \n#' \n#' @param hindcast a hyfo grid data output or a dataframe(time series) consists of Date column and one or more value columns, \n#' representing the hindcast data. This data will be used in the calibration of the forecast, so it's better to have the same date period as\n#' observation data. Check details for more information.\n#' @param obs a hyfo grid data output or a dataframe (time series) consists of Date column and one or more value columns, \n#' representing the observation data.\n#' @param method bias correct method, including 'delta', 'scaling'...,default method is 'scaling'.\n#' @param scaleType only when the method \"scaling\" is chosen, scaleType will be available. Two different types\n#' of scaling method, 'add' and 'multi', which means additive and multiplicative scaling method, default is 'multi'. More info check \n#' details.\n#' @param preci If the precipitation is biascorrected, then you have to assign \\code{preci = TRUE}. Since for\n#' precipitation, some biascorrect methods may not apply to, or some methods are specially for precipitation. \n#' Default is FALSE, refer to details.\n#' @param prThreshold The minimum value that is considered as a non-zero precipitation. Default to 1 (assuming mm).\n#' @param extrapolate When use 'eqm' method, and 'no' is set, modified frc is bounded by the range of obs.\n#' If 'constant' is set, modified frc is not bounded by the range of obs. Default is 'no'.\n#' \n#' @seealso \\code{\\link{biasCorrect}} for method used in bias correction.\n#' \\code{\\link{applyBiasFactor}}, for the second part.\n#' \n#' @details \n#' \n#' Information about the method and how biasCorrect works can be found in \\code{\\link{biasCorrect}}\n#' \n#' \\strong{why use biasFactor}\n#' \n#' As for forecasting, for daily data, there is usually no need to have\n#' different bias factor every different day. You can calculate one bisa factor using a long\n#' period of hindcast and obs, and apply that factor to different frc.\n#' \n#' For example,\n#' \n#' You have 10 years of hindcast and observation. you want to do bias correction for some \n#' forecasting product, e.g. system 4. For system 4, each month, you will get a new forecast\n#' about the future 6 months. So if you want to do the real time bias correction, you have to\n#' take the 10 years of hindcast and observation data with you, and run \\code{biasCorrect} every\n#' time you get a new forecast. That's too expensive.\n#' \n#' For some practical use in forecasting, there isn't a so high demand for accuracy. E.g.,\n#' Maybe for February and March, you can use the same biasFactor, no need to do the computation \n#' again. \n#'  \n#' It is a generic function, if in your case you need to debug, please see \\code{?debug()} \n#' for how to debug S4 method.  \n#'  \n#' @examples \n#' \n#' ######## hyfo grid file biascorrection\n#' ########\n#' \n#' # If your input is obtained by \\code{loadNcdf}, you can also directly biascorrect\n#' # the file.\n#' \n#' # First load ncdf file.\n#' filePath <- system.file(\"extdata\", \"tnc.nc\", package = \"hyfo\")\n#' varname <- getNcdfVar(filePath)    \n#' nc <- loadNcdf(filePath, varname)\n#' \n#' data(tgridData)\n#' # Since the example data, has some NA values, the process will include some warning #message, \n#' # which can be ignored in this case.\n#' \n#' \n#' \n#' # Then we will use nc data as forecasting data, and use itself as hindcast data,\n#' # use tgridData as observation.\n#' \n#' biasFactor <- getBiasFactor(nc, tgridData)\n#' newFrc <- applyBiasFactor(nc, biasFactor)\n#'    \n#' biasFactor <- getBiasFactor(nc, tgridData, method = 'eqm', extrapolate = 'constant',\n#' preci = TRUE)\n#' # This method needs obs input.\n#' newFrc <- applyBiasFactor(nc, biasFactor, obs = tgridData)\n#' \n#' biasFactor <- getBiasFactor(nc, tgridData, method = 'gqm', preci = TRUE)\n#' newFrc <- applyBiasFactor(nc, biasFactor) \n#' \n#' \n#' ######## Time series biascorrection\n#' ########\n#' \n#' # Use the time series from testdl as an example, we take frc, hindcast and obs from testdl.\n#' data(testdl)\n#' \n#' # common period has to be extracted in order to better train the forecast.\n#' \n#' datalist <- extractPeriod(testdl, startDate = '1994-1-1', endDate = '1995-10-1')\n#' \n#' frc <- datalist[[1]]\n#' hindcast <- datalist[[2]]\n#' obs <- datalist[[3]]\n#' \n#' \n#' # The data used here is just for example, so there could be negative data.\n#' \n#' # default method is scaling\n#' biasFactor <- getBiasFactor(hindcast, obs)\n#' frc_new <- applyBiasFactor(frc, biasFactor)\n#' \n#' # for precipitation data, extra process needs to be executed, so you have to tell\n#' # the program to it is a precipitation data.\n#' \n#' biasFactor <- getBiasFactor(hindcast, obs, preci = TRUE)\n#' frc_new1 <- applyBiasFactor(frc, biasFactor)\n#' \n#' # You can use other methods to biascorrect, e.g. delta method. \n#' biasFactor <- getBiasFactor(hindcast, obs, method = 'delta')\n#' # delta method needs obs input.\n#' frc_new2 <- applyBiasFactor(frc, biasFactor, obs = obs)\n#' \n#' # \n#' biasFactor <- getBiasFactor(hindcast, obs, method = 'eqm', preci = TRUE)\n#' # eqm needs obs input\n#' frc_new3 <- applyBiasFactor(frc, biasFactor, obs = obs)\n#' \n#' biasFactor <- getBiasFactor(hindcast, obs, method = 'gqm', preci = TRUE)\n#' frc_new4 <- applyBiasFactor(frc, biasFactor)\n#' \n#' plotTS(obs, frc, frc_new, frc_new1, frc_new2, frc_new3, frc_new4, plot = 'cum')\n#' \n#' # You can also give name to this input list.\n#' TSlist <- list(obs, frc, frc_new, frc_new1, frc_new2, frc_new3, frc_new4)\n#' names(TSlist) <- c('obs', 'frc', 'delta', 'delta_preci', 'scale', 'eqm', 'gqm')\n#' plotTS(list = TSlist, plot = 'cum')\n#' \n#' \n#' # If the forecasts you extracted only has incontinuous data for certain months and years, e.g.,\n#' # for seasonal forecasting, forecasts only provide 3-6 months data, so the case can be \n#' # for example Dec, Jan and Feb of every year from year 1999-2005.\n#' # In such case, you need to extract certain months and years from observed time series.\n#' # extractPeriod() can be then used.\n#'   \n#'   \n#'\n#'\n#'\n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' \n#' @references \n#' Bias correction methods come from \\code{biasCorrection} from \\code{dowscaleR}\n#' \n#' \\itemize{\n#' \n#' \\item Santander Meteorology Group (2015). downscaleR: Climate data manipulation and statistical downscaling. R\n#' package version 0.6-0. https://github.com/SantanderMetGroup/downscaleR/wiki\n#' \n#' \\item R.A.I. Wilcke, T. Mendlik and A. Gobiet (2013) Multi-variable error correction of regional climate models. Climatic Change, 120, 871-887\n#' \n#' \\item A. Amengual, V. Homar, R. Romero, S. Alonso, and C. Ramis (2012) A Statistical Adjustment of Regional Climate Model Outputs to Local Scales: Application to Platja de Palma, Spain. J. Clim., 25, 939-957\n#' \n#' \\item C. Piani, J. O. Haerter and E. Coppola (2009) Statistical bias correction for daily precipitation in regional climate models over Europe, Theoretical and Applied Climatology, 99, 187-192\n#' \n#' \\item O. Gutjahr and G. Heinemann (2013) Comparing precipitation bias correction methods for high-resolution regional climate simulations using COSMO-CLM, Theoretical and Applied Climatology, 114, 511-529\n#' }\n#' \n#' @author Yuanchao Xu \\email{xuyuanchao37@@gmail.com }\n#' \n#' @importFrom methods setMethod\n#' @export\n#' \n#' \n# debug by trace(\"getBiasFactor\", browser, exit=browser, signature = c(\"list\", \"list\"))\nsetGeneric('getBiasFactor', function(hindcast, obs, method = 'scaling', scaleType = 'multi', \n                                     preci = FALSE, prThreshold = 0, extrapolate = 'no') {\n  standardGeneric('getBiasFactor')\n})\n\n#' @describeIn getBiasFactor\nsetMethod('getBiasFactor', signature('data.frame', 'data.frame'), \n          function(hindcast, obs, method, scaleType, preci, prThreshold, extrapolate) {\n            result <- getBiasFactor.TS(hindcast, obs, method, scaleType, preci, prThreshold, extrapolate)\n            return(result)\n          })\n\n\n# This is for the grid file from downscaleR\n#' @describeIn getBiasFactor\n#' @importFrom methods new\nsetMethod('getBiasFactor', signature('list', 'list'), \n          function(hindcast, obs, method, scaleType, preci, prThreshold, extrapolate) {\n            result <- getBiasFactor.list(hindcast, obs, method, scaleType, preci, prThreshold, extrapolate)\n            return(result)\n            })\n\n\n\n\n#' Apply bias factor to different forecasts for multi/operational/real time bias correction.\n#' \n#' When you do multi/operational/real time bias correction. It's too expensive\n#' to input hindcast and obs every time. Especially when you have a long period of hindcast\n#' and obs, but only a short period of frc, it's too unecessary to read and compute hindcast\n#' and obs everytime. Therefore, biasFactor is designed. Using \\code{getBiasFactor}, you can\n#' get the biasFactor with hindcast and observation, then you can use \\code{applyBiasFactor} to \n#' apply the biasFactor to different forecasts. \n#' \n#' @param frc a hyfo grid data output or a dataframe(time series) consists of Date column and one or more value columns, \n#' representing the frc data. Check details for more information.\n#' @param biasFactor a file containing all the information of the calibration, will be\n#' applied to different forecasts.\n#' @param obs for some methods, observation input is necessary. obs is a hyfo grid data output or a dataframe (time series) consists of Date column and one or more value columns, \n#' representing the observation data. Default value is NULL.\n#' @seealso \\code{\\link{biasCorrect}} for method used in bias correction. \n#' \\code{\\link{getBiasFactor}}, for the first part.\n#' \n#' @details \n#' \n#' Information about the method and how biasCorrect works can be found in \\code{\\link{biasCorrect}}\n#' \n#' \\strong{why use biasFactor}\n#' \n#' As for forecasting, for daily data, there is usually no need to have\n#' different bias factor every different day. You can calculate one bisa factor using a long\n#' period of hindcast and obs, and apply that factor to different frc.\n#' \n#' For example,\n#' \n#' You have 10 years of hindcast and observation. you want to do bias correction for some \n#' forecasting product, e.g. system 4. For system 4, each month, you will get a new forecast\n#' about the future 6 months. So if you want to do the real time bias correction, you have to\n#' take the 10 years of hindcast and observation data with you, and run \\code{biasCorrect} every\n#' time you get a new forecast. That's too expensive.\n#' \n#' For some practical use in forecasting, there isn't a so high demand for accuracy. E.g.,\n#' Maybe for February and March, you can use the same biasFactor, no need to do the computation \n#' again. \n#' \n#' \n#' It is a generic function, if in your case you need to debug, please see \\code{?debug()} \n#' for how to debug S4 method.\n#'  \n#' @examples \n#' \n#' ######## hyfo grid file biascorrection\n#' ########\n#' \n#' # If your input is obtained by \\code{loadNcdf}, you can also directly biascorrect\n#' # the file.\n#' \n#' # First load ncdf file.\n#' filePath <- system.file(\"extdata\", \"tnc.nc\", package = \"hyfo\")\n#' varname <- getNcdfVar(filePath)    \n#' nc <- loadNcdf(filePath, varname)\n#' \n#' data(tgridData)\n#' #' # Since the example data, has some NA values, the process will include some warning #message, \n#' # which can be ignored in this case.\n#' \n#' \n#' \n#' # Then we will use nc data as forecasting data, and use itself as hindcast data,\n#' # use tgridData as observation.\n#' \n#' biasFactor <- getBiasFactor(nc, tgridData)\n#' newFrc <- applyBiasFactor(nc, biasFactor)\n#'    \n#' biasFactor <- getBiasFactor(nc, tgridData, method = 'eqm', extrapolate = 'constant',\n#' preci = TRUE)\n#' # This method needs obs input.\n#' newFrc <- applyBiasFactor(nc, biasFactor, obs = tgridData)\n#' \n#' biasFactor <- getBiasFactor(nc, tgridData, method = 'gqm', preci = TRUE)\n#' newFrc <- applyBiasFactor(nc, biasFactor) \n#' \n#' \n#' ######## Time series biascorrection\n#' ########\n#' \n#' # Use the time series from testdl as an example, we take frc, hindcast and obs from testdl.\n#' data(testdl)\n#' \n#' # common period has to be extracted in order to better train the forecast.\n#' \n#' datalist <- extractPeriod(testdl, startDate = '1994-1-1', endDate = '1995-10-1')\n#' \n#' frc <- datalist[[1]]\n#' hindcast <- datalist[[2]]\n#' obs <- datalist[[3]]\n#' \n#' \n#' # The data used here is just for example, so there could be negative data.\n#' \n#' # default method is scaling\n#' biasFactor <- getBiasFactor(hindcast, obs)\n#' frc_new <- applyBiasFactor(frc, biasFactor)\n#' \n#' # for precipitation data, extra process needs to be executed, so you have to tell\n#' # the program to it is a precipitation data.\n#' \n#' biasFactor <- getBiasFactor(hindcast, obs, preci = TRUE)\n#' frc_new1 <- applyBiasFactor(frc, biasFactor)\n#' \n#' # You can use other methods to biascorrect, e.g. delta method. \n#' biasFactor <- getBiasFactor(hindcast, obs, method = 'delta')\n#' # delta method needs obs input.\n#' frc_new2 <- applyBiasFactor(frc, biasFactor, obs = obs)\n#' \n#' # \n#' biasFactor <- getBiasFactor(hindcast, obs, method = 'eqm', preci = TRUE)\n#' # eqm needs obs input\n#' frc_new3 <- applyBiasFactor(frc, biasFactor, obs = obs)\n#' \n#' biasFactor <- getBiasFactor(hindcast, obs, method = 'gqm', preci = TRUE)\n#' frc_new4 <- applyBiasFactor(frc, biasFactor)\n#' \n#' plotTS(obs, frc, frc_new, frc_new1, frc_new2, frc_new3, frc_new4, plot = 'cum')\n#' \n#' # You can also give name to this input list.\n#' TSlist <- list(obs, frc, frc_new, frc_new1, frc_new2, frc_new3, frc_new4)\n#' names(TSlist) <- c('obs', 'frc', 'delta', 'delta_preci', 'scale', 'eqm', 'gqm')\n#' plotTS(list = TSlist, plot = 'cum')\n#' \n#' \n#' # If the forecasts you extracted only has incontinuous data for certain months and years, e.g.,\n#' # for seasonal forecasting, forecasts only provide 3-6 months data, so the case can be \n#' # for example Dec, Jan and Feb of every year from year 1999-2005.\n#' # In such case, you need to extract certain months and years from observed time series.\n#' # extractPeriod() can be then used.\n#'   \n#'   \n#'\n#'\n#'\n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' \n#' @references \n#' Bias correction methods come from \\code{biasCorrection} from \\code{dowscaleR}\n#' \n#' \\itemize{\n#' \n#' \\item Santander Meteorology Group (2015). downscaleR: Climate data manipulation and statistical downscaling. R\n#' package version 0.6-0. https://github.com/SantanderMetGroup/downscaleR/wiki\n#' \n#' \\item R.A.I. Wilcke, T. Mendlik and A. Gobiet (2013) Multi-variable error correction of regional climate models. Climatic Change, 120, 871-887\n#' \n#' \\item A. Amengual, V. Homar, R. Romero, S. Alonso, and C. Ramis (2012) A Statistical Adjustment of Regional Climate Model Outputs to Local Scales: Application to Platja de Palma, Spain. J. Clim., 25, 939-957\n#' \n#' \\item C. Piani, J. O. Haerter and E. Coppola (2009) Statistical bias correction for daily precipitation in regional climate models over Europe, Theoretical and Applied Climatology, 99, 187-192\n#' \n#' \\item O. Gutjahr and G. Heinemann (2013) Comparing precipitation bias correction methods for high-resolution regional climate simulations using COSMO-CLM, Theoretical and Applied Climatology, 114, 511-529\n#' }\n#' \n#' @author Yuanchao Xu \\email{xuyuanchao37@@gmail.com }\n#' \n#' @export\nsetGeneric('applyBiasFactor', function(frc, biasFactor, obs = NULL) {\n  standardGeneric('applyBiasFactor')\n})\n\n#' @describeIn applyBiasFactor\n#' @importFrom methods setMethod\nsetMethod('applyBiasFactor', signature('data.frame', 'biasFactor'), \n          function(frc, biasFactor, obs) {\n            result <- applyBiasFactor.TS(frc, biasFactor, obs)\n            return(result)\n          })\n           \n#' @describeIn applyBiasFactor\n#' @importFrom methods setMethod\nsetMethod('applyBiasFactor', signature('list', 'biasFactor.hyfo'), \n          function(frc, biasFactor, obs) {\n            result <- applyBiasFactor.list(frc, biasFactor, obs)\n            return(result)\n          })\n\n\n### generic functions\ngetBiasFactor.TS <- function(hindcast, obs, method, scaleType, preci, prThreshold, extrapolate) {\n  \n  if (!grepl('-|/', obs[1, 1]) | !grepl('-|/', hindcast[1, 1])) {\n    stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base} \n         and use as.Date to convert.If your input is a hyfo dataset, put input = \"hyfo\" as an\n         argument, check help for more info.')\n  }\n  \n  # change to date type is easier, but in case in future the flood part is added, Date type doesn't have\n  # hour, min and sec, so, it's better to convert it into POSIxlt.\n  \n  # if condition only accepts one condition, for list comparison, there are a lot of conditions, better\n  # further process it, like using any.\n  if (any(as.POSIXlt(hindcast[, 1]) != as.POSIXlt(obs[, 1]))) {\n    warning('time of obs and time of hindcast are not the same, which may cause inaccuracy in \n            the calibration.')\n  }\n  n <- ncol(hindcast)\n  \n  # For every column, it's biascorrected respectively.\n  biasFactor <- lapply(2:n, function(x) getBiasFactor_core(hindcast[, x], obs[, 2], method = method,\n                                                           scaleType = scaleType, preci = preci, prThreshold = prThreshold, \n                                                           extrapolate = extrapolate))\n  if (n - 1 > 1) {\n    biasFactor_all <- new('biasFactor.multiMember', biasFactor = biasFactor, memberDim = n - 1,\n                          method = method, preci = preci, prThreshold = prThreshold, scaleType = scaleType, \n                          extrapolate = extrapolate)\n    \n  } else {\n    biasFactor_all <- new('biasFactor', biasFactor = biasFactor, method = method, \n                          preci = preci, prThreshold = prThreshold, scaleType = scaleType, \n                          extrapolate = extrapolate)\n  }\n  \n  return(biasFactor_all)\n}\n\ngetBiasFactor.list <- function(hindcast, obs, method, scaleType, preci, prThreshold, extrapolate) {\n  \n  ## Check if the data is a hyfo grid data.\n  checkHyfo(hindcast, obs)\n  \n  hindcastData <- hindcast$Data\n  obsData <- obs$Data\n  \n  ## save frc dimension order, at last, set the dimension back to original dimension\n  hindcastDim <- attributes(hindcastData)$dimensions\n  \n  ## ajust the dimension into general dimension order.\n  obsData <- adjustDim(obsData, ref = c('lon', 'lat', 'time'))\n  \n  ## CheckDimLength, check if all the input dataset has different dimension length\n  # i.e. if they all have the same lon and lat number.\n  checkDimLength(hindcastData, obsData, dim = c('lon', 'lat'))\n  \n  \n  # Now real bias correction is executed.\n  \n  memberIndex <- match('member', attributes(hindcastData)$dimensions)\n  \n  # For dataset that has a member part \n  if (!is.na(memberIndex)) {\n    \n    hindcastData <- adjustDim(hindcastData, ref = c('lon', 'lat', 'time', 'member'))\n    \n    # The following code may speed up because it doesn't use for loop.\n    # It firstly combine different array into one array. combine the time \n    # dimension of frc, hindcast and obs. Then use apply, each time extract \n    # the total time dimension, and first part is frc, second is hindcast, third\n    # is obs. Then use these three parts to bias correct. All above can be written\n    # in one function and called within apply. But too complicated to understand,\n    # So save it for future use maybe.\n    \n    #       for (member in 1:dim(frcData)[4]) {\n    #         totalArr <- array(c(frcData[,,, member], hindcastData[,,, member], obsData),\n    #                           dim = c(dim(frcData)[1], dim(frcData)[2], \n    #                                                        dim(frcData)[3] + dim(hindcastData)[3] + dim(obsData)[3]))\n    #       }\n    \n    biasFactor_all <- vector(mode = \"list\", length = dim(hindcastData)[4])\n    for (member in 1:dim(hindcastData)[4]) {\n      biasFactor_all[[member]] <- vector(mode = 'list', length = dim(hindcastData)[1])\n      for (lon in 1:dim(hindcastData)[1]) {\n        biasFactor_all[[member]][[lon]] <- vector(mode = 'list', length = dim(hindcastData)[2])\n        for (lat in 1:dim(hindcastData)[2]) {\n          biasFactor_all[[member]][[lon]][[lat]] <- getBiasFactor_core(hindcastData[lon, lat,, member], obsData[lon, lat,], method = method,\n                                                                       scaleType = scaleType, preci = preci, prThreshold = prThreshold, \n                                                                       extrapolate = extrapolate)\n        }\n      }\n    }\n    \n    biasFactor <- new('biasFactor.hyfo', biasFactor = biasFactor_all, method = method, preci = preci,\n                      prThreshold = prThreshold, scaleType = scaleType, extrapolate = extrapolate, \n                      lonLatDim = calcuDim(hindcastData, dim = c('lon', 'lat')),\n                      memberDim = calcuDim(hindcastData, dim = 'member'))\n  } else {\n    \n    hindcastData <- adjustDim(hindcastData, ref = c('lon', 'lat', 'time'))\n    \n    biasFactor_all <- vector(mode = 'list', length = dim(hindcastData)[1])\n    for (lon in 1:dim(hindcastData)[1]) {\n      biasFactor_all[[lon]] <- vector(mode = 'list', length = dim(hindcastData)[2]) \n      for (lat in 1:dim(hindcastData)[2]) {\n        biasFactor_all[[lon]][[lat]] <- getBiasFactor_core(hindcastData[lon, lat,], obsData[lon, lat,], method = method,\n                                                           scaleType = scaleType, preci = preci, prThreshold = prThreshold, \n                                                           extrapolate = extrapolate)\n      }\n    }\n    biasFactor <- new('biasFactor.hyfo', biasFactor = biasFactor_all, method = method, preci = preci,\n                      prThreshold = prThreshold, scaleType = scaleType, extrapolate = extrapolate, \n                      lonLatDim = calcuDim(hindcastData, dim = c('lon', 'lat')))\n    \n  }\n  \n  return(biasFactor)\n}\n\napplyBiasFactor.TS <- function(frc, biasFactor, obs) {\n  method <- biasFactor@method\n  preci <- biasFactor@preci\n  prThreshold <- biasFactor@prThreshold\n  scaleType <- biasFactor@scaleType\n  extrapolate <- biasFactor@extrapolate\n  memberDim <- biasFactor@memberDim\n  biasFactor <- biasFactor@biasFactor\n  \n  \n  # First check if the first column is Date\n  if (!grepl('-|/', frc[1, 1])) {\n    stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base} \n         and use as.Date to convert.If your input is a hyfo dataset, put input = \"hyfo\" as an\n         argument, check help for more info.')\n  }\n  # change to date type is easier, but in case in future the flood part is added, Date type doesn't have\n  # hour, min and sec, so, it's better to convert it into POSIxlt.\n  \n  # In this case more than one value columns exist in the dataset, both frc and hindcast.\n  \n  n <- ncol(frc)\n  if (n-1 != memberDim) stop('frc and biasFactor have different members.')\n  \n  \n  # For every column, it's biascorrected respectively.\n  frc_data <- lapply(2:n, function(x) applyBiasFactor_core(frc[, x], biasFactor = biasFactor[[x - 1]], method = method,\n                                                           scaleType = scaleType, preci = preci, prThreshold = prThreshold, \n                                                           extrapolate = extrapolate, obs = obs[, 2]))\n  frc_data <- do.call('cbind', frc_data)\n  rownames(frc_data) <- NULL\n  \n  names <- colnames(frc)\n  frc_new <- data.frame(frc[, 1], frc_data)\n  colnames(frc_new) <- names\n  \n  return(frc_new)\n  \n}\n\napplyBiasFactor.list <- function(frc, biasFactor, obs) {\n  method <- biasFactor@method\n  preci <- biasFactor@preci\n  prThreshold <- biasFactor@prThreshold\n  scaleType <- biasFactor@scaleType\n  extrapolate <- biasFactor@extrapolate\n  lonLatDim <- biasFactor@lonLatDim\n  memberDim <- biasFactor@memberDim\n  biasFactor <- biasFactor@biasFactor\n  \n  ## Check if the data is a hyfo grid data.\n  checkHyfo(frc)\n  \n  \n  obsData <- obs$Data\n  frcData <- frc$Data\n  \n  ## save frc dimension order, at last, set the dimension back to original dimension\n  frcDim <- attributes(frcData)$dimensions\n  \n  ## ajust the dimension into general dimension order.\n  obsData <- adjustDim(obsData, ref = c('lon', 'lat', 'time'))\n  \n  ## CheckDimLength, check if all the input dataset has different dimension length\n  # i.e. if they all have the same lon and lat number.\n  if (!identical(calcuDim(frcData, dim = c('lon', 'lat')), lonLatDim)) {\n    stop('frc data has different lon and lat from hindcast data.')\n  }\n  \n  \n  # Now real bias correction is executed.\n  \n  memberIndex <- match('member', attributes(frcData)$dimensions)\n  \n  # For dataset that has a member part \n  if (!is.na(memberIndex)) {\n    # check if frcData and hindcastData has the same dimension and length.\n    if (calcuDim(frcData, dim = 'member') != memberDim) {\n      stop('frc data has different member number from hindcast.')\n    } \n    \n    frcData <- adjustDim(frcData, ref = c('lon', 'lat', 'time', 'member'))\n    \n    # The following code may speed up because it doesn't use for loop.\n    # It firstly combine different array into one array. combine the time \n    # dimension of frc, hindcast and obs. Then use apply, each time extract \n    # the total time dimension, and first part is frc, second is hindcast, third\n    # is obs. Then use these three parts to bias correct. All above can be written\n    # in one function and called within apply. But too complicated to understand,\n    # So save it for future use maybe.\n    \n    #       for (member in 1:dim(frcData)[4]) {\n    #         totalArr <- array(c(frcData[,,, member], hindcastData[,,, member], obsData),\n    #                           dim = c(dim(frcData)[1], dim(frcData)[2], \n    #                                                        dim(frcData)[3] + dim(hindcastData)[3] + dim(obsData)[3]))\n    #       }\n    \n    \n    for (member in 1:dim(frcData)[4]) {\n      for (lon in 1:dim(frcData)[1]) {\n        for (lat in 1:dim(frcData)[2]) {\n          frcData[lon, lat,, member] <- applyBiasFactor_core(frcData[lon, lat,,member], biasFactor = biasFactor[[member]][[lon]][[lat]], method = method,\n                                                             scaleType = scaleType, preci = preci, prThreshold = prThreshold, \n                                                             extrapolate = extrapolate, obs = obsData[lon, lat,])\n        }\n      }\n    }\n  } else {\n    frcData <- adjustDim(frcData, ref = c('lon', 'lat', 'time'))\n    for (lon in 1:dim(frcData)[1]) {\n      for (lat in 1:dim(frcData)[2]) {\n        frcData[lon, lat,] <- applyBiasFactor_core(frcData[lon, lat,], biasFactor = biasFactor[[lon]][[lat]], method = method,\n                                                   scaleType = scaleType, preci = preci, prThreshold = prThreshold, \n                                                   extrapolate = extrapolate, obs = obsData[lon, lat,])\n      }\n    }\n  }\n  \n  frcData <- adjustDim(frcData, ref = frcDim)\n  frc$Data <- frcData\n  frc$biasCorrected_by <- method\n  frc_new <- frc\n  \n  return(frc_new)\n}\n\n\n#################\n################# core functions for multi bias correction.\n\n#' @importFrom MASS fitdistr\n#' @importFrom stats ecdf quantile pgamma qgamma rgamma\n#' \n#' @references \n#' Bias correction methods come from \\code{biasCorrection} from \\code{dowscaleR}\n#' \n#' \\itemize{\n#' \n#' \\item Santander Meteorology Group (2015). downscaleR: Climate data manipulation and statistical downscaling. R\n#' package version 0.6-0. https://github.com/SantanderMetGroup/downscaleR/wiki\n#' \n#' \\item R.A.I. Wilcke, T. Mendlik and A. Gobiet (2013) Multi-variable error correction of regional climate models. Climatic Change, 120, 871-887\n#' \n#' \\item A. Amengual, V. Homar, R. Romero, S. Alonso, and C. Ramis (2012) A Statistical Adjustment of Regional Climate Model Outputs to Local Scales: Application to Platja de Palma, Spain. J. Clim., 25, 939-957\n#' \n#' \\item C. Piani, J. O. Haerter and E. Coppola (2009) Statistical bias correction for daily precipitation in regional climate models over Europe, Theoretical and Applied Climatology, 99, 187-192\n#' \n#' \\item O. Gutjahr and G. Heinemann (2013) Comparing precipitation bias correction methods for high-resolution regional climate simulations using COSMO-CLM, Theoretical and Applied Climatology, 114, 511-529\n#' }\ngetBiasFactor_core <- function(hindcast, obs, method , scaleType, preci, prThreshold, extrapolate){\n  # If the variable is precipitation, some further process needs to be added.\n  # The process is taken from downscaleR, to provide a more reasonable hindcast, used in the calibration.\n  \n  \n  # check if frc, hindcast or obs are all na values\n  if (!any(!is.na(obs)) | !any(!is.na(hindcast))) {\n    warning('In this cell, hindcast or obs data is missing. No biasCorrection for this cell.')\n    return(NA)\n  } \n  \n  if (preci == TRUE) {\n    preprocessHindcast_res <- preprocessHindcast(hindcast = hindcast, obs = obs, prThreshold = prThreshold)\n    hindcast <- preprocessHindcast_res[[1]]\n    minHindcastPreci <- preprocessHindcast_res[[2]]\n  }\n  \n  # default is the simplest method in biascorrection, just do simple addition and subtraction.\n  if (method == 'delta') {\n    biasFactor <- getBiasFactor_core_delta(hindcast)\n  } else if (method == 'scaling') {\n    biasFactor <- getBiasFactor_core_scaling(hindcast, obs, scaleType)\n  } else if (method == 'eqm') {\n    # In this method, the value is bounded by the observation\n    # Preci or not both have the same biasFactor\n    if (preci == FALSE) {\n      biasFactor <- getBiasFactor_core_eqm_nonPreci(hindcast, obs, extrapolate)\n    } else {\n      biasFactor <- getBiasFactor_core_eqm_preci(hindcast, obs, minHindcastPreci, extrapolate, prThreshold)\n    }\n    \n    \n  } else if (method == 'gqm') {\n    if (preci == FALSE) stop ('gqm method only applys to precipitation, please set preci = T')\n    biasFactor <- getBiasFactor_core_gqm(hindcast, obs, prThreshold, minHindcastPreci)\n  }\n  \n  if (preci == TRUE) biasFactor$minHindcastPreci <- minHindcastPreci\n  \n  return(biasFactor)\n}\n\n\napplyBiasFactor_core <- function(frc, biasFactor, method, preci, prThreshold, scaleType,\n                                 extrapolate, obs = NULL) {\n  \n  if (!any(!is.na(biasFactor))) {\n    warning('In this cell, biasFactor is missing.No biasCorrection for this cell.')\n    # here return NA or return the unprocessed frc, both are OK. But return NA is more\n    # obvious for user.\n    return(NA)\n  }\n  \n  if (method == 'delta') {\n    if (is.null(obs)) stop('This method needs obs input.')\n    if (length(frc) != length(obs)) stop('This method needs frc data have the same length as obs data.')\n    frc <- applyBiasFactor_core_delta(frc = frc, biasFactor = biasFactor, obs = obs)\n  } else if (method == 'scaling') {\n    frc <- applyBiasFactor_core_scaling(frc = frc, biasFactor = biasFactor, scaleType = scaleType)\n  } else if (method == 'eqm') {\n    if (is.null(obs)) stop('This method needs obs input.')\n    if (preci == FALSE) {\n      frc <- applyBiasFactor_core_eqm_nonPreci(frc = frc, biasFactor = biasFactor, extrapolate = extrapolate, \n                                               obs = obs)\n    } else {\n      frc <- applyBiasFactor_core_eqm_preci(frc = frc, biasFactor = biasFactor, extrapolate = extrapolate, \n                                            prThreshold = prThreshold, obs = obs)\n    }\n  } else if (method == 'gqm') {\n    frc <- applyBiasFactor_core_gqm(frc = frc, biasFactor = biasFactor)\n  }\n  \n  return(frc)\n}\n\n\ngetBiasFactor_core_delta <- function(hindcast) {\n  biasFactor <- list()\n  biasFactor$hindcastMean <- mean(hindcast, na.rm = TRUE)\n  return(biasFactor)\n}\napplyBiasFactor_core_delta <- function(frc, biasFactor, obs) {\n  hindcastMean <- biasFactor$hindcastMean\n  frcMean <- mean(frc, na.rm = TRUE)\n  return(obs - hindcastMean + frcMean)\n}\n\ngetBiasFactor_core_scaling <- function(hindcast, obs, scaleType) {\n  biasFactor <- list()\n  \n  hindcastMean <- mean(hindcast, na.rm = TRUE)\n  obsMean <- mean(obs, na.rm = TRUE)\n  \n  if (scaleType == 'multi') {\n    biasFactor$scale <- obsMean / hindcastMean\n    \n  } else if (scaleType == 'add') {\n    biasFactor$scale <- obsMean - hindcastMean\n  }\n  \n  return(biasFactor)\n}\n\napplyBiasFactor_core_scaling <- function(frc, biasFactor, scaleType) {\n  \n  if (scaleType == 'multi') {\n    frc <- frc * biasFactor$scale\n    \n  } else if (scaleType == 'add') {\n    frc <- frc + biasFactor$scale\n  }\n  return(frc)\n}\n\ngetBiasFactor_core_eqm_nonPreci <- function(hindcast, obs, extrapolate) {\n  \n  biasFactor <- list()\n  biasFactor$ecdfHindcast <- ecdf(hindcast)\n  \n  if (extrapolate == 'constant') {\n    biasFactor$maxHindcast <- max(hindcast, na.rm = TRUE)\n    biasFactor$minHindcast <- min(hindcast, na.rm = TRUE)\n    biasFactor$higherIndex_dif <- biasFactor$maxHindcast - max(obs, na.rm = TRUE)\n    biasFactor$lowerIndex_dif <- biasFactor$minHindcast - min(obs, na.rm = TRUE)\n  }\n  \n  return(biasFactor)\n}\n\ngetBiasFactor_core_eqm_preci <- function(hindcast, obs, minHindcastPreci, extrapolate,\n                                         prThreshold) {\n  \n  biasFactor <- list()\n  biasFactor$ecdfHindcast <- ecdf(hindcast[hindcast > minHindcastPreci])\n  \n  if (extrapolate == 'constant') {\n    biasFactor$maxHindcast <- max(hindcast, na.rm = TRUE)\n    biasFactor$minHindcast <- min(hindcast, na.rm = TRUE)\n    biasFactor$higherIndex_dif <- biasFactor$maxHindcast - max(obs, na.rm = TRUE)\n    biasFactor$lowerIndex_dif <- biasFactor$minHindcast - min(obs, nna.rm = TRUE)\n  }\n  biasFactor$availableHindcastLength <- length(which(hindcast > minHindcastPreci))\n  \n  # drizzle parameter 1\n  biasFactor$drizzleP1 <- min(hindcast[hindcast > minHindcastPreci], na.rm = TRUE)\n  # biasFactor$prThreshold <- prThreshold\n  return(biasFactor)\n}\n\napplyBiasFactor_core_eqm_nonPreci <- function(frc, biasFactor, extrapolate, obs) {\n  ecdfHindcast <- biasFactor$ecdfHindcast\n  \n  if (extrapolate == 'constant') {\n    higherIndex <- which(frc > biasFactor$maxHindcast)\n    lowerIndex <- which(frc < biasFactor$minHindcast)\n    \n    extrapolateIndex <- c(higherIndex, lowerIndex)\n    non_extrapolateIndex <- setdiff(1:length(frc), extrapolateIndex)\n    \n    # In case extrapolateIndex is of length zero, than extrapolate cannot be used afterwards\n    # So use setdiff(1:length(sim), extrapolateIndex), if extrapolateIndex == 0, than it will\n    # return 1:length(sim)\n    \n    if (length(higherIndex) > 0) {\n      \n      frc[higherIndex] <- frc[higherIndex] - biasFactor$higherIndex_dif\n    }\n    \n    if (length(lowerIndex) > 0) {\n      \n      frc[lowerIndex] <- frc[lowerIndex] - biasFactor$lowerIndex_dif\n    }\n    \n    frc[non_extrapolateIndex] <- quantile(obs, probs = ecdfHindcast(frc[non_extrapolateIndex]), \n                                          na.rm = TRUE, type = 4)\n  } else {\n    frc <- quantile(obs, probs = ecdfHindcast(frc), na.rm = TRUE, type = 4)\n  }\n  return(frc)\n}\n\n#' @importFrom stats quantile\napplyBiasFactor_core_eqm_preci <- function(frc, biasFactor, extrapolate, prThreshold, obs) {\n  \n  # Most of time this condition seems useless because minHindcastPreci comes from hindcast, so there will be\n  # always hindcast > minHindcastPreci exists.\n  # Unless one condition that minHindcastPreci is the max in the hindcast, than on hindcast > minHindcastPreci\n  if (biasFactor$availableHindcastLength > 0) {\n    \n    ecdfHindcast <- biasFactor$ecdfHindcast\n    \n    noRain <- which(frc <= biasFactor$minHindcastPreci & !is.na(frc))\n    rain <- which(frc > biasFactor$minHindcastPreci & !is.na(frc))\n    \n    # drizzle is to see whether there are some precipitation between the min frc (over threshold) and \n    # min hindcast (over threshold).\n    drizzle <- which(frc > biasFactor$minHindcastPreci & frc <= biasFactor$drizzleP1 & !is.na(frc))\n    \n    if (length(rain) > 0) {\n      ecdfFrc <- ecdf(frc[rain])\n      \n      if (extrapolate == 'constant') {\n        \n        # This higher and lower index mean the extrapolation part\n        higherIndex <- which(frc[rain] > biasFactor$maxHindcast)\n        lowerIndex <- which(frc[rain] < biasFactor$minHindcast)\n        \n        extrapolateIndex <- c(higherIndex, lowerIndex)\n        non_extrapolateIndex <- setdiff(1:length(rain), extrapolateIndex)\n        \n        if (length(higherIndex) > 0) {\n          frc[rain[higherIndex]] <- frc[higherIndex] - biasFactor$higherIndex_dif\n        }\n        \n        if (length(lowerIndex) > 0) {\n          frc[rain[lowerIndex]] <- frc[lowerIndex] - biasFactor$lowerIndex_dif\n        }\n        \n        \n        # Here the original function doesn't accout for the situation that extraploateIndex is 0\n        # if it is 0, rain[-extraploateIndex] would be nothing\n        \n        # Above has been solved by using setdiff.\n        frc[rain[non_extrapolateIndex]] <- quantile(obs[which(obs > prThreshold & !is.na(obs))], \n                                                    probs = ecdfHindcast(frc[rain[non_extrapolateIndex]]), \n                                                    na.rm = TRUE, type = 4)\n        \n      } else {\n        \n        frc[rain] <- quantile(obs[which(obs > prThreshold & !is.na(obs))], \n                              probs = ecdfHindcast(frc[rain]), na.rm = TRUE, type = 4)\n      }\n    }\n    if (length(drizzle) > 0){\n      \n      # drizzle part is a seperate part. it use the ecdf of frc (larger than minHindcastPreci) to \n      # biascorrect the original drizzle part \n      frc[drizzle] <- quantile(frc[which(frc > biasFactor$drizzleP1 & !is.na(frc))], \n                               probs = ecdfFrc(frc[drizzle]), na.rm = TRUE, \n                               type = 4)\n    }\n    \n    frc[noRain] <- 0\n    \n  } else {\n    # in this condition minHindcastPreci is the max of hindcast, so all hindcast <= minHindcastPreci\n    # And frc distribution is used then.\n    noRain <- which(frc <= biasFactor$minHindcastPreci & !is.na(frc))\n    rain <- which(frc > biasFactor$minHindcastPreci & !is.na(frc))\n    \n    if (length(rain) > 0) {\n      ecdfFrc <- ecdf(frc[rain])\n      frc[rain] <- quantile(obs[which(obs > prThreshold & !is.na(obs))], probs = ecdfFrc(frc[rain]), \n                            na.rm = TRUE, type = 4)\n    }\n    frc[noRain]<-0\n  }\n  return(frc)\n}\n\n#' @importFrom MASS fitdistr\ngetBiasFactor_core_gqm <- function(hindcast, obs, prThreshold, minHindcastPreci) {\n  if (any(obs > prThreshold)) {\n    biasFactor <- list()\n    ind <- which(obs > prThreshold & !is.na(obs))\n    obsGamma <- fitdistr(obs[ind],\"gamma\")\n    biasFactor$obsShape <- obsGamma$estimate[1]\n    biasFactor$obsRate <- obsGamma$estimate[2]\n    \n    ind <- which(hindcast > 0 & !is.na(hindcast))\n    hindcastGamma <- fitdistr(hindcast[ind],\"gamma\")\n    biasFactor$hindcastShape <- hindcastGamma$estimate[1]\n    biasFactor$hindcastRate <- hindcastGamma$estimate[2]\n    biasFactor$minHindcastPreci <- minHindcastPreci\n    \n  } else {\n    warning('All the observations of this cell(station) are lower than the threshold, \n            no biasFactor returned.')\n    biasFactor <- NA\n  }\n  return(biasFactor)\n}\n\n#' @importFrom stats pgamma qgamma\napplyBiasFactor_core_gqm <- function(frc, biasFactor) {\n  \n  rain <- which(frc > biasFactor$minHindcastPreci & !is.na(frc))\n  noRain <- which(frc <= biasFactor$minHindcastPreci & !is.na(frc))\n  \n  probF <- pgamma(frc[rain], biasFactor$hindcastShape, rate = biasFactor$hindcastRate)\n  frc[rain] <- qgamma(probF, biasFactor$obsShape, rate = biasFactor$obsRate)\n  frc[noRain] <- 0\n  \n  return(frc)\n}",
    "created" : 1446994263124.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "1852951685",
    "id" : "17C4CBA0",
    "lastKnownWriteTime" : 1446995325,
    "path" : "E:/1/R/hyfo/R/multi-biasCorrect(generic).R",
    "project_path" : "R/multi-biasCorrect(generic).R",
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "type" : "r_source"
}