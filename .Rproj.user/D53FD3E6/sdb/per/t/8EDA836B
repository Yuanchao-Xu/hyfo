{
    "contents" : "#' Get spatial map of the input dataset.\n#' \n#' @param dataset A list containing different information, should be the result of reading netcdf file using\n#' \\code{loadNcdf}.\n#' @param method A string showing different calculating method for the map. More information please refer to\n#' details.\n#' @param member A number showing which member is selected to get, if the dataset has a \"member\" dimension. Default\n#' is NULL, if no member assigned, and there is a \"member\" in dimensions, the mean value of the members will be\n#' taken.\n#' @param ...  several arguments including x, y, title, catchment, point, output, name, info, scale, color, \n#' type in \\code{?getSpatialMap_mat} for details.\n#' @return A matrix representing the raster map is returned, and the map is plotted.\n#' @details\n#' There are following methods to be selected, \n#' \"meanAnnual\": annual rainfall of each year is plotted.  \n#' \"winter\", \"spring\", \"autumn\", \"summer\": MEAN seasonal rainfall of each year is plotted.\n#' Month(number 1 to 12): MEAN month rainfall of each year is plotted, e.g. MEAN march rainfall of each year.\n#' \"mean\", \"max\", \"min\": mean daily, maximum daily, minimum daily precipitation.\n#' @examples\n#' \n#' \n#' \\dontrun{\n#' #gridData provided in the package is the result of \\code {loadNcdf}\n#' data(tgridData)\n#' getSpatialMap(tgridData, method = 'meanAnnual')\n#' getSpatialMap(tgridData, method = 'winter')\n#' \n#' \n#' getSpatialMap(tgridData, method = 'winter', catchment = testCat)\n#' \n#' file <- system.file(\"extdata\", \"point.txt\", package = \"hyfo\")\n#' point <- read.table(file, header = TRUE, sep = ',' )\n#' getSpatialMap(tgridData, method = 'winter', catchment = testCat, point = point)\n#' }\n#' \n#' \n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' @export\ngetSpatialMap <- function(dataset, method = NULL, member = 'mean', ...) {\n\n  #check input dataset\n  checkHyfo(dataset)\n  \n  #range of the dataset just loaded \n  lon <- dataset$xyCoords$x\n  lat <- dataset$xyCoords$y\n  startTime <- as.POSIXlt(dataset$Dates$start, tz = 'GMT')\n  yearIndex <- startTime$year + 1900\n  monthIndex <-startTime$mon + 1\n  data <- dataset$Data\n  \n  # Dimension needs to be arranged. Make sure first and second dimension is lat and lon.\n  data <- adjustDim(data, ref = c('lon', 'lat', 'time'))\n  \n  # Because in the following part, only 3 dimensions are allowed, so data has to be processed.\n  if (member == 'mean' & any(attributes(data)$dimensions == 'member')) {\n    dimIndex3 <- which(attributes(data)$dimensions != 'member')\n    data <- apply(data, MARGIN = dimIndex3, FUN = mean, na.rm = TRUE)\n    message('Mean value of the members are returned.')\n    \n  } else if (member != 'mean' & any(attributes(data)$dimensions == 'member')) {\n    dimIndex3 <- which(attributes(data)$dimensions == 'member')\n    data <- chooseDim(data, dimIndex3, member, drop = TRUE)\n    \n  } else if (member != 'mean' & !any(attributes(data)$dimensions == 'member')){\n    stop('There is no member part in the dataset, but you choose one, check the input\n         dataset or change your arguments.')\n  }\n  \n  \n  \n  \n  if (is.null(method)) {\n    \n    warning('You should shoose a method, unless input is a matrix directly to be plotted.')\n    #in case the dataset is ready to plot and no need to calculate\n    \n  } else if (method == 'meanAnnual') { \n    #mean value of the annual precipitation over the period of the data \n    #time <- proc.time()\n    if (length(unique(monthIndex)) < 12) {\n      warning ('There are less than 12 months in a year, the results may be inaccurate.')\n    }\n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex,  method = 'annual')\n    #newTime <- proc.time() - time\n    title_d  <- 'Mean Annual Precipitation (mm / year)'\n    \n  } else if (method == 'winter') {\n    #mean value of the seasonal precipitation, in this case, winter \n    #time <- proc.time()\n    wm <- match(c(12, 1, 2), unique(monthIndex))\n    if (length(which(!is.na(wm))) < 3) {\n      stop ('Winter has less than 3 months, check data and try to calculate every month\n  seperately or choose another season.')\n    }\n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'winter')\n    #newTime <- proc.time() - time\n    title_d <- 'Mean Winter Precipitation (mm / winter)'\n    \n  } else if (method == 'spring') {\n    wm <- match(c(3, 4, 5), unique(monthIndex))\n    if (length(which(!is.na(wm))) < 3) {\n      stop ('Spring has less than 3 months, check data and try to calculate every month\n  seperately or choose another season.')\n    }\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'spring')    \n    title_d <- 'Mean Spring Precipitation (mm / spring)'\n    \n  } else if (method == 'summer') {\n    wm <- match(c(6, 7, 8), unique(monthIndex))\n    if (length(which(!is.na(wm))) < 3) {\n      stop ('Summer has less than 3 months, check data and try to calculate every month\n  seperately or choose another season.')\n    }\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'summer')    \n    title_d <- 'Mean Summer Precipitation (mm / summer)'\n    \n  } else if (method == 'autumn') {\n    \n    wm <- match(c(9, 10, 11), unique(monthIndex))\n    if (length(which(!is.na(wm))) < 3) {\n      stop ('Autumn has less than 3 months, check data and try to calculate every month\n  seperately or choose another season.')\n    }\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'autumn')    \n    title_d <- 'Mean Autumn Precipitation (mm / autumn)'\n    \n  } else if (method == 'mean') {\n    \n    #sum value of the dataset, this procedure is to get the mean value\n    data_new <- apply(data, MARGIN = c(2, 1), FUN = mean, na.rm = TRUE)\n    title_d <- 'Mean Daily Precipitation (mm / day)'\n    \n  } else if (method == 'max') {\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = suppressWarnings(max), na.rm = TRUE)\n    title_d <- 'Max Daily Precipitation (mm / day)'\n    \n  } else if (method == 'min') {\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = suppressWarnings(min), na.rm = TRUE)\n    title_d <- 'Min Daily Precipitation (mm / day)'\n    \n  } else if (is.numeric(method)) {\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = method)    \n    title_d <- paste(month.abb[method], 'Precipitation (mm / month)', sep = ' ')\n    \n  } else {\n    wrongMethod <- method\n    stop(paste('no method called', wrongMethod))\n  }\n  # This is to give attributes to the matrix and better be melted in ggplot.\n  colnames(data_new) <- round(lon, 2)\n  rownames(data_new) <- round(lat, 2)\n  \n  # If ... also has a title argument, this will cause conflicts. so title has to be renamed as title_d\n  # This has to be paid a lot of attention when use ... to pass arguments.\n  output <- getSpatialMap_mat(matrix = data_new, title_d = title_d, ...)\n  return(output)\n}\n\n\n\n\n\n#' Replot raster matrix\n#' \n#' replot the matrix output from \\code{getSpatialMap}, when \\code{output = 'data'} or output is default\n#' value.\n#' \n#' @param matrix A matrix raster, should be the result of \\code{getSpatialMap()}, output should be default\n#' or 'data'\n#' @param title_d A string showing the title of the plot, defaut is NULL.\n#' @param catchment A catchment file geting from \\code{shp2cat()} in the package, if a catchment is available for background.\n#' @param point A dataframe, showing other information, e.g., location of the gauging stations. The \n#' the data.frame should be with columes \"name, lon, lat, z, value\".\n#' @param output A string showing the type of the output, if \\code{output = 'ggplot'}, the returned \n#' data can be used in ggplot and \\code{getSpatialMap_comb()}; if \\code{output = 'plot'}, the returned data is the plot containing all \n#' layers' information, and can be plot directly or used in grid.arrange; if not set, the raster matrix data\n#' will be returned.\n#' @param name If \\code{output = 'ggplot'}, name has to be assigned to your output, in order to differentiate\n#' different outputs in the later multiplot using \\code{getSpatialMap_comb}.\n#' @param info A boolean showing whether the information of the map, e.g., max, mean ..., default is FALSE.\n#' @param scale A string showing the plot scale, 'identity' or 'sqrt'.\n#' @param color Most of time you don't have to set this, but if you are not satisfied with the \n#' default color, you can set your own palette here. e.g., \\code{color = c('red', 'blue')}, then\n#' the value from lowest to highest, will have the color from red to blue. More info about color,\n#' please check ?palette().\n#' @param ... \\code{title, x, y} showing the title and x and y axis of the plot. e.g. \\code{title = 'aaa'}\n#'default is about precipitation.\n#' @return A matrix representing the raster map is returned, and the map is plotted.\n#' @examples\n#' \n#' \\dontrun{\n#' data(tgridData)# the result of \\code{loadNcdf}\n#' #the output type of has to be default or 'data'.\n#' a1 <- getSpatialMap(tgridData, method = 'mean')\n#' a2 <- getSpatialMap(tgridData, method = 'max')\n#' a3 <- getSpatialMap(tgridData, method = 'winter')\n#' a4 <- getSpatialMap(tgridData, method = 'summer')\n#' #For example, if we want to investigate the difference between mean value and max.\n#' \n#' a5 <- a2 - a1\n#' getSpatialMap_mat(a4)\n#' \n#' #Or to investigate the difference between winter value and summer value.\n#' a6 <- a3 - a4\n#' getSpatialMap_mat(a6)\n#' \n#' }\n#' \n#' \n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' @export\n#' @import ggplot2 plyr maps maptools rgeos\n#' @importFrom stats median\n#' @importFrom reshape2 melt\n#' @references \n#' \n#' \\itemize{\n#' \\item R Core Team (2015). R: A language and environment for statistical computing. R Foundation for\n#' Statistical Computing, Vienna, Austria. URL http://www.R-project.org/.\n#' \n#' \\item Hadley Wickham (2007). Reshaping Data with the reshape Package. Journal of Statistical Software,\n#' 21(12), 1-20. URL http://www.jstatsoft.org/v21/i12/.\n#' \n#' \\item Hadley Wickham (2011). The Split-Apply-Combine Strategy for Data Analysis. Journal of Statistical\n#' Software, 40(1), 1-29. URL http://www.jstatsoft.org/v40/i01/.\n#' \n#' \\item Original S code by Richard A. Becker and Allan R. Wilks. R version by Ray Brownrigg. Enhancements\n#' by Thomas P Minka <tpminka at media.mit.edu> (2015). maps: Draw Geographical Maps. R package version\n#' 2.3-11. http://CRAN.R-project.org/package=maps\n#' \n#' \\item Roger Bivand and Nicholas Lewin-Koh (2015). maptools: Tools for Reading and Handling Spatial\n#' Objects. R package version 0.8-36. http://CRAN.R-project.org/package=maptools\n#' \n#' \\item Roger Bivand and Colin Rundel (2015). rgeos: Interface to Geometry Engine - Open Source (GEOS). R\n#' package version 0.3-11. http://CRAN.R-project.org/package=rgeos\n#' \n#' }\n#' \n#' \n#' \n#' \n#' \ngetSpatialMap_mat <- function(matrix, title_d = NULL, catchment = NULL, point = NULL, output = 'data', \n                              name = NULL, info = FALSE, scale = 'identity', color = NULL, ...) {\n  #check input\n  checkWord <- c('lon', 'lat', 'z', 'value')\n  if (is.null(attributes(matrix)$dimnames)) {\n    stop('Input matrix is incorrect, check help to know how to get the matrix.')\n  } else if (!is.null(catchment) & class(catchment) != \"SpatialPolygonsDataFrame\") {\n    stop('Catchment format is incorrect, check help to get more details. ')\n  } else if (!is.null(point) & any(is.na(match(checkWord, attributes(point)$names)))) {\n    stop('point should be a dataframe with colnames \"lon, lat, z, value\".')\n  }\n  \n  #ggplot\n  #for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function\n  #get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use \n  #data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available \n  #in the environment.\n  #in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them\n  #outside aes() as normal parameters.\n  \n  if (info == TRUE) {  \n    plotMax <- round(max(matrix, na.rm = TRUE), 2)\n    plotMin <- round(min(matrix, na.rm = TRUE), 2)\n    plotMean <- round(mean(matrix, na.rm = TRUE), 2)\n    plotMedian <- round(median(matrix, na.rm = TRUE), 2)\n    word <- paste('\\n\\n', paste('Max', '=', plotMax), ',', paste('Min', '=', plotMin), ',',\n                  paste('Mean', '=', plotMean), ',', paste('Median', '=', plotMedian))\n  } else {\n    word <- NULL\n  }\n  \n  x_word <- paste('Longitude', word)\n  world_map <- map_data('world')\n  \n  # For some cases, matrix has to be reshaped, because it's too fat or too slim, to make\n  # it shown on the map, the ratio is x : y is 4 : 3.\n  matrix <- reshapeMatrix(matrix)\n  \n  \n  # cannot remove NA, or the matrix shape will be changed.\n  data_ggplot <- melt(matrix, na.rm = FALSE) \n  \n  colnames(data_ggplot) <- c('lat', 'lon', 'value')\n  theme_set(theme_bw())\n  \n  if (is.null(color)) color <- c('yellow', 'orange', 'red')\n  # if (is.null(color)) color <- rev(rainbow(n = 20, end = 0.7))\n  \n  mainLayer <- with(data_ggplot, {\n    \n    ggplot(data = data_ggplot) +\n    geom_tile(aes(x = lon, y = lat, fill = value)) +\n    #scale_fill_discrete()+\n    scale_fill_gradientn(colours = color, na.value = 'transparent') +#usually scale = 'sqrt'\n                        #guide = guide_colorbar, colorbar and legend are not the same.\n    guides(fill = guide_colourbar(title='Rainfall (mm)', barheight = rel(9), trans = scale)) +#usually scale = 'sqrt'\n    geom_map(data = world_map, map = world_map, aes(map_id = region), fill = 'transparent', \n             color='black') +\n    #    guides(fill = guide_colorbar(title='Rainfall (mm)', barheight = 15))+\n    xlab(x_word) +\n    ylab('Latitude') +\n    ggtitle(title_d) +\n    labs(empty = NULL, ...) +#in order to pass \"...\", arguments shouldn't be empty.\n    theme(plot.title = element_text(size = rel(1.8), face = 'bold'),\n          axis.title.x = element_text(size = rel(1.7)),\n          axis.title.y = element_text(size = rel(1.7)),\n          axis.text.x = element_text(size = rel(1.9)),\n          axis.text.y = element_text(size = rel(1.9)),\n          legend.text = element_text(size = rel(1.3)),\n          legend.title = element_text(size = rel(1.3)))\n#    coord_fixed(ratio = 1, xlim = xlim, ylim = ylim)\n    \n#   geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),\n#             xmax=min(lon)+0.99*(max(lon)-min(lon)),\n#             ymin=min(lat)+0.02*(max(lat)-min(lat)),\n#             ymax=min(lat)+0.28*(max(lat)-min(lat)),\n#             fill='white',colour='black')+\n#   annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)\n  \n  })\n  \n  printLayer <- mainLayer\n  \n  #catchment conversion\n  if (is.null(catchment) == FALSE) {\n    a <- catchment\n    a@data$id <- rownames(a@data)\n    b <- fortify(a, region = 'id')\n    c <- join(b, a@data, by = 'id')\n    catchmentLayer <- with(c, {\n      geom_polygon(data = c, aes(long, lat, group = group), color = 'black', \n                                   fill = 'transparent')\n    })\n      \n    \n    printLayer <- printLayer + catchmentLayer\n  }\n  #plot point\n  if (is.null(point) == FALSE) {\n    pointLayer <- with(point, {\n      geom_point(data = point, aes(x = lon, y = lat, size = value, colour = z),\n                 guide = guide_legend(barheight = rel(3)))\n        \n        \n    })\n    \n    printLayer <- printLayer + pointLayer\n  }\n  \n  print(printLayer)\n  \n  if (output == 'ggplot') {\n    if (is.null(name)) stop('\"name\" argument not found, \n                            If you choose \"ggplot\" as output, please assign a name.')\n    data_ggplot$Name <- rep(name, dim(data_ggplot)[1])\n    return (data_ggplot)\n  } else if (output == 'plot') {\n    return(printLayer)\n  } else {\n    return(matrix)\n  }\n}\n\n\n#' Combine maps together\n#' @param ... different maps generated by \\code{getSpatialMap(, output = 'ggplot')}, see details.\n#' @param nrow A number showing the number of rows.\n#' @param list If input is a list containing different ggplot data, use \\code{list = inputlist}.\n#' @param x A string of x axis name.\n#' @param y A string of y axis name.\n#' @param title A string of the title.\n#' @param output A boolean, if chosen TRUE, the output will be given.\n#' @return A combined map.\n#' @examples\n#' \n#' \n#' \\dontrun{\n#' data(tgridData)# the result of \\code{\\link{loadNcdf}}\n#' #The output should be 'ggplot'\n#' a1 <- getSpatialMap(tgridData, method = 'summer', output = 'ggplot', name = 'a1')\n#' a2 <- getSpatialMap(tgridData, method = 'winter', output = 'ggplot', name = 'a2')\n#' a3 <- getSpatialMap(tgridData, method = 'mean', output = 'ggplot', name = 'a3')\n#' a4 <- getSpatialMap(tgridData, method = 'max', output = 'ggplot', name = 'a4')\n#' getSpatialMap_comb(a1, a2)\n#' \n#' # or you can put them into a list.\n#' getSpatialMap_comb(list = list(a1, a2), nrow = 2)\n#' }\n#' \n#' \n#' \n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' @details\n#' For \\code{getSpatialMap_comb}, the maps to be compared should be with same size and resolution, \n#' in other words, they should be fully overlapped by each other.\n#' \n#' If they have different resolutions, use \\code{interpGridData{ecomsUDG.Raccess}} to interpolate.\n#' \n#' @export\n#' @import ggplot2 maps\n#' @references \n#' \n#' \\itemize{\n#' \\item H. Wickham. ggplot2: elegant graphics for data analysis. Springer New York, 2009.\n#' }\ngetSpatialMap_comb <- function(..., list = NULL, nrow = 1, x = '', y = '', title = '', \n                               output = FALSE) {\n  \n  \n  if (!is.null(list)) {\n    data_ggplot <- do.call('rbind', list)\n  } else {\n    maps <- list(...)\n    checkBind(maps, 'rbind')\n    data_ggplot <- do.call('rbind', maps)\n  }\n  \n  if (!class(data_ggplot) == 'data.frame') {\n    warning('Your input is probably a list, but you forget to add \"list = \" before it.\n            Try again, or check help for more information.')\n  } else if (is.null(data_ggplot$Name)) {\n    stop('No \"Name\" column in the input data, check the arguments in getSpatialMap(), if \n         output = \"ggplot\" is assigned, more info please check ?getSpatialMap().')\n  }\n  \n  data_ggplot$Name <- factor(data_ggplot$Name, levels = unique(data_ggplot$Name), ordered = TRUE)\n  \n#   lim <- getLim(data_ggplot$lon, data_ggplot$lat)\n#   xlim <- lim[[1]]                                  \n#   ylim <- lim[[2]]\n  \n  world_map <- map_data('world')\n  theme_set(theme_bw())\n  mainLayer <- with(data_ggplot, {\n    ggplot(data = data_ggplot) + \n    geom_tile(aes(x = lon, y = lat, fill = value)) +\n    #scale_fill_gradient(high = 'red', low = 'yellow')+\n    scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent') +#usually scale = 'sqrt'\n    geom_map(data = world_map, map = world_map, aes(map_id = region), fill = 'transparent', color = 'black') +\n#    guides(fill = guide_colourbar(title='Rainfall (mm)', barheight = rel(9), trans = scale)) +#\n    facet_wrap(~ Name, nrow = nrow) +\n    theme(plot.title = element_text(size = rel(1.8), face = 'bold'),\n          axis.title.x = element_text(size = rel(1.7)),\n          axis.title.y = element_text(size = rel(1.7)),\n          axis.text.x = element_text(size = rel(1.9)),\n          axis.text.y = element_text(size = rel(1.9)),\n          legend.text = element_text(size = rel(1.3)),\n          legend.title = element_text(size = rel(1.3))) +\n    # no solultion for some very fat or very slim, in facet ggplot2, so, it's not buitiful.\n    #coord_equal() +\n    labs(x = x, y = y, title = title)\n  })\n  \n  \n  suppressWarnings(print(mainLayer))\n  \n  if (output == TRUE) return(data_ggplot)\n}\n\n\n\nreshapeMatrix <- function(matrix) {\n  # This is for the map plot to keep the ratio x : y == 4:3\n  # mainly used in map plot in ggplot2.\n  \n  \n  # So the input matrix should be reshaped, add in some NA values, \n  # in order to be shown appropriately in ggplot.\n  \n  lon <- as.numeric(colnames(matrix))\n  lat <- as.numeric(rownames(matrix))\n  \n  dx <- mean(diff(lon))\n  dy <- mean(diff(lat))\n  \n  lx <- max(lon) - min(lon)\n  ly <- max(lat) - min(lat)\n  \n  \n  if (0.75 * lx < ly) {\n    # In this case, x needs to be made longer\n    \n    xhalf <- 0.67 * ly\n    xadd <- xhalf - lx / 2\n    # calculate how many columns needs to be added.\n    nxadd <- abs(round(xadd / dx))\n    \n    madd1 <- matrix(data = NA, nrow = length(lat), ncol = nxadd)\n    madd2 <- madd1\n    colnames(madd1) <- seq(to = min(lon) - dx, length = nxadd, by = dx)\n    colnames(madd2) <- seq(from = max(lon) + dx, length = nxadd, by = dx)\n    \n    matrix_new <- cbind(madd1, matrix, madd2)  \n    \n    \n  } else if (0.75 * lx > ly) {\n    \n    yhalf <- 0.38 * lx\n    yadd <- yhalf - ly / 2\n    nyadd <- abs(round(yadd / dy))\n    \n    madd1 <- matrix(data = NA, nrow = nyadd, ncol = length(lon))\n    madd2 <- madd1  \n      \n    rownames(madd1) <- seq(to = max(lat) + dy, length = nyadd, by = -dy)\n    rownames(madd2) <- seq(from = min(lat) - dx, length = nyadd, by = -dy)\n    \n    matrix_new <- rbind(madd1, matrix, madd2)\n    \n  } else {\n    matrix_new <- matrix\n  }\n  \n  return(matrix_new)\n}\n",
    "created" : 1449244575929.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "1779347934",
    "id" : "8EDA836B",
    "lastKnownWriteTime" : 1449681451,
    "path" : "E:/1/R/hyfo/R/getSpatialMap.R",
    "project_path" : "R/getSpatialMap.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}