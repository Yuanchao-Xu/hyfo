{
    "contents" : "#' Extract period from list or dataframe.\n#' \n#' Extract common period or certain period from a list of different dataframes of time series, or from a \n#' dataframe.\n#' NOTE: all the dates in the datalist should follow the format in ?as.Date{base}.\n#' @param datalist A list of different dataframes of time series .\n#' @param startDate A Date showing the start of the extract period, default as NULL, check details.\n#' @param endDate A Date showing the end of the extract period, default as NULL, check details.\n#' @param commonPeriod A boolean showing whether the common period is extracted. If chosen, startDate and endDate\n#' should be NULL.\n#' @param dataframe A dataframe with first column Date, the rest columns value. If your input is a \n#' dataframe, not time series list, you can put \\code{dataframe = yourdataframe}. And certain period will be \n#' extracted. Note: if your input is a time series, that means all the columns share the same period of date.\n#' @param year extract certain year in the entire time series. if you want to extract year 2000, set \\code{year = 2000}\n#' @param month extract certain months in a year. e.g. if you want to extract Jan, Feb of each year, \n#' set \\code{month = c(1, 2)}.\n#' @details \n#' \\strong{startDate and endDate}\n#' \n#' If startDate and endDate are assigned, then certain period between startDate and endDate will be returned, \n#' for both datalist input and dataframe input.\n#' \n#' If startDate and endDate are NOT assigned, then,\n#' \n#'    if input is a datalist, the startDate and endDate of the common period of different datalists will be assigned\n#'    to the startDate and endDate.\n#' \n#'    if input is a dataframe, the startDate and endDate of the input dataframe will be assigned to the startDate\n#'    and endDate . Since different value columns share a common Date column in a dataframe input. \n#' \n#' \\strong{year and month}\n#' \n#' For year crossing month input, hyfo will take from the year before. E.g. if \\code{month = c(10, 11, 12, 1)},\n#' and \\code{year = 1999}, hyfo will take month 10, 11 and 12 from year 1998, and month 1 from 1999.You DO NOT \n#' have to set \\code{year = 1998 : 1999}.\n#' \n#' Well, if you set \\code{year = 1998 : 1999}, hyfo will take month 10, 11 and 12 from year 1997, and month 1 from 1998,\n#' then, take month 10, 11 and 12 from year 1998, month 1 from 1999. So you only have to care about the latter year.\n#' \n#' \n#' \n#' @return A list or a dataframe with all the time series inside containing the same period.\n#' @examples\n#' # Generate timeseries datalist. Each data frame consists of a Date and a value.\n#' \n#' AAA <- data.frame(\n#' # date column\n#' Date = seq(as.Date('1990-10-28'),as.Date('1997-4-1'),1),\n#'  # value column\n#' AAA = sample(1:100,length(seq(as.Date('1990-10-28'),as.Date('1997-4-1'),1)), repl = TRUE))\n#' \n#' BBB <- data.frame(\n#' Date = seq(as.Date('1993-3-28'),as.Date('1999-1-1'),1), \n#' BBB = sample(1:100,length(seq(as.Date('1993-3-28'),as.Date('1999-1-1'),1)), repl = TRUE))\n#'  \n#' CCC <- data.frame(\n#' Date = seq(as.Date('1988-2-2'),as.Date('1996-1-1'),1), \n#' CCC = sample(1:100,length(seq(as.Date('1988-2-2'),as.Date('1996-1-1'),1)), repl = TRUE)) \n#' \n#' list <- list(AAA, BBB, CCC)# dput() and dget() can be used to save and load list file.\n#' \n#' list_com <- extractPeriod(list, commonPeriod = TRUE)\n#' \n#' # list_com is the extracted datalist.\n#' str(list_com)\n#' \n#' # If startDate and endDate is provided, the record between them will be extracted.\n#' # make sure startDate is later than any startDate in each dataframe and endDate is \n#' # earlier than any endDate in each dataframe.\n#' \n#' data(testdl)\n#' datalist_com1 <- extractPeriod(testdl, startDate = '1994-1-1', endDate = '1995-10-1')\n#' \n#' \n#' dataframe <- list2Dataframe(datalist_com1)\n#' # now we have a dataframe to extract certain months and years.\n#' dataframe_new <- extractPeriod(dataframe = dataframe, month = c(1,2,3))\n#' dataframe_new <- extractPeriod(dataframe = dataframe, month = c(12,1,2), year = 1995)\n#' \n#' \n#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/\n#' \n#' @importFrom zoo as.Date\n#' @references \n#' \n#' \\itemize{\n#' \\item Achim Zeileis and Gabor Grothendieck (2005). zoo: S3 Infrastructure for Regular and Irregular Time\n#' Series. Journal of Statistical Software, 14(6), 1-27. URL http://www.jstatsoft.org/v14/i06/\n#' }\n#'\n#' @export\nextractPeriod <- function(datalist, startDate = NULL, endDate = NULL, commonPeriod = FALSE, \n                          dataframe = NULL, year = NULL, month = NULL) {\n  if (!is.null(dataframe)) {\n    dataset <- extractPeriod_dataframe(dataframe, startDate = startDate, endDate = endDate, year = year,\n                                       month = month)\n    \n    \n  } else {\n    if (!is.null(startDate) & !is.null(endDate) & commonPeriod == FALSE) {\n      dataset <- lapply(datalist, extractPeriod_dataframe, startDate = startDate, endDate = endDate, year = year,\n                        month = month)\n    } else if (is.null(startDate) & is.null(endDate) & commonPeriod == TRUE) {\n    \n      Dates <- lapply(datalist, extractPeriod_getDate) \n      Dates <- do.call('rbind', Dates)\n    \n      startDate <- as.Date(max(Dates[, 1]))\n      endDate <- as.Date(min(Dates[, 2]))\n    \n      dataset <- lapply(datalist, extractPeriod_dataframe, startDate = startDate, endDate = endDate, year = year,\n                        month = month)\n    \n    } else {\n      stop('Enter startDate and endDate, set commonPeriod as False, or simply set commonPeriod as TRUE')\n    }\n  }\n  \n  return(dataset)\n}\n\n\n\nextractPeriod_dataframe <- function(dataframe, startDate, endDate, year = NULL, month = NULL) {\n  # to check whether first column is a date format\n  if (!grepl('-|/', dataframe[1, 1])) {\n    stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base} \n         and use as.Date to convert.')\n  }    \n  dataframe[, 1] <- as.Date(dataframe[, 1])\n  \n  if (is.null(startDate)) startDate <- dataframe[1, 1]\n  if (is.null(endDate)) endDate <- tail(dataframe[, 1], 1)\n  \n  startIndex <- which(dataframe[, 1] == startDate)\n  endIndex <- which(dataframe[, 1] == endDate)\n  if (length(startIndex) == 0 | length(endIndex) == 0) {\n    stop('startDate and endDate exceeds the date limits in dataframe. Check datalsit please.')\n  }\n  output <- dataframe[startIndex:endIndex, ]\n\n  \n  if (!is.null(year)) {\n    Date <- as.POSIXlt(output[, 1])\n    yea <- Date$year + 1900\n    mon <- Date$mon + 1\n      \n    if (is.null(month) || !any(sort(month) != month)) {\n      DateIndex <- which(yea %in% year)\n      if (length(DateIndex) == 0) stop('No input years in the input ts, check your input.')\n      \n      output <- output[DateIndex, ]\n      \n      # if year crossing  than sort(month) != month, in this case we need to\n      # take months from last year.\n    } else {\n      \n      \n      startIndex <- intersect(which(yea == year[1] - 1), which(mon == month[1]))[1]\n      endIndex <- tail(intersect(which(yea == tail(year, 1)), which(mon == tail(month, 1))), 1)\n      \n      \n      if (is.na(startIndex) || length(endIndex) == 0 || startIndex > endIndex) {\n        stop('Cannot find input months and input years in the input time series.')\n      }\n      output <- output[startIndex:endIndex, ]\n        \n      if (any(diff(year) != 1)) {\n        # if year is not continuous, like 1999, 2003, 2005, than we have to sift again.  \n        Date <- as.POSIXlt(output[, 1])\n        yea <- Date$year + 1900\n        mon <- Date$mon + 1\n        \n        DateIndex <- unlist(sapply(year, function(x) {\n          startIndex <- intersect(which(yea == x - 1), which(mon == month[1]))[1]\n          endIndex <- tail(intersect(which(yea == x), which(mon == tail(month, 1))), 1)\n          index <- startIndex:endIndex\n          return(index)\n        }))\n        \n        \n        output <- output[DateIndex, ]\n        \n        # cannot directly return output here, because sometimes, month can be incontinuous,\n        # we still need the next process to sift month.\n        }\n      }\n      \n    }\n  \n    \n    if (!is.null(month)) {\n      Date <- as.POSIXlt(output[, 1])\n      mon <- Date$mon + 1\n    \n      # %in% can deal with multiple equalities\n      DateIndex <- which(mon %in% month)\n      \n      if (length(DateIndex) == 0) stop('No input months in the input ts, check your input.')\n      \n      output <- output[DateIndex, ]\n  }\n  \n\n  return(output)  \n}\n\n\n#' @importFrom utils tail\n#' @references \n#' \n#' \\itemize{\n#' \\item R Core Team (2015). R: A language and environment for statistical computing. R Foundation for\n#' Statistical Computing, Vienna, Austria. URL http://www.R-project.org/.\n#' }\n#' \n#' \nextractPeriod_getDate <- function(dataset) {\n  \n  if (!grepl('-|/', dataset[1, 1])) {\n    stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base}, \n          and use as.Date to convert.')\n  }\n  start <- as.Date(dataset[1, 1])\n  end <- as.Date(tail(dataset[, 1], 1))\n  \n  \n  return(c(start, end))\n}\n\n\n\n",
    "created" : 1443190512650.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "1354367936",
    "id" : "6DD36101",
    "lastKnownWriteTime" : 1443190524,
    "path" : "~/hyfo/R/extractPeriod.R",
    "project_path" : "R/extractPeriod.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "type" : "r_source"
}