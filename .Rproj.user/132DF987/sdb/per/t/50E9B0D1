{
    "contents" : "#' Get variable name in the NetCDF file. After knowning the name, you can use \\code{loadNcdf} to load\n#' the target variable.\n#' \n#' @param filePath A path pointing to the netCDF file.\n#' @return The names of the varialbes in the file.\n#' @import ncdf\n#' @export\ngetNcdfVar <- function(filePath) {\n  nc <- open.ncdf(filePath)\n  names <- names(nc$var)\n  return(names)\n}\n\n\n#' Load NetCDF file\n#' \n#' @param filePath A path pointing to the NetCDF file, version3.\n#' @param varname A character representing the variable name, you can use \\code{getNcdfVar} to\n#' get the basic information about the variables and select the target.\n#' @param tz A string representing the time zone, default is GMT, if you know what time zone is \n#' you can assign it in the argument. If \\code{tz = ''}, current time zone will be taken.\n#' @return A list object from \\code{hyfo} containing the information to be used in the analysis, \n#' or biascorrection.\n#' \n#' @export\n#'@import ncdf\nloadNcdf <- function(filePath, varname, tz = 'GMT') {\n  nc <- open.ncdf(filePath)\n  \n  var <- nc$var\n  # Use name to locate the variable\n  call_1 <- as.call(c(\n    list(as.name('$'), var, varname)\n  ))\n  var <- eval(call_1)\n  if(is.null(var)) stop('No such variable name, check source file.')\n  \n  # First needs to identify the variable name, load the right data\n  message('Loading data...')\n  nc_data <- get.var.ncdf(nc, var)\n  message('Processing...')\n  \n  dimNames <- unlist(lapply(1:length(var$dim), function(x) var$dim[[x]]$name))\n  \n  # Only deals with the most common dimensions, futher dimensions will be added in future.\n  dimIndex <- match(c('lon', 'lat', 'time', 'member'), dimNames)\n  \n  gridData <- list()\n  gridData$Variable$varName <- varname\n  gridData$xyCoords$x <- var$dim[[dimIndex[1]]]$vals\n  gridData$xyCoords$y <- var$dim[[dimIndex[2]]]$vals\n  \n  # Time part needs to be taken seperately\n  \n  timeUnit <- strsplit(var$dim[[dimIndex[3]]]$units, split = ' since')[[1]][1]\n  timeDiff <- var$dim[[dimIndex[3]]]$vals\n  # To get real time, time since when has to be grabbed from the dataset.\n  timeSince <- as.POSIXlt(strsplit(var$dim[[dimIndex[3]]]$units, split = 'since')[[1]][2], tz = tz)\n  \n  \n#  Date <- rep(timeSince, length(timeDiff))\n  \n  \n  unitDic <- data.frame(weeks = 'weeks', days = 'days', hours = 'hours',\n                        minutes = 'mins', seconds = 'secs')\n  \n  timeDiff <- as.difftime(timeDiff, units = as.character(unitDic[1, timeUnit]))\n  \n#   if (grepl('day', timeUnit)) {\n#     Date$mday <- Date$mday + timeDiff\n#   } else if (grepl('second', timeUnit)) {\n#     Date$sec <- Date$sec + timeDiff\n#   }\n  Date <- timeSince + timeDiff\n  \n  if (length(Date) == 1) {\n    warning(\"Only one time step is taken, time dimension is dropped in the original data.\n            But after loading, the time dimension (with length : 1) will be added.\")\n  }\n  gridData$Dates$start <- as.character(Date)\n  \n  # Assing data to grid data\n  # At leaset should be 3 dimensions, lon, lat, time. So if less than 3, \n  \n  if (length(dim(nc_data)) < 3) {\n    dim(nc_data) <- c(dim(nc_data), 1) \n    message('Time dimension is added, make sure in your original data, only time dimension is dropped.')\n  }\n  gridData$Data <- nc_data\n  attributes(gridData$Data)$dimensions <- dimNames\n  \n  if (!is.na(dimIndex[4])) gridData$Members <- var$dim[[dimIndex[4]]]$vals\n  \n  gridData$Loaded <- 'by hyfo package, http://yuanchao-xu.github.io/hyfo/'\n  \n  return(gridData)\n  \n}\n\n#' Write to NetCDF file using hyfo list file\n#' @param gridData A hyfo list file or the list file from \\code{loadECOMS{ecomsUDG.Raccess}}\n#'  or \\code{loadGridData{ecomsUDG.Raccess}}\n#' @param filePath A path of the new NetCDF file, should end with \".nc\"\n#' @param missingValue A number representing the missing value in the NetCDF file, default\n#' is 1e20\n#' #' @param tz A string representing the time zone, default is GMT, if you know what time zone is \n#' you can assign it in the argument. If \\code{tz = ''}, current time zone will be taken.\n#' @param units A string showing in which unit you are putting in the NetCDF file, it can be \n#' seconds or days and so on. If not specified, the function will pick up the possible largest \n#' time units from \\code{c('weeks', 'days', 'hours', 'mins', 'secs')}\n#' @return An NetCDF version 3 file.\n#' @export \n#' @import ncdf\nwriteNcdf <- function(gridData, filePath, missingValue = 1e20, tz = 'GMT', units = NULL) {\n  \n  name <- gridData$Variable$varName\n  # First defines dimensions.\n  dimLon <- dim.def.ncdf('lon', 'degree', gridData$xyCoords$x)\n  dimLat <- dim.def.ncdf('lat', 'degree', gridData$xyCoords$y)\n  dimMem <- NULL\n  if (!is.null(gridData$Members)) {\n    dimMem <- dim.def.ncdf('member', 'members', 1:length(gridData$Members))\n  }\n  \n  \n  # Time needs to be treated seperately\n  dates <- as.POSIXlt(gridData$Dates$start, tz = tz)\n  if (is.null(units)) {\n    units <- getTimeUnit(dates)\n    time <- difftime(dates, dates[1], units = units)\n  } else {\n    time <- difftime(dates, dates[1], units = units)\n  }\n  timeUnits <- paste(units, 'since', dates[1])\n  dimTime <- dim.def.ncdf('time', timeUnits, time)\n  \n  \n  # Depending on whether there is a member part of the dataset.\n  \n  dimList <- list(dimLon, dimLat, dimTime, dimMem)\n  # delete the NULL list, in order that there is no member part in the data.\n  dimList <- Filter(Negate(is.null), dimList)\n  # Then difines data\n  var <- var.def.ncdf( name, \"units\", dimList, missingValue)\n  \n  nc <- create.ncdf(filePath, var)\n  \n  # This part comes from the library downscaleR, can be deleted if you don't \n  # use {ecomsUDG.Raccess}, by adding this, the file can be read by the package {ecomsUDG.Raccess}\n  att.put.ncdf(nc, \"time\", \"standard_name\",\"time\")\n  att.put.ncdf(nc, \"time\", \"axis\",\"T\")\n  att.put.ncdf(nc, \"time\", \"_CoordinateAxisType\",\"Time\")\n  #att.put.ncdf(nc, \"time\", \"_ChunkSize\",1)\n  att.put.ncdf(nc, \"lon\", \"standard_name\",\"longitude\")\n  att.put.ncdf(nc, \"lon\", \"_CoordinateAxisType\",\"Lon\")\n  att.put.ncdf(nc, \"lat\", \"standard_name\",\"latitude\")\n  att.put.ncdf(nc, \"lat\", \"_CoordinateAxisType\",\"Lat\")\n  if (!is.null(dimMem)){\n    att.put.ncdf(nc, \"member\", \"standard_name\",\"realization\")\n    att.put.ncdf(nc, \"member\", \"_CoordinateAxisType\",\"Ensemble\")\n    #att.put.ncdf(nc, \"member\", \"ref\",\"http://www.uncertml.org/samples/realisation\")\n  }\n  \n  \n  # This part has to be put\n  att.put.ncdf(nc, 0, \"Conventions\",\"CF-1.4\")\n  att.put.ncdf(nc, 0, 'WrittenBy', 'hyfo(http://yuanchao-xu.github.io/hyfo/)')\n  \n  dimIndex <- match(c('lon', 'lat', 'time', 'member'), attributes(gridData$Data)$dimensions)\n  dimIndex <- na.omit(dimIndex)\n  data <- aperm(gridData$Data, dimIndex)\n  put.var.ncdf(nc, name, data)\n  close.ncdf(nc)\n  \n}\n\n# For internaluse by writeNcdf\ngetTimeUnit <- function(dates) {\n  units <- c('weeks', 'days', 'hours', 'mins', 'secs')\n  output <- NULL\n  for (unit in units) {\n    time <- difftime(dates, dates[1], units = unit)\n    rem <- sapply(time, function(x) x%%1)\n    if (!any(rem != 0)) {\n      output <- unit\n      break\n    }\n  } \n  return(output)\n}\n\n\n# Save for future use. \n#'@import ncdf\ngetExtralDim <- function(...) {\n  dimList <- list(...)\n  \n  \n}",
    "created" : 1438199524196.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "1711831153",
    "id" : "50E9B0D1",
    "lastKnownWriteTime" : 1438349168,
    "path" : "~/hyfo/R/Ncdf_related.R",
    "project_path" : "R/Ncdf_related.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_source"
}