{
    "contents" : "#' getHisEnsem use historical data as the forecasting input time series.\n#' \n#' @param TS A time series dataframe, with first column Date, and second column value.\n#' @param example A vector containing two strings showing the start and end date, which can be used as an example.\n#' This should be the first example, only the data earlier than the example will not be considered.\n#' e.g. \\code{example = c('1994-3-1', '1996-1-2')}, meaning the example period is from 1994-3-1 to 1996-1-2. And \n#' the program will extract every possible period in TS you provided to generate the ensemble. Check details for \n#' more information.\n#' @param interval A number representing the interval of each ensemble member. NOTE: \"interval\" takes\n#' 365 as a year, and 30 as a month, regardless of leap year and months with 31 days. So if you want the interval \n#' to be 2 years, set \\code{interval = 730}, which equals 2 * 365 ; if two months, set \\code{interval = 60}; \n#' 2 days, \\code{interval = 2}, for other numbers that cannot be divided by 365 or 30 without remainder, it will treat the \n#' number as days.By defualt interval is set to be 365, a year.\n#' @param buffer A number showing how many days are used as buffer period for models. Check details for more\n#' information.\n#' \n#' @param plot A boolean showing whether the plot will be shown, default is TRUE.\n#' \n#' @details \n#' \n#' \\code{interval} doesn't care about leap year and the months with 31 days, it will take 365 as a year, and 30 as a month.\n#' e.g., if the interval is from 1999-2-1 to 1999-3-1, you should just set interval to 30, although the real interval is 28\n#' days.\n#' \n#' \\code{example} and \\code{interval} controls how the ensemble will be generated. e.g. if the time series is from \n#' 1990-1-1 to 2001-1-1.\n#' \n#' if \\code{example = c('1992-3-1', '1994-1-1')} and \\code{interval = 1095}, note, 1095 = 365 * 3, so the program treat\n#' this as 3 years.\n#' \n#' Then you are supposed to get the ensemble consisting of following part:\n#' \n#' 1. 1992-3-1 to 1994-1-1 first one is the example, and it's NOT start from 1990-3-1.\n#' 2. 1995-3-1 to 1997-1-1 second one starts from 1993, because \"interval\" is 3 years.\n#' 3. 1998-3-1 to 2000-1-1\n#' \n#' because the last one \"2000-3-1 to 2002-1-1\", 2002 exceeds the original TS range, so it will not be included.\n#' \n#' Sometimes, there are leap years and months with 31 days included in some ensemble part, in which case the length of the data will\n#' be different, e.g., 1999-1-1 to 1999-3-1 is 1 day less than 2000-1-1 to 2000-3-1. In this situation,\n#' the data will use example as a standard. If the example is 1999-1-1 to 1999-3-1, then the latter one\n#' will be changed to 2001-1-1 to 2000-2-29, which keeps the start Date and change the end Date.\n#' \n#' If the end date is so important that cannot be changed, try to solve this problem by resetting\n#' the example period, to make the event included in the example.\n#' \n#' Good set of example and by can generate good ensemble.\n#' \n#' \\code{buffer}\n#' Sometimes the model needs to run for a few days to warm up, before the forecast. E.g., if a forecast starts at\n#' '1990-1-20', for some model like MIKE NAM model, the run needs to be started about 14 days. So the input timeseries\n#' should start from '1990-1-6'.\n#' \n#' Buffer is mainly used for the model hotstart. Sometimes the hot start file cannot contain all the parameters needed,\n#' only some important parameters. In this case, the model needs to run for some time, to make other parameters ready\n#' for the simulation.\n#' \n#' @return A ensemble time series using historical data as forecast.\n#' \n#' @examples\n#' \n#' data(testdl)\n#' \n#' a <- testdl[[1]]\n#' \n#' # Choose example from \"1994-2-4\" to \"1996-1-4\"\n#' b <- getHisEnsem(a, example = c('1994-2-4', '1996-1-4'))\n#' \n#' # Default interval is one year, can be set to other values, check help for information.\n#' \n#' # Take 7 months as interval\n#' b <- getHisEnsem(a, example = c('1994-2-4', '1996-1-4'), interval = 210) \n#' # Take 30 days as buffer\n#' b <- getHisEnsem(a, example = c('1994-2-4', '1996-1-4'), interval = 210, buffer = 30)\n#' @import reshape2 ggplot2\n#' @export\n\ngetHisEnsem <- function (TS, example, interval = 365, buffer = 0, plot = TRUE) {\n  if (!grepl('-|/', TS[1, 1])) {\n    stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base} \n         and use as.Date to convert.')\n  } else if (!grepl('-|/', example[1]) | !grepl('-|/', example[1])) {\n    stop('Wrong date format in the example, check the format in ?as.Date{base} \n         and use as.Date to convert.')\n  } else {\n    \n    TS[, 1] <- as.Date(TS[, 1])\n    example <- as.Date(example ,tz = '')\n    exL <- example[2] - example[1]\n    \n\n    \n    if (interval %% 365 == 0) {\n      d <- interval / 365\n      \n      # Get sequence of start and end date.\n      \n      startDate <- rev(seq(from = example[1], to = min(TS[, 1]), by = paste(-d, 'years')))\n      endDate <- seq(from = example[2], to = max(TS[, 1]), by = paste(d, 'years'))\n\n      n <- length(startDate) + length(endDate) - 1 # example is counted twice, should be subtracted.      \n      \n      # Generate full start date series.\n      startDate <- seq(min(startDate), length = n, by = paste(d, 'years'))\n      endDate <- startDate + exL\n      \n    } else if (interval %% 30) {\n      d <- interval / 30\n      \n      # Get sequence of start and end date.\n      \n      startDate <- rev(seq(from = example[1], to = min(TS[, 1]), by = paste(-d, 'months')))\n      endDate <- seq(from = example[2], to = max(TS[, 1]), by = paste(d, 'months'))\n      \n      n <- length(startDate) + length(endDate) - 1\n      \n      startDate <- seq(min(startDate), length = n, by = paste(d, 'months'))\n      endDate <- startDate + exL\n      \n    } else {\n      d <- interval\n      \n      # Get sequence of start and end date.\n      \n      startDate <- rev(seq(from = example[1], to = min(TS[, 1]), by = paste(-d, 'days')))\n      endDate <- seq(from = example[2], to = max(TS[, 1]), by = paste(d, 'days'))\n      \n      n <- length(startDate) + length(endDate) - 1\n      \n      startDate <- seq(min(startDate), length = n, by = paste(d, 'days'))\n      endDate <- startDate + exL\n    }\n    \n    data <- mapply(FUN = function(x, y) extractPeriod_dataset(dataset = TS, startDate = x, endDate = y),\n                   x = startDate, y = endDate)\n    \n    data <- lapply(1:n, function(x) data.frame(data[, x]))\n    \n    if (buffer > 0) {\n      bufferStart <- example[1] - buffer\n      bufferEnd <- example[1] - 1\n      bufferTS <- extractPeriod_dataset(TS, bufferStart, bufferEnd)\n      \n      data <- lapply(data, function(x) rbind(bufferTS, x))\n      \n    } else if (buffer < 0) {\n      stop ('Buffer should be positive, or reset example.')\n    }\n    \n    \n    output <- list2Dataframe(data)\n    colnames(output) <- c('Date', as.character(startDate))\n    \n    # Rearrange dataframe to make example the first column.\n    ind <- match(c('Date', as.character(example[1])), colnames(output))\n    output <- cbind(output[ind], output[-ind])\n    ex_date <- seq(from = example[1] - buffer, to = example[2], by = 1)\n    output$Date <- ex_date\n    colnames(output)[2] <- 'Example'\n    \n    if (plot == TRUE) {\n      \n      data_ggplot <- melt(output, id.var = 'Date')\n      \n      mainLayer <- with(data_ggplot, {\n        ggplot(data = data_ggplot) +\n          aes(x = Date, y = value, color = variable, group = variable) +\n          geom_line(size = 0.3) +\n          geom_line(data = data_ggplot[data_ggplot$variable == 'Example', ], size = 2)\n            \n      })\n      print(mainLayer)\n    }\n    \n    return(output)\n  }\n}\n\n\n\n\n\n\n#' getFrcEnsem extract different members' timeseries from forecasting data, if forecasting data has a member session.\n#' \n#' @param dataset A list containing different information, should be the result of reading netcdf file using\n#' \\code{library(ecomsUDG.Raccess)}, there should be a member part in the data part of the dataset.\n#' @param cell A vector containing the locaton of the cell, e.g. c(2, 3), default is \"mean\", representing\n#' the spatially averaged value. Check details for more information.\n#' @param plot A boolean showing whether the plot will be shown, default is TRUE.\n#' \n#' @details \n#' \n#' \\code{cell} representing the location of the cell, NOTE: this location means the index of the cell,\n#' IT IS NOT THE LONGITUDE AND LATITUDE. e.g., \\code{cell = c(2, 3)}, the program will take the 2nd longitude\n#' and 3rd latitude, by the increasing order. Longitude comes first.\n#' \n#' \n#' @return A ensemble time series extracted from forecating data.\n#' \n#' @import reshape2 ggplot2\n#' @export\ngetFrcEnsem <- function(dataset, cell = 'mean', plot = TRUE) {\n  # cell should be a vector showing the location, or mean representing the loacation averaged.\n  \n  checkWord <- c('Data', 'xyCoords', 'Dates')\n  if (any(is.na(match(checkWord, attributes(dataset)$names)))) {\n    stop('Input dataset is incorrect, it should contain \"Data\", \"xyCoords\", and \"Dates\", \n         check help for details.')\n  }\n  \n  Date <- as.Date(dataset$Dates$start)\n  data <- dataset$Data\n  \n  # Dimension needs to be arranged. Make sure first and second dimension is lat and lon.\n  att <- attributes(data)$dimensions\n  dimIndex <- seq(1, length(att))\n  dimIndex1 <- match(c('lon', 'lat', 'time'), att)# match can apply to simple cases\n  dimIndex2 <- dimIndex[-dimIndex1]# choose nomatch\n  \n  data <- aperm(data, c(dimIndex1, dimIndex2))\n  attributes(data)$dimensions <- att[c(dimIndex1, dimIndex2)]\n  \n  if (!any(attributes(data)$dimensions == 'member')){\n    stop('There is no member part in the dataset, check the input\n         dataset or change your arguments.')\n  }\n  \n  \n  if (length(cell) == 2) {\n    data_ensem <- data[cell[1], cell[2], , ]\n    meanV <- apply(data_ensem, MARGIN = 1, FUN = mean, na.rm = TRUE)\n    data_ensem <- data.frame('mean' = meanV, data_ensem) \n    \n  } else if (cell == 'mean') {\n    data_ensem <- apply(data, MARGIN = c(3, 4), FUN = mean, na.rm = TRUE)\n#    colnames <- 1:ncol(data_ensem)\n    meanV <- apply(data_ensem, MARGIN = 1, FUN = mean, na.rm = TRUE)\n    data_ensem <- data.frame('mean' = meanV, data_ensem)\n    \n  } else {\n    stop('Wrong cell input, check help for information.')\n  }\n  \n  output <- data.frame(Date, data_ensem)\n  \n  if (plot == TRUE) {\n    \n    data_ggplot <- melt(output, id.var = 'Date')\n    \n    mainLayer <- with(data_ggplot, {\n      ggplot(data = data_ggplot) +\n        aes(x = Date, y = value, color = variable) +\n        geom_line(size = 0.3) +\n        geom_line(data = data_ggplot[data_ggplot$variable == 'mean', ], size = 2)\n      \n    })\n    print(mainLayer)\n  }\n  \n  return(output)\n  \n}\n\n",
    "created" : 1436658344273.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "4147554502",
    "id" : "D7BC7C1A",
    "lastKnownWriteTime" : 1436729180,
    "path" : "~/hyfo/R/getEnsemble.R",
    "project_path" : "R/getEnsemble.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}