{
    "contents" : "#' Get spatial map of the input dataset, and a matrix representing the raster map will be returned.\n#' \n#' @param dataset A list containing different information, should be the result of reading netcdf file using\n#' \\code{library(ecomsUDG.Raccess)}.\n#' @param catchment A catchment file geting from \\code{shp2cat()} in the package, if a catchment is available for background.\n#' @param points A shape file showing other information, e.g., location of the gauging stations.\n#' @param method A string showing different calculating method for the map.\n#' @param outputData A boolean showing whether the raster matrix will be returned, default is T.\n#' @param info A boolean showing whether the information of the map, e.g., max, mean ..., default is T.\n#' @param ... arguments which will be passed to \\code{scale_fill_gradientn()}, including \\code{trans}, \n#' \\code{limits}, \\code{breaks}, see \\code{scale_fill_gradientn()} for more details.\n#' @return A matrix representing the raster map is returned, and the map is plotted.\n#' @export\n#' @import ggplot2 rgdal\ngetSpatialMap <- function(dataset, catchment = NULL,points = NULL, method = NULL, outputData = TRUE, \n                          info = T, ...){\n  message('used for showing the spatial map for parameters like precipitation.\n          different method are provided for analysing the parameters\n          catchment needs shape file\n          points needs data.frame, with colume \"name, lon, lat, z, value\" in data.frame()\n          method = NULL means no method calculated on the cell')\n  \n  #range of the dataset just loaded \n  lon <- dataset$xyCoords$x\n  lat <- dataset$xyCoords$y\n  startTime <- as.POSIXlt(dataset$Dates$start,tz = 'GMT')\n  yearIndex <- startTime$year + 1900\n  monthIndex <-startTime$mon + 1\n  data <- dataset$Data\n  \n  if (is.null(method)){\n    #in case the dataset is ready to plot and no need to calculate\n  }else if(method == 'meanAnnual'){\n    #mean value of the annual precipitation over the period of the data \n    #time <- proc.time()\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex,  method = 'meanAnnualPreci')\n    #newTime <- proc.time() - time\n    title  <- 'Mean Annual Precipitation (mm / year)'\n    \n  }else if(method == 'winter'){\n    #mean value of the seasonal precipitation, in this case, winter\n    \n    #time <- proc.time()\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'winter')\n    #newTime <- proc.time() - time\n    title <- 'Mean Winter Precipitation (mm / winter)'\n    \n  }else if(method == 'spring'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'spring')\n    \n    title <- 'Mean Spring Precipitation (mm / spring)'\n    \n  }else if (method == 'summer'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'summer')\n    \n    title <- 'Mean Summer Precipitation (mm / summer)'\n    \n  }else if (method == 'autumn'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'autumn')\n    \n    title <- 'Mean Autumn Precipitation (mm / autumn)'\n    \n  }else if(method == 'mean'){\n    #sum value of the dataset, this procedure is to get the mean value\n    data_new <- apply(data, MARGIN = c(2,3), FUN = mean)  \n  }else if(method == 'max'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = max)   \n  }else if(method == 'min'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = min)\n  }else{\n    wrongMethod <- method\n    stop (paste('no method called',wrongMethod))\n  }\n  \n  if (info == T) {\n    plotMax <- round(max(data_new,na.rm=TRUE),2)\n    plotMin <- round(min(data_new,na.rm=TRUE),2)\n    plotMean <- round(mean(data_new,na.rm=TRUE),2)\n    plotMedian <- round(median(data_new,na.rm=T),2)\n    word <- paste('\\n\\n', paste('Max','=',plotMax), ',', paste('Min','=',plotMin), ',',\n                  paste('Mean','=',plotMean), ',', paste('Median', '=', plotMedian))\n  }else{\n    word <- NULL\n  }\n    \n  x_word <- paste('Longitude', word)\n  \n  \n  \n  #set names for the matrix, in order to be better converted later in ggplot.\n  colnames(data_new) <- round(lon,2)\n  rownames(data_new) <- round(lat,2)\n  \n  world_map <- ggplot2::map_data('world')\n  \n  \n  #ggplot\n  #for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function\n  #get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use \n  #data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available \n  #in the environment.\n  #in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them\n  #outside aes() as normal parameters.\n  \n  data_ggplot <- reshape2::melt(data_new, na.rm = T)\n  colnames(data_ggplot) <- c('lat', 'lon', 'value')\n  theme_set(theme_bw())\n  mainLayer <- ggplot(data = data_ggplot)+ \n    geom_tile(aes(x=lon,y=lat,fill = value))+\n    scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent', ...)+#usually scale = 'sqrt'\n    geom_map(data = world_map, map = world_map, aes(map_id = region), fill='transparent', color='black')+\n    guides(fill = guide_colorbar(title='Rainfall (mm)', barheight = 15))+\n    xlab(x_word)+\n    ylab('Latitude')+\n    ggtitle(title)+\n    theme(plot.title=element_text(size=20, face='bold'),\n          axis.title.x=element_text(size = 18),\n          axis.title.y = element_text(size = 18))\n#     geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),\n#               xmax=min(lon)+0.99*(max(lon)-min(lon)),\n#               ymin=min(lat)+0.02*(max(lat)-min(lat)),\n#               ymax=min(lat)+0.28*(max(lat)-min(lat)),\n#               fill='white',colour='black')+\n#   annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)\n  \n  printLayer <- mainLayer\n  \n  #catchment conversion\n  if(is.null(catchment) == FALSE){\n    a <- catchment\n    a@data$id <- rownames(a@data)\n    b <- fortify(a,region='id')\n    c <- plyr::join(b,a@data,by='id')\n    catchmentLayer <- geom_polygon(data=c, aes(long,lat,group=group), color='black', fill='transparent')\n    \n    printLayer <- printLayer + catchmentLayer\n  }\n  \n  if(is.null(points) == FALSE){\n    pointLayer <- geom_point(data = points,aes(x = lon, y = lat, size = value, colour = z))\n    \n    printLayer <- printLayer + pointLayer\n  }\n  \n  print (printLayer)\n  \n  if(outputData == TRUE) return(data_new)\n}\n\n",
    "created" : 1434408950881.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "2833151359",
    "id" : "41197718",
    "lastKnownWriteTime" : 1434408957,
    "path" : "~/hyfo/R/getSpatialMap.R",
    "project_path" : "R/getSpatialMap.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}