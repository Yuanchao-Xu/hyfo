{
    "contents" : "#' Get spatial map of the input dataset.\n#' \n#' @param dataset A list containing different information, should be the result of reading netcdf file using\n#' \\code{library(ecomsUDG.Raccess)}.\n#' @param method A string showing different calculating method for the map. More information please refer to\n#' details.\n#' @param member A number showing which member is selected to get, if the dataset has a \"member\" dimension. Default\n#' is NULL, if no member assigned, and there is a \"member\" in dimensions, the mean value of the members will be\n#' taken.\n#' @param ... Check \\code{?getSpatialMap_mat} for details, e.g., x, y, title, catchment, \n#' points, output,\n#' @return A matrix representing the raster map is returned, and the map is plotted.\n#' @details\n#' There are following methods to be selected, \n#' \"meanAnnual\": annual rainfall of each year is plotted.  \n#' \"winter\", \"spring\", \"autumn\", \"summer\": MEAN seasonal rainfall of each year is plotted.\n#' Month(number 1 to 12): MEAN month rainfall of each year is plotted, e.g. MEAN march rainfall of each year.\n#' \"mean\", \"max\", \"min\": mean daily, maximum daily, minimum daily precipitation.\n#' @examples\n#' \n#' #gridData provided in the package is the result of \\code {loadGridData{ecomsUDG.Raccess}}\n#' data(tgridData)\n#' getSpatialMap(tgridData, method = 'meanAnnual')\n#' getSpatialMap(tgridData, method = 'winter')\n#' \n#' \n#' getSpatialMap(tgridData, method = 'winter', catchment = testCat)\n#' \n#' file <- system.file(\"extdata\", \"points.txt\", package = \"hyfo\")\n#' points <- read.table(file, header = TRUE, sep = ',' )\n#' getSpatialMap(tgridData, method = 'winter', catchment = testCat, points = points)\n#' \n#' @export\ngetSpatialMap <- function(dataset, method = NULL, member = NULL, ...) {\n\n  #check input dataset\n  checkWord <- c('Data', 'xyCoords', 'Dates')\n  if (any(is.na(match(checkWord, attributes(dataset)$names)))) {\n    stop('Input dataset is incorrect, it should contain \"Data\", \"xyCoords\", and \"Dates\", \n          check help for details.')\n  }\n  \n  \n  #range of the dataset just loaded \n  lon <- dataset$xyCoords$x\n  lat <- dataset$xyCoords$y\n  startTime <- as.POSIXlt(dataset$Dates$start, tz = 'GMT')\n  yearIndex <- startTime$year + 1900\n  monthIndex <-startTime$mon + 1\n  data <- dataset$Data\n  \n  # Dimension needs to be arranged. Make sure first and second dimension is lat and lon.\n  att <- attributes(data)$dimensions\n  dimIndex <- seq(1, length(att))\n  dimIndex1 <- match(c('lon', 'lat', 'time'), att)# match can apply to simple cases\n  dimIndex2 <- dimIndex[-dimIndex1]# choose nomatch\n  \n  \n  data <- aperm(data, c(dimIndex1, dimIndex2))\n  attributes(data)$dimensions <- att[c(dimIndex1, dimIndex2)]\n  \n  # Because in the following part, only 3 dimensions are allowed, so data has to be processed.\n  if (is.null(member) & any(attributes(data)$dimensions == 'member')) {\n    dimIndex3 <- which(attributes(data)$dimensions != 'member')\n    data <- apply(data, MARGIN = dimIndex3, FUN = mean, na.rm = TRUE)\n  } else if (!is.null(member) & any(attributes(data)$dimensions == 'member')) {\n    dimIndex3 <- which(attributes(data)$dimensions == 'member')\n    data <- chooseDim(data, dimIndex3, member, drop = TRUE)\n  } else if (!is.null(member) & !any(attributes(data)$dimensions == 'member')){\n    stop('There is no member part in the dataset, but you choose one, check the input\n         dataset or change your arguments.')\n  }\n  \n  \n  \n  \n  if (is.null(method)) {\n    \n    warning('You should shoose a method, unless input is a matrix directly to be plotted.')\n    #in case the dataset is ready to plot and no need to calculate\n    \n  } else if (method == 'meanAnnual') { \n    #mean value of the annual precipitation over the period of the data \n    #time <- proc.time()\n    if (length(unique(monthIndex)) < 12) {\n      warning ('There are less than 12 months in a year, the results may be inaccurate.')\n    }\n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex,  method = 'annual')\n    #newTime <- proc.time() - time\n    title_d  <- 'Mean Annual Precipitation (mm / year)'\n    \n  } else if (method == 'winter') {\n    #mean value of the seasonal precipitation, in this case, winter \n    #time <- proc.time()\n    wm <- match(c(12, 1, 2), unique(monthIndex))\n    if (length(which(!is.na(wm))) < 3) {\n      stop ('Winter has less than 3 months, check data and try to calculate every month\n  seperately or choose another season.')\n    }\n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'winter')\n    #newTime <- proc.time() - time\n    title_d <- 'Mean Winter Precipitation (mm / winter)'\n    \n  } else if (method == 'spring') {\n    wm <- match(c(3, 4, 5), unique(monthIndex))\n    if (length(which(!is.na(wm))) < 3) {\n      stop ('Spring has less than 3 months, check data and try to calculate every month\n  seperately or choose another season.')\n    }\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'spring')    \n    title_d <- 'Mean Spring Precipitation (mm / spring)'\n    \n  } else if (method == 'summer') {\n    wm <- match(c(6, 7, 8), unique(monthIndex))\n    if (length(which(!is.na(wm))) < 3) {\n      stop ('Summer has less than 3 months, check data and try to calculate every month\n  seperately or choose another season.')\n    }\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'summer')    \n    title_d <- 'Mean Summer Precipitation (mm / summer)'\n    \n  } else if (method == 'autumn') {\n    \n    wm <- match(c(9, 10, 11), unique(monthIndex))\n    if (length(which(!is.na(wm))) < 3) {\n      stop ('Autumn has less than 3 months, check data and try to calculate every month\n  seperately or choose another season.')\n    }\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'autumn')    \n    title_d <- 'Mean Autumn Precipitation (mm / autumn)'\n    \n  } else if (method == 'mean') {\n    \n    #sum value of the dataset, this procedure is to get the mean value\n    data_new <- apply(data, MARGIN = c(2, 1), FUN = mean)\n    title_d <- 'Mean Daily Precipitation (mm / day)'\n    \n  } else if (method == 'max') {\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = max)\n    title_d <- 'Max Daily Precipitation (mm / day)'\n    \n  } else if (method == 'min') {\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = min)\n    title_d <- 'Min Daily Precipitation (mm / day)'\n    \n  } else if (is.numeric(method)) {\n    \n    data_new <- apply(data, MARGIN = c(2, 1), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = method)    \n    title_d <- paste(month.abb[method], 'Precipitation (mm / month)', sep = ' ')\n    \n  } else {\n    wrongMethod <- method\n    stop(paste('no method called', wrongMethod))\n  }\n  # This is to give attributes to the matrix and better be melted in ggplot.\n  colnames(data_new) <- round(lon, 2)\n  rownames(data_new) <- round(lat, 2)\n  \n  # If ... also has a title argument, this will cause conflicts. so title has to be renamed as title_d\n  # This has to be paid a lot of attention when use ... to pass arguments.\n  output <- getSpatialMap_mat(matrix = data_new, title_d = title_d, ...)\n  return(output)\n}\n\n\n\n\n\n#' Get spatial map of the input dataset, and a matrix representing the raster map will be returned.\n#' \n#' @param matrix A matrix raster, should be the result of \\code{getSpatialMap()}, output should be default\n#' or 'data'\n#' @param title_d A string showing the title of the plot, defaut is NULL.\n#' @param catchment A catchment file geting from \\code{shp2cat()} in the package, if a catchment is available for background.\n#' @param points A dataframe, showing other information, e.g., location of the gauging stations. The \n#' the data.frame should be with columes \"name, lon, lat, z, value\".\n#' @param output A string showing the type of the output, if \\code{output = 'ggplot'}, the returned \n#' data can be used in ggplot and \\code{getSpatialMap_comb()}; if \\code{output = 'plot'}, the returned data is the plot containing all \n#' layers' information, and can be plot directly or used in grid.arrange; if not set, the raster matrix data\n#' will be returned.\n#' @param info A boolean showing whether the information of the map, e.g., max, mean ..., default is T.\n#' @param scale A string showing the plot scale, 'identity' or 'sqrt'.\n#' @param ... \\code{title, x, y} showing the title and x and y axis of the plot, should be string,\n#'default is about precipitation.\n#' @return A matrix representing the raster map is returned, and the map is plotted.\n#' @examples\n#' data(tgridData)# the result of \\code{loadGridData{ecomsUDG.Raccess}}\n#' #the output type of has to be default or 'data'.\n#' a1 <- getSpatialMap(tgridData, method = 'mean')\n#' a2 <- getSpatialMap(tgridData, method = 'max')\n#' a3 <- getSpatialMap(tgridData, method = 'winter')\n#' a4 <- getSpatialMap(tgridData, method = 'summer')\n#' #For example, if we want to investigate the difference between mean value and max.\n#' \n#' a5 <- a2 - a1\n#' getSpatialMap_mat(a4)\n#' \n#' #Or to investigate the difference between winter value and summer value.\n#' a6 <- a3 - a4\n#' getSpatialMap_mat(a6)\n#' \n#' @export\n#' @import ggplot2 plyr maps maptools rgeos\ngetSpatialMap_mat <- function(matrix, title_d = NULL, catchment = NULL, points = NULL, output = 'data', \n                              info = TRUE, scale = 'identity', ...) {\n  #check input\n  checkWord <- c('lon', 'lat', 'z', 'value')\n  if (is.null(attributes(matrix)$dimnames)) {\n    stop('Input matrix is incorrect, check help to know how to get the matrix.')\n  } else if (!is.null(catchment) & class(catchment) != \"SpatialPolygonsDataFrame\") {\n    stop('Catchment format is incorrect, check help to get more details. ')\n  } else if (!is.null(points) & any(is.na(match(checkWord, attributes(points)$names)))) {\n    stop('Points should be a dataframe with colnames \"lon, lat, z, value\".')\n  }\n  \n  #ggplot\n  #for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function\n  #get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use \n  #data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available \n  #in the environment.\n  #in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them\n  #outside aes() as normal parameters.\n  \n  if (info == TRUE) {  \n    plotMax <- round(max(matrix, na.rm = TRUE), 2)\n    plotMin <- round(min(matrix, na.rm = TRUE), 2)\n    plotMean <- round(mean(matrix, na.rm = TRUE), 2)\n    plotMedian <- round(median(matrix, na.rm = TRUE), 2)\n    word <- paste('\\n\\n', paste('Max', '=', plotMax), ',', paste('Min', '=', plotMin), ',',\n                  paste('Mean', '=', plotMean), ',', paste('Median', '=', plotMedian))\n  } else {\n    word <- NULL\n  }\n  \n  x_word <- paste('Longitude', word)\n  world_map <- map_data('world')\n  \n  data_ggplot <- melt(matrix, na.rm = TRUE)\n  colnames(data_ggplot) <- c('lat', 'lon', 'value')\n  theme_set(theme_bw())\n  \n  mainLayer <- with(data_ggplot, {\n    \n    ggplot(data = data_ggplot) +\n    geom_tile(aes(x = lon, y = lat, fill = value)) +\n    #scale_fill_gradient(high = 'red', low = 'yellow')+\n    scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent',\n                         guide = guide_colorbar(title='Rainfall (mm)', barheight = rel(9)), trans = scale) +#usually scale = 'sqrt'\n    geom_map(data = world_map, map = world_map, aes(map_id = region), fill='transparent', color='black') +\n    #    guides(fill = guide_colorbar(title='Rainfall (mm)', barheight = 15))+\n    xlab(x_word) +\n    ylab('Latitude') +\n    ggtitle(title_d) +\n    labs(empty = NULL, ...) +#in order to pass \"...\", arguments shouldn't be empty.\n    theme(plot.title = element_text(size = rel(1.3), face = 'bold'),\n          axis.title.x = element_text(size = rel(1.2)),\n          axis.title.y = element_text(size = rel(1.2)))\n#   geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),\n#             xmax=min(lon)+0.99*(max(lon)-min(lon)),\n#             ymin=min(lat)+0.02*(max(lat)-min(lat)),\n#             ymax=min(lat)+0.28*(max(lat)-min(lat)),\n#             fill='white',colour='black')+\n#   annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)\n  \n  })\n  \n  printLayer <- mainLayer\n  \n  #catchment conversion\n  if (is.null(catchment) == FALSE) {\n    a <- catchment\n    a@data$id <- rownames(a@data)\n    b <- fortify(a, region = 'id')\n    c <- join(b, a@data, by = 'id')\n    catchmentLayer <- with(c, {\n      geom_polygon(data = c, aes(long, lat, group = group), color = 'black', \n                                   fill = 'transparent')\n    })\n      \n    \n    printLayer <- printLayer + catchmentLayer\n  }\n  #plot points\n  if (is.null(points) == FALSE) {\n    pointLayer <- with(points, {\n      geom_point(data = points, aes(x = lon, y = lat, size = value, colour = z),\n                 guide = guide_legend(barheight = rel(3)))\n        \n        \n    })\n    \n    printLayer <- printLayer + pointLayer\n  }\n  \n  print(printLayer)\n  \n  if (output == 'ggplot') {\n    data_ggplot$Name <- rep(title_d, dim(data_ggplot)[1])\n    return (data_ggplot)\n  } else if (output == 'plot') {\n    return(printLayer)\n  } else {\n    return(matrix)\n  }\n}\n\n\n#' Combine maps together\n#' @param ... different maps generated by \\code{getSpatialMap(, output = 'ggplot')}, see details.\n#' @param nrow A number showing the number of rows.\n#' @param list If input is a list containing different ggplot data, use l\\code{list = inputlist}.\n#' @return A combined map.\n#' @examples\n#' data(tgridData)# the result of \\code{loadGridData{ecomsUDG.Raccess}}\n#' #The output should be 'ggplot'\n#' a1 <- getSpatialMap(tgridData, method = 'summer', output = 'ggplot')\n#' a2 <- getSpatialMap(tgridData, method = 'winter', output = 'ggplot')\n#'# a3 <- getSpatialMap(tgridData, method = 'mean', output = 'ggplot')\n#'# a4 <- getSpatialMap(tgridData, method = 'max', output = 'ggplot')\n#' getSpatialMap_comb(a1, a2)\n#' getSpatialMap_comb(a1, a2, nrow = 2)\n#' @details\n#' For \\code{getSpatialMap_comb}, the maps to be compared should be with same size and resolution, \n#' in other words, they should be fully overlapped by each other.\n#' \n#' If they have different resolutions, use \\code{interpGridData{ecomsUDG.Raccess}} to interpolate.\n#' \n#' @export\n#' @import ggplot2 maps\ngetSpatialMap_comb <- function(..., list = NULL, nrow = 1) {\n  \n  \n  if (!is.null(list)) {\n    data_ggplot <- do.call('rbind', list)\n  } else {\n    maps <- list(...)\n    data_ggplot <- do.call('rbind', maps)\n  }\n  data_ggplot$Name <- factor(data_ggplot$Name, levels = data_ggplot$Name, ordered = TRUE)\n  \n  world_map <- map_data('world')\n  theme_set(theme_bw())\n  mainLayer <- with(data_ggplot, {\n    ggplot(data = data_ggplot) + \n    geom_tile(aes(x = lon, y = lat, fill = value)) +\n    #scale_fill_gradient(high = 'red', low = 'yellow')+\n    scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent') +#usually scale = 'sqrt'\n    geom_map(data = world_map, map = world_map, aes(map_id = region), fill = 'transparent', color = 'black') +\n    facet_wrap(~ Name, nrow = nrow)\n  })\n  \n  suppressWarnings(print(mainLayer))\n}\n\n\n\n\nchooseDim <- function(array, dim, value, drop = FALSE) { \n  # Create list representing arguments supplied to [\n  # bquote() creates an object corresponding to a missing argument\n  indices <- rep(list(bquote()), length(dim(array)))\n  indices[[dim]] <- value\n  \n  if (dim(array)[dim] < value) {\n    stop('Chosen member exceeds the member range of the dataset.')\n  }\n  \n  # Generate the call to [\n  call <- as.call(c(\n    list(as.name(\"[\"), quote(array)),\n    indices,\n    list(drop = drop)))\n  # Print it, just to make it easier to see what's going on\n  # Print(call)\n  \n  # Finally, evaluate it\n  return(eval(call))\n}\n\n",
    "created" : 1436659166408.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "3131779939",
    "id" : "D115C83B",
    "lastKnownWriteTime" : 1436723007,
    "path" : "~/hyfo/R/getSpatialMap.R",
    "project_path" : "R/getSpatialMap.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}