{
    "contents" : "#' Get spatial map of the input dataset, and a matrix representing the raster map will be returned.\n#' \n#' @param dataset A list containing different information, should be the result of reading netcdf file using\n#' \\code{library(ecomsUDG.Raccess)}.\n#' @param method A string showing different calculating method for the map.\n#' @inheritParams getSpatialMap_mat\n#' @return A matrix representing the raster map is returned, and the map is plotted.\n#' @export\ngetSpatialMap <- function(dataset, method = NULL, ...){\n\n  #check input dataset\n  checkWord <- c('Data', 'xyCoords', 'Dates')\n  if(any(is.na(match(checkWord, attributes(dataset)$names)))){\n    stop ('Input dataset is incorrect, it should contain \"Data\", \"xyCoords\", and \"Dates\", \n          check help for details.')\n  }\n  \n  \n  #range of the dataset just loaded \n  lon <- dataset$xyCoords$x\n  lat <- dataset$xyCoords$y\n  startTime <- as.POSIXlt(dataset$Dates$start,tz = 'GMT')\n  yearIndex <- startTime$year + 1900\n  monthIndex <-startTime$mon + 1\n  data <- dataset$Data\n  \n  if (is.null(method)){\n    warning ('You should shoose a method, unless input is a matrix directly to be plotted.')\n    #in case the dataset is ready to plot and no need to calculate\n  }else if(method == 'meanAnnual'){\n    #mean value of the annual precipitation over the period of the data \n    #time <- proc.time()\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex,  method = 'meanAnnualPreci')\n    #newTime <- proc.time() - time\n    title  <- 'Mean Annual Precipitation (mm / year)'\n    \n  }else if(method == 'winter'){\n    #mean value of the seasonal precipitation, in this case, winter\n    \n    #time <- proc.time()\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'winter')\n    #newTime <- proc.time() - time\n    title <- 'Mean Winter Precipitation (mm / winter)'\n    \n  }else if(method == 'spring'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'spring')\n    \n    title <- 'Mean Spring Precipitation (mm / spring)'\n    \n  }else if (method == 'summer'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'summer')\n    \n    title <- 'Mean Summer Precipitation (mm / summer)'\n    \n  }else if (method == 'autumn'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'autumn')\n    \n    title <- 'Mean Autumn Precipitation (mm / autumn)'\n    \n  }else if(method == 'mean'){\n    #sum value of the dataset, this procedure is to get the mean value\n    data_new <- apply(data, MARGIN = c(2,3), FUN = mean)\n    title <- 'Mean Daily Precipitation (mm / day)'\n  }else if(method == 'max'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = max)\n    title <- 'Max Daily Precipitation (mm / day)'\n  }else if(method == 'min'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = min)\n    title <- 'Min Daily Precipitation (mm / day)'\n  }else{\n    wrongMethod <- method\n    stop (paste('no method called',wrongMethod))\n  }\n  #this is to give attributes to the matrix and better be melted in ggplot.\n  colnames(data_new) <- round(lon,2)\n  rownames(data_new) <- round(lat,2)\n  \n  output <- getSpatialMap_mat(data_new, title, ...)\n  return (output)\n}\n\n\n\n\n\n#' Get spatial map of the input dataset, and a matrix representing the raster map will be returned.\n#' \n#' @param matrix A matrix raster, should be the result of \\code{getSpatialMap()}.\n#' @param title A string showing the title of the plot, defaut is NULL.\n#' @param catchment A catchment file geting from \\code{shp2cat()} in the package, if a catchment is available for background.\n#' @param points A dataframe, showing other information, e.g., location of the gauging stations. The \n#' the data.frame should be with columes \"name, lon, lat, z, value\".\n#' @param output A string showing the type of the output, if \\code{output = 'ggplot'}, the returned \n#' data can be used in ggplot and \\code{getSpatialMap_comb()}; if \\code{output = 'plot'}, the returned data is the plot containing all \n#' layers' information, and can be plot directly or used in grid.arrange; if not set, the raster matrix data\n#' will be returned.\n#' @param info A boolean showing whether the information of the map, e.g., max, mean ..., default is T.\n#' @param scale A string showing the plot scale, 'identity' or 'sqrt'.\n#' @param ... \\code{title, y} showing the title and x and y axis of the plot, default is about precipitation.\n#' \\code{limits}, \\code{breaks}, see \\code{scale_fill_gradientn()} for more details.\n#' @return A matrix representing the raster map is returned, and the map is plotted.\n#' @export\n#' @import ggplot2 rgdal plyr\ngetSpatialMap_mat <- function(matrix, title = NULL, catchment = NULL, points = NULL, output = 'data', \n                              info = T, scale = 'identity', ...){\n  #check input\n  checkWord <- c('lon', 'lat', 'z', 'value')\n  if (is.null(attributes(matrix)$dimnames)){\n    stop ('Input matrix is incorrect, check help to know how to get the matrix.')\n  }else if (!is.null(catchment) & class(catchment) != \"SpatialPolygonsDataFrame\"){\n    stop ('Catchment format is incorrect, check help to get more details. ')\n  }else if (!is.null(points) & any(is.na(match(checkWord, attributes(points)$names)))){\n    stop ('Points should be a dataframe with colnames \"lon, lat, z, value\".')\n  }\n  \n  #ggplot\n  #for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function\n  #get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use \n  #data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available \n  #in the environment.\n  #in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them\n  #outside aes() as normal parameters.\n  \n  if (info == T) {\n    plotMax <- round(max(matrix,na.rm=TRUE),2)\n    plotMin <- round(min(matrix,na.rm=TRUE),2)\n    plotMean <- round(mean(matrix,na.rm=TRUE),2)\n    plotMedian <- round(median(matrix,na.rm=T),2)\n    word <- paste('\\n\\n', paste('Max', '=', plotMax), ',', paste('Min', '=', plotMin), ',',\n                  paste('Mean', '=', plotMean), ',', paste('Median', '=', plotMedian))\n  }else{\n    word <- NULL\n  }\n  \n  x_word <- paste('Longitude', word)\n  world_map <- map_data('world')\n  \n  data_ggplot <- melt(matrix, na.rm = T)\n  colnames(data_ggplot) <- c('lat', 'lon', 'value')\n  theme_set(theme_bw())\n  mainLayer <- ggplot(data = data_ggplot)+ \n    geom_tile(aes(x = lon, y = lat, fill = value))+\n    #scale_fill_gradient(high = 'red', low = 'yellow')+\n    scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent',\n                         guide = guide_colorbar(title='Rainfall (mm)', barheight = 15), trans = scale)+#usually scale = 'sqrt'\n    geom_map(data = world_map, map = world_map, aes(map_id = region), fill='transparent', color='black')+\n    #    guides(fill = guide_colorbar(title='Rainfall (mm)', barheight = 15))+\n    xlab(x_word)+\n    ylab('Latitude')+\n    ggtitle(title)+\n    labs(empty = NULL, ...)+#in order to pass \"...\", arguments shouldn't be empty.\n    theme(plot.title = element_text(size = 20, face = 'bold'),\n          axis.title.x = element_text(size = 18),\n          axis.title.y = element_text(size = 18))\n  #     geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),\n  #               xmax=min(lon)+0.99*(max(lon)-min(lon)),\n  #               ymin=min(lat)+0.02*(max(lat)-min(lat)),\n  #               ymax=min(lat)+0.28*(max(lat)-min(lat)),\n  #               fill='white',colour='black')+\n  #   annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)\n  \n  printLayer <- mainLayer\n  \n  #catchment conversion\n  if(is.null(catchment) == FALSE){\n    a <- catchment\n    a@data$id <- rownames(a@data)\n    b <- fortify(a,region='id')\n    c <- join(b,a@data,by='id')\n    catchmentLayer <- geom_polygon(data=c, aes(long,lat,group=group), color='black', fill='transparent')\n    \n    printLayer <- printLayer + catchmentLayer\n  }\n  #plot points\n  if(is.null(points) == FALSE){\n    pointLayer <- geom_point(data = points,aes(x = lon, y = lat, size = value, colour = z))\n    \n    printLayer <- printLayer + pointLayer\n  }\n  \n  print (printLayer)\n  \n  if(output == 'ggplot') {\n    data_ggplot$Name <- rep(title, dim(data_ggplot)[1])\n    return (data_ggplot)\n  }else if (output == 'plot'){\n    return(printLayer)\n  }else{\n    return(matrix)\n  }\n}\n\n\n#' Combine maps together\n#' @param ... different maps generated by \\code{getSpatialMap(, output = 'ggplot')}\n#' @param nrow A number showing the number of rows.\n#' @param list If input is a list containing different ggplot data, use l\\code{list = inputlist}.\n#' @return A combined map.\n#' @export\n#' @import ggplot2\ngetSpatialMap_comb <- function(..., list = NULL, nrow = 1){\n  \n  \n  if (!is.null(list)){\n    data_ggplot <- do.call('rbind', list)\n  }else{\n    maps <- list(...)\n    data_ggplot <- do.call('rbind', maps)\n  }\n  \n  \n  world_map <- map_data('world')\n  theme_set(theme_bw())\n  mainLayer <- ggplot(data = data_ggplot)+ \n    geom_tile(aes(x = lon, y = lat, fill = value))+\n    #scale_fill_gradient(high = 'red', low = 'yellow')+\n    scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent')+#usually scale = 'sqrt'\n    geom_map(data = world_map, map = world_map, aes(map_id = region), fill = 'transparent', color='black')+\n    facet_wrap(~ Name, nrow = nrow)\n  print (mainLayer)\n}\n\n",
    "created" : 1434973036191.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "1816195858",
    "id" : "26229C8",
    "lastKnownWriteTime" : 1434991128,
    "path" : "~/hyfo/R/getSpatialMap.R",
    "project_path" : "R/getSpatialMap.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}