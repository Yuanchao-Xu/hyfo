{
    "contents" : "#' get mean rainfall bar plot of the input dataset\n#' \n#' @param dataset A list containing different information, should be the result of reading netcdf file using\n#' \\code{library(ecomsUDG.Raccess)}, e.g., \\code{loadGridData{ecomsUDG.Raccess}}\n#' @param method A string showing the calculating method of the input time series, including: \"meanMonthly\",\n#' \"annual\", and one umber from 1 to 12 representing the month.\n#' @param output A string showing the type of the output, if \\code{output = 'ggplot'}, the returned \n#' data can be used in ggplot and \\code{getPreciBar_comb()}; if \\code{output = 'plot'}, the returned data is the plot containing all \n#' layers' information, and can be plot directly or used in grid.arrange; if not set, the data\n#' will be returned.\n#' @param plotRange A boolean showing whether the range will be plotted.\n#' @param ... \\code{title, x, y} showing the title and x and y axis of the plot.\n#' @examples\n#' #gridData provided by package is the result of \\code{loadGridData{ecomsUDG.Raccess}}\n#' b1 <- getPreciBar(tgridData, method = 'annual')\n#' b2 <- getPreciBar(tgridData, method = 'meanMonthly')\n#' \n#' @return The calculated mean value of the input time series and the plot of the result.\n#' @export\ngetPreciBar <- function(dataset, method, output = 'data', plotRange = TRUE, ...) {\n  \n  \n  #check input dataset\n  checkWord <- c('Data', 'xyCoords', 'Dates')\n  if (any(is.na(match(checkWord, attributes(dataset)$names)))) {\n    stop('Input dataset is incorrect, it should contain \"Data\", \"xyCoords\", and \"Dates\", \n          check help for details.')\n  }\n  \n  \n  data <- dataset$Data\n  startTime <- as.POSIXlt(dataset$Dates$start, tz = 'GMT')\n  yearIndex <- startTime$year + 1900\n  monthIndex <- startTime$mon + 1\n  TS <- apply(data, MARGIN = 1, FUN = mean, na.rm = TRUE) \n  \n  \n  if (method == 'meanMonthly') {\n    \n    monthlypreci <- tapply(TS, INDEX = list(yearIndex, monthIndex), FUN = sum, na.rm = TRUE)\n    meanMonthlyPreci <- apply(monthlypreci, MARGIN = 2, FUN = mean, na.rm = TRUE)\n    \n    title <- 'Mean Monthly Precipitation'\n    xlab <- 'Month'\n    \n    plotPreci <- data.frame(Index = month.abb[1:12], Preci = meanMonthlyPreci)\n    plotPreci$Index <- factor(plotPreci$Index, levels = plotPreci$Index, ordered = TRUE)\n    \n    if (plotRange) {\n      maxValue <- apply(monthlypreci, MARGIN = 2, FUN = max, na.rm = TRUE)\n      minValue <- apply(monthlypreci, MARGIN = 2, FUN = min, na.rm = TRUE)\n      \n      plotPreci$maxValue <- maxValue\n      plotPreci$minValue <- minValue\n      \n      ylim <- c(0,max(maxValue, na.rm = TRUE) * 1.1)\n      \n    } else {\n      ylim <- c(0,max(meanMonthlyPreci, na.rm = TRUE) * 1.1)\n    }\n    \n    \n  } else if (method == 'annual') {\n    annualPreci <- tapply(TS, INDEX = yearIndex, FUN = sum, na.rm = TRUE)\n    title <- 'Annual Precipitation'\n    xlab <- 'Year'\n    plotName <- names(annualPreci)\n    \n    plotPreci <- data.frame(Index = names(annualPreci), Preci = annualPreci)\n    plotPreci$Index <- factor(plotPreci$Index, levels = plotPreci$Index, ordered = TRUE)\n    \n    ylim <- c(0, max(annualPreci, na.rm = TRUE) * 1.1)\n    \n  } else if (is.numeric(method)) {\n    month <- method\n    monthlyPreci <- tapply(TS, INDEX = list(yearIndex, monthIndex), FUN = sum)[, month]\n    \n    plotPreci <- data.frame(Index = names(monthlyPreci), Preci = monthlyPreci)\n    plotPreci$Index <- factor(plotPreci$Index, levels = plotPreci$Index, ordered = TRUE)\n    \n    title <- paste(month.abb[month], 'Precipitation over Whole Period', sep = ' ')\n    xlab <- 'Year'\n    ylim <- c(0,max(monthlyPreci, na.rm = TRUE) * 1.1)\n    \n  } else {\n    stop(paste('No method called \"', method, '\", check help for information'))\n  }\n  \n  \n  xlim <- c(0, length(rownames(plotPreci))) \n  meanValue <- round(mean(plotPreci$Preci, na.rm = TRUE), 2)\n  medianValue <- round(median(plotPreci$Preci,na.rm = TRUE), 2)\n  plotMean <- paste('Mean', ' = ', meanValue)\n  plotMedian <- paste('Median', ' = ', medianValue)\n  \n  plotMax <- round(max(plotPreci$Preci, na.rm = TRUE), 2)\n  plotMin <- round(min(plotPreci$Preci, na.rm = TRUE), 2)\n  word <- paste('\\n\\n', paste(' Max', '=', plotMax), ',', paste('Min', '=', plotMin), ',',\n                plotMean, ',', plotMedian)\n  \n  xlab <- paste(xlab, word)\n  \n  theme_set(theme_bw())\n  \n  mainLayer <- with(plotPreci, {\n    ggplot(plotPreci)+\n    geom_bar(aes(x = Index, y = Preci), stat = 'identity', colour = 'black', fill = 'lightblue', width = .6)+\n    xlab(xlab)+\n    ylab('Precipitation (mm)')+\n    ggtitle(title)+\n    labs(empty = NULL, ...)+#in order to pass \"...\", arguments shouldn't be empty.\n    theme(plot.title = element_text(size = 20, face = 'bold'),\n          axis.title.x = element_text(size = 18),\n          axis.title.y = element_text(size = 18))+\n#    geom_text(x = min(xlim) + 0.95 * (max(xlim) - min(xlim)), y = min(ylim) + 0.15 * (max(ylim) - min(ylim)),\n#              label = word)+\n    geom_hline(yintercept = meanValue)+\n    geom_text(x = min(xlim) + 0.3 * (max(xlim) - min(xlim)), y = meanValue + 3, vjust = 0, label = 'mean')+\n    geom_hline(yintercept = medianValue, colour = 'red')+\n    geom_text(x = min(xlim) + 0.6 * (max(xlim) - min(xlim)), y = medianValue + 3, vjust = 0,\n              label = 'median', colour = 'red')\n  })\n  \n\n  if (plotRange) {\n    if (is.null(plotPreci$maxValue)) {\n      warning('There is no plotRange for this method')\n      print(mainLayer)\n    } else {\n      rangeLayer <- with(plotPreci, {\n        geom_errorbar(aes(x = Index, ymax = maxValue, ymin = minValue), width = 0.3)\n      })\n        \n      print(mainLayer + rangeLayer)\n    }\n    \n  } else {\n    print(mainLayer)\n  } \n  \n  if (output == 'plot') {\n    return(mainLayer)\n  } else if (output == 'ggplot') {\n    plotPreci$Name <- rep(title, dim(plotPreci)[1])\n    return(plotPreci)\n  } else {\n    return(plotPreci)\n  }\n}\n\n\n#' Combine bars together\n#' @param ... different barplots generated by \\code{getPreciBar(, output = 'ggplot')}, refer to details.\n#' @details\n#' ..., representing different ouput generated by \\code{getPreciBar(, output = 'ggplot')}, they \n#' have to be of the same type, e.g., \n#' 1. Jan precipitation of different years, Feb precipitation of different years, and... \n#' They are both monthly precipitation, and they share x axis.\n#' \n#' 2. Mean monthly precipitation of different dataset. e.g., long term mean monthly precipitation\n#' and short term mean monthly precipitation. They are both mean monthly precipitation.\n#' \n#' @param nrow A number showing the number of rows.\n#' @param list If input is a list containing different ggplot data, use l\\code{list = inputlist}.\n#' @return A combined barplot.\n#' @examples\n#' \n#' data(tgridData)# the result of \\code{loadGridData{ecomsUDG.Raccess}}\n#' #output type of getPreciBar() has to be 'ggplot'.\n#' b1 <- getPreciBar(tgridData, method = 2, output = 'ggplot')\n#' b2 <- getPreciBar(tgridData, method = 3, output = 'ggplot')\n#' \n#' getPreciBar_comb(b1, b2)\n#' \n#' @export\n#' @import ggplot2\ngetPreciBar_comb <- function(..., list = NULL, nrow = 1) {\n  if (!is.null(list)) {\n    data_ggplot <- do.call('rbind', list)\n  } else {\n    \n    bars <- list(...)\n    data_ggplot <- do.call('rbind', bars)\n  }\n\n  data_ggplot$Name <- factor(data_ggplot$Name, levels = data_ggplot$Name, ordered = TRUE)\n  \n  theme_set(theme_bw())\n  \n  mainLayer <- with(data_ggplot, {\n    mainLayer <- ggplot(data_ggplot)+\n      geom_bar(aes(x = Index, y = Preci, fill = Name), stat = 'identity', colour = 'black', width = .6)+\n      facet_wrap( ~ Name, nrow = nrow)\n  })\n\n  \n  print(mainLayer)\n}\n\n",
    "created" : 1435501767225.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "3300837989",
    "id" : "815FA067",
    "lastKnownWriteTime" : 1435452011,
    "path" : "~/hyfo/R/getPreciBar.R",
    "project_path" : "R/getPreciBar.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}