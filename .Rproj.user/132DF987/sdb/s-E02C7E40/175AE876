{
    "contents" : "#source(\"C:\\\\DHI_Projects\\\\11811405\\\\Seasonal_Forecasting\\\\R\\\\Data_Analysis\\\\Main.R\")\n\nrequire(xlsx)\nrequire(ggplot2)\nrequire(reshape2)\nrequire(moments)\nrequire(zoo)\n\n\n############################### Functions  ########################################################################\n\n###################################################################################################################\n\n\n\n\n\n############################### For reading data from excel,txt,and csv\n\n\n\nreadTable_excel_anarbe <- function(fileName){\n  \n  index <- tail(strsplit(fileName,'\\\\.|\\\\ ')[[1]],3)\n  raw_year <- index[1]\n  raw_mon <- index[2]\n  \n  raw <- read.xlsx(fileName,sheetName='A')\n  startRow <- which(raw=='COTA',arr.ind=T)[1]+4\n  startCol <- which(raw=='COTA',arr.ind=T)[2]-1\n  stopRow <- which(raw =='TOTAL',arr.ind=T)[1]-1\n  stopCol1 <- startCol + 17\n  stopCol2 <- which(raw == 'SUPERFICIE',arr.ind=T)[2]\n  data <- cbind(raw[startRow:stopRow,startCol:stopCol1],raw[startRow:stopRow,stopCol2])\n  \n\n  yearIndex <- rep(raw_year,stopRow-startRow+1)\n  monIndex <- rep(raw_mon,stopRow-startRow+1)\n  \n  data <- cbind(yearIndex,monIndex,data)\n  return (data)\n}\n\n\nreadColumn_excel_anarbe <- function(fileName,keyword = NULL){\n  \n  index <- tail(strsplit(fileName,'\\\\.|\\\\ ')[[1]],3)\n  year <- as.numeric(index[1])\n  mon <- as.numeric(index[2])\n  \n  if(year == 99){\n    year = year + 1900\n  }else year = year + 2000\n  \n  word = c('COTA','Cota\\n(m)','TOTAL','  TOTAL')\n  \n  if (keyword == 'waterLevel'){\n    searchWord <- c('COTA','Cota\\n(m)')\n  }else if (keyword =='discharge_ERE'){\n    searchWord <- c('AF.ERE-','Caudal\\n(mB3/s)')\n  }else if (keyword == 'waterBalance'){\n    searchWord <- c('INCREMENTO','al Canal Bajo','AFORO',\n                    'VariaciC3n\\nvolumen embalsado')\n  }else if (keyword == 'surfaceArea'){\n    searchWord <- c('SUPERFICIE', 'SUPERFICIE')\n  }else if (keyword == 'volume'){\n    searchWord <- c('EMBALSADO', 'Volumen\\n(mCB3)')\n  }\n  \n  \n  if (year == 1999 | year < 2009 | (year == 2009 & mon < 5)){\n    raw <- read.xlsx(fileName,sheetName='A')\n    startIndex <- which(raw == word[1],arr.ind=T)\n    endIndex <- which(raw == word[3],arr.ind=T)\n    startRow <- startIndex[1]+4\n    endRow <- endIndex[1]-1\n    \n    dayCol <- endIndex[2]\n    day <- raw[startRow:endRow,dayCol]\n\n    targetCol <- which(raw == searchWord[1],arr.ind=T)[2]\n    \n    if (is.na(targetCol)) stop (sprintf('capture nothing in %s',fileName))\n    \n    if(keyword == 'waterBalance'){\n      targetStart <- targetCol\n      targetEnd <- which(raw == searchWord[3],arr.ind=T)[2]\n      a <- raw[startRow:endRow,targetStart:targetEnd]\n      a <- sapply(a,function(x) as.numeric(levels(x)[x]))\n      \n      if(year == 1999 & mon ==4){\n        \n        target <- data.frame(a[,2]*86.4,a[,5]*86.4,rep(NA,dim(a)[1]),a[,6]*86.4,\n                             a[,4]*86.4,a[,11]*86.4,a[,3],a[,7],rep(NA,dim(a)[1]),a[,1])\n      }else{\n        target <- data.frame(a[,2]*86.4,a[,5]*86.4,a[,6]*86.4,a[,7]*86.4,a[,4]*86.4,\n                             a[,12]*86.4,a[,3],a[,8],rep(NA,dim(a)[1]),a[,1])\n      }   \n      \n    }else{\n      target <- raw[startRow:endRow,targetCol]\n      if(keyword == 'discharge_ERE') target <- as.numeric(levels(target))[target]/1000\n    }\n    \n  }else{\n    raw <- read.xlsx(fileName,sheetName='parte del embalse')\n    startIndex <- which(raw == word[2],arr.ind=T)\n    endIndex <- which(raw == word[4],arr.ind=T)\n    startRow <- startIndex[1]+1\n    endRow <- endIndex[1]-2\n    \n    dayCol <- endIndex[2]\n    day <- raw[startRow:endRow,dayCol]\n    targetCol <- which(raw == searchWord[2],arr.ind=T)[2]\n    if (is.na(targetCol)) stop (sprintf('capture nothing in %s',fileName))\n    \n    if(keyword == 'waterBalance'){\n      targetStart <- targetCol\n      targetEnd <- which(raw == searchWord[4],arr.ind=T)[2]\n      target <- raw[startRow:endRow,targetStart:targetEnd]\n      \n    }else{\n      target <- raw[startRow:endRow,targetCol]\n    }\n    \n  }\n    \n  \n  startDate <- as.Date(paste(year,mon,day[1],sep='-'))\n  endDate <- as.Date(paste(year,mon,tail(day,1),sep='-'))\n  \n  Date <- seq(startDate,endDate,1)\n  output <- data.frame(Date,as.vector(target))\n  colnames(output) <- c('Date',seq(1,dim(output)[2]-1))\n  message (fileName)  \n  return (output)\n  \n}\n\n\ncollectData_excel_anarbe <- function(folderName,keyword=NULL,output=T){\n  newFileName <- file.choose(new = T)\n  message ('new file should be located a different location than the excel folder, \n         in order to avoid error.\n         At least 2 excels should be in the folder\\n')\n  \n  message ('this function only applies to strange spain dem operation record file, and this strange file changes\n         its format in the middle of the record. For other applications, some tiny changes needs to be made.')\n  if(is.null(keyword)) stop ('key word is needed, e.g.\"waterLevel\".')\n  \n  fileNames <- list.files(folderName,pattern='*.xls',full.names=T)\n  data <- lapply(fileNames,FUN=readColumn_excel_anarbe,keyword = keyword)\n  checkBind(data,'rbind')\n  data <- do.call('rbind',data)\n  \n  data_new <- data.frame(data)\n  \n  data_new <- data_new[order(data_new[,1]),]\n  \n  \n  startDate <- data_new[1,1]\n  endDate <- data_new[length(data_new[,1]),1]\n  \n  Date <- as.factor(seq(startDate,endDate,by=1))\n  \n  if(length(Date)!=length(data_new[,1])) stop ('check if the excel files are continuous')\n  \n  colnames(data_new) <- c('Date',keyword)\n  \n  write.table(data_new,file=newFileName,\n              row.names = F, col.names = T,sep=',')\n  if(output == T) return (data_new)\n}\n\ncheckBind <- function(data,bind){\n  # data has to be a list of values, and will be used in do.call('rbind')\n  message ('check if the data list is available for rbind or cbind...')\n  if (bind == 'rbind'){\n    colNum <- sapply(data,function(x) dim(x)[2])\n    colLev <- unique(colNum)\n    if (length(colLev) != 1){\n      dif <- colLev[2]\n      difNum <- which(colNum == dif)\n      stop (sprintf('different Colomn number in %s th of the data list',difNum))\n      \n    }\n    \n  }else if (bind =='cbind'){\n    rowNum <- sapply(data,function(x) dim(x)[1])\n  }\n  \n  message ('Data list is OK')\n}\n\n\nanarbe_txt <- function(dataset,x1,x2){\n  \n  data <- as.matrix(dataset[x1:x2,2:13])\n  startYear <- data[1,6]\n  \n  data <- data[5:35,]\n  \n  date <- which(data!='          ',arr.ind=T)\n  startDate <- date[1,]\n  \n  endDate <- date[length(date[,1]),]\n  \n  startDate <- as.Date(paste(startYear,startDate[2],startDate[1],sep='-'))\n  endDate <- as.Date(paste(startYear,endDate[2],endDate[1],sep='-'))\n  \n  Date <- as.factor(seq(startDate,endDate,1))\n  \n  dim(data) <- c(length(data),1)\n  \n  data <- as.numeric(data[which(data!='          '),])\n  \n  if (length(data) != length(Date)){\n    stop('check original txt file. for missing value, the symbol is \"--\", check\n         if this symbol is missing somewhere')\n  }\n    \n  output <- data.frame(Date = Date, target = data)\n\n  return(output)\n}\n\nreadColumn_txt_anarbe <- function(fileName,keyword=NULL,rangeWord=NULL){\n  \n  a <- read.fwf(fileName,width=rep(10,13))\n  \n  startRow <- which(a==rangeWord[1])\n  startRow <- startRow + as.numeric(rangeWord[2])\n  \n  endRow <- which(a==rangeWord[3])\n  endRow <- endRow + as.numeric(rangeWord[4])\n  \n  data <- mapply(FUN=function(x1,x2) anarbe_txt(dataset=a,x1,x2),startRow,endRow)\n  \n  data_new <- data.frame(Data = unlist(data[1,]),target = unlist(data[2,]))\n  message (fileName)\n  return (data_new)\n}\n\ncollectData_txt_anarbe <- function(folderName,output=T,rangeWord=NULL){\n  \n  if(is.null(rangeWord)){\n      stop ('rangeWord consists of 4 elements:\n         1. start word which program can recognise.\n         2. shift1, the shift needs to be made. E.g. start word is in line 7, and program\n            should read file from line 9, then shift is 9-7 = 2.\n         3. end word, as start word\n         4. shift2, same as shift1, sometimes can be negative\n         \n         E.g. rangeWord=c(\\\"aaa\\\",2,\\\"bbb\\\",-2)\n         if no rangeWord, just input c(NULL,NULL,NULL,NULL)')\n  \n  }\n  \n\n  fileNames <- list.files(folderName,pattern='*.TXT',full.names=T)\n  \n  data <- lapply(fileNames,FUN = readColumn_txt_anarbe,rangeWord=rangeWord)\n  \n  data <- do.call('rbind',data)\n  \n  a <- unlist(strsplit(folderName,'\\\\\\\\|/'))\n  tarName <- tail(a,2)[1]\n  colnames(data) <- c('Date',tarName)\n  \n  #newFileName <- file.choose(new = T)\n  message ('new file should be located a different location than the excel folder, \n         in order to avoid error.\n         At least 2 excels should be in the folder')\n  \n  #write.table(data_new,file=newFileName,row.names = F, col.names = F,sep=',')\n  \n  \n  if (output == T) return (data)\n\n}  \n\nreadColumn_csv_anarbe <- function(fileName){\n  data <- read.csv(fileName,skip=3)\n  endIndex <- which(data=='',arr.ind=T)[1]-1\n  \n  data <- data[1:endIndex,]\n  \n  if (!is.null(levels(data[,2]))) {\n    data[,2] <- as.numeric(levels((data[,2])))[data[,2]]\n  }\n  \n  colnames(data) <- c('Date','target')\n  message (fileName)\n  \n  return (data)\n}\n\ncollectData_csv_anarbe <- function(folderName,output=T){\n  fileNames <- list.files(folderName,pattern='*.csv',full.names=T)\n  data <- lapply(fileNames,readColumn_csv_anarbe)\n  data <- do.call('rbind',data)\n  data <- data[,1:2]\n  data[,1] <- as.Date(data[,1],format='%d/%m/%Y')\n  \n  #newFileName <- file.choose(new = T)\n  #write.table(data_new,file=newFileName,row.names = F, col.names = F,sep=',')\n  a <- unlist(strsplit(folderName,'\\\\\\\\|/'))\n  tarName <- tail(a,2)[1]\n  colnames(data) <- c('Date',tarName)\n  \n  if (output) return(data)\n}\n\nreadData_folder <- function(folderName,keyword){\n  \n  folderName <- paste(folderName,keyword,sep='\\\\')\n  \n  fileNames <- list.files(folderName,pattern='*.csv',full.names=T)\n  \n  if (length(fileNames)==0){\n    fileNames <- list.files(folderName,pattern='.TXT',full.names=T)\n    if(length(fileNames)==0) stop ('Wrong keyword, initial has to be Upper-case')\n    \n    data <- collectData_txt_anarbe(folderName,rangeWord = c('D?a       ',-1,'M?x.      ',-5))\n    rownames(data) <- NULL\n  }else {\n    data <- collectData_csv_anarbe(folderName)\n  }\n  \n  return (data)\n}\n\n\ncollectData_anarbe <- function(keyword){\n  message ('Choose the main folder that, in it, there are different folders representing different gauging stations,\n           all the gauging stations have precipitation data, some of them also have discharge data,\n           this function is to open different gauging folders and read the data, arragen them together.')\n  message ('\\n\\n\n           new file is a list based file and needs to be read by dget()')\n  \n  folderName <- choose.dir()\n  fileNames <- list.files(folderName,full.names=T)\n  data <- lapply(fileNames, FUN=readData_folder, keyword=keyword)\n  \n  names <- sapply(c(1:length(data)),function(x) colnames(data[[x]])[2])\n  names(data) <- names\n  \n  fileName <- file.choose(new=T)\n  dput(data,file=fileName)\n  \n  return (data)\n}\n\n############################## For extract Period\n\nextractPeriod_dataset <- function(dataset, startDate, endDate){\n  \n  dataset[,1] <- as.Date(dataset[,1])\n  \n  startIndex <- which(dataset[,1] == startDate)\n  endIndex <- which(dataset[,1] == endDate)\n  \n  output <- dataset[startIndex:endIndex,]\n  \n  return (output)  \n}\n\nextractPeriod_getDate <- function(dataset){\n  start <- as.Date(dataset[1,1])\n  end <- as.Date(tail(dataset[,1],1))\n  \n  return (c(start,end))\n}\n\nextractPeriod <- function(datalist,startDate = NULL,endDate = NULL, commonPeriod = F){\n  message('dataset has to be generated by dput() and read by dget(), list based dataset,\n          with first column to be the Date')\n  \n  if (!is.null(startDate)&!is.null(endDate)&commonPeriod == F){\n    dataset <- lapply(datalist,extractPeriod_dataset,startDate=startDate,endDate=endDate)\n  }else if (is.null(startDate)&is.null(endDate)&commonPeriod == T){\n    \n    Dates <- lapply(datalist,extractPeriod_getDate) \n    Dates <- do.call('rbind',Dates)\n    \n    startDate <- zoo::as.Date(max(Dates[,1]))\n    endDate <- zoo::as.Date(min(Dates[,2]))\n    \n    dataset <- lapply(datalist,extractPeriod_dataset,startDate=startDate,endDate=endDate)\n    \n  }else{\n    stop ('Enter startDate and endDate, set commonPeriod as False, or simply set commonPeriod as TRUE')\n  }\n\n  return(dataset)\n}\n\n################################### Annual Rainfall\n\ngetAnnual_dataframe <- function(dataset, output = 'series'){\n  Date <- as.Date(dataset[,1])\n  year <- format(Date,'%Y')\n  yearUnique <- unique(year)\n  calcuNum <- c(1: length(yearUnique))\n  \n  NANum <- length(which(is.na(dataset[,2])))\n  \n  annualPreci <- tapply(dataset[,2], INDEX = year, FUN = sum, na.rm = T)\n  NANum <- tapply(dataset[,2], INDEX = year, function(x) length(which(is.na(x))))\n  \n  \n  firstYearN <- length(which(year == year[1]))\n  if (firstYearN < 360) calcuNum[1] <- NA \n  \n  lastYearN <- length(which(year == year[length(year)]))\n  if (lastYearN < 360) calcuNum[length(yearUnique)] <- NA\n  \n  calcuNum[which(NANum > 10)] <- NA\n  \n  meanV <- mean(annualPreci[which(!is.na(calcuNum))])\n  \n  if (output == 'mean'){\n    name <- colnames(dataset)[2]\n    output <- data.frame(name,meanV)\n    return (output)\n  }else if(output == 'series'){\n    name <- rep(colnames(dataset)[2],length(calcuNum))\n    output <- data.frame(yearUnique,name,annualPreci,NANum)\n    return (output)\n  }\n  \n}\n\ngetAnnual_mean <- function(datalist){\n  data <- lapply(datalist, FUN = getAnnual_dataframe, output = 'mean')\n  data <- do.call('rbind',data)\n  rownames(data) <- NULL\n  \n  return (data)\n}\n\ngetAnnual <- function(datalist){\n  \n  data <- lapply(datalist, FUN = getAnnual_dataframe)\n  \n  data <- do.call('rbind',data)\n  \n  rownames(data) <- NULL\n  return (data)\n}\n\n################################### Dataframe Generation\n\nlist2Dataframe <- function(datalist){\n  message('Applies to datalist, in which every list containing Date column and value column.\n          and all the sublists are in the same period of time. ExtracPeriod() can do that')\n  \n  data <- lapply(datalist, function(x) x[,2])\n  Date <- datalist[[1]][,1]\n  data <- data.frame(data)\n  data <- data.frame(cbind(Date,data))\n  \n  return (data)\n}\n\n#################################### Gap filler\n\nfillGap_column <- function(i, data, corOrder, lmCoef){\n  TS <- data[,i] # extract target column\n  l <- dim(data)[2] # length\n  \n  for (j in 1:l){\n    if (!any(is.na(TS))) break\n    NAindex <- which(is.na(TS))\n    TS[NAindex] <- lmCoef[j,i] * data[NAindex,corOrder[j,i]]\n    \n    if (j == l) stop ('Error: One time consists of all NA values')\n  }\n    \n  return(TS)\n}\n\nmonthlyPreci <- function(TS,year,mon){\n  \n  monTS <- tapply(TS, INDEX = list(year, mon), FUN = sum, na.rm = T)\n  output <- t(monTS)\n  dim(output) <- c(dim(monTS)[1] * dim(monTS)[2],1)\n  return (output)\n}\n\n\n\nfillGap_cor <- function(data, corPeriod = 'monthly', Date){\n  \n  names <- colnames(data)\n  year <- format(Date,'%Y')\n  \n  if (corPeriod == 'monthly'){\n    #based on monthly rainfall\n    mon <- format(Date, '%m')\n    monthlyPreci <- lapply(data, FUN = monthlyPreci, year = year, mon = mon)\n    corData <- do.call('cbind', monthlyPreci)\n  }else if (corPeriod == 'yearly'){\n    year <- format(Date, '%Y')\n    annualPreci <- lapply(data, FUN = function(x) tapply(x, INDEX = year, FUN = sum, na.rm = T))\n    corData <- do.call('cbind', annualPreci)\n  }else if (corPeriod == 'daily'){\n    corData <- data\n  }\n  \n  corData <- data.frame(na.omit(corData))\n  colnames(corData) <- names\n  \n  corN <- cor(corData)\n  \n  return (corN)\n  \n} \n\nfillGap_lmCoef <- function(data, corOrder){\n  l <- dim(data)[2]\n  m <- diag(l)# m is the coeficients matrix\n  m[lower.tri(m)] <- combn(data, 2, function(x) coef(lm(x[,2] ~ x[,1] + 0)))\n  tm <- t(m)\n  \n  tm[lower.tri(tm)] <- combn(data, 2, function(x) coef(lm(x[,1] ~ x[,2] + 0)))\n  \n  m <- t(tm)\n  \n  lmCoef <- lapply(1 : l, function(x) m[x,corOrder[,x]])\n  lmCoef <- do.call('rbind',lmCoef)\n  rownames(lmCoef) <- colnames(data)\n  \n  return(t(lmCoef))\n}\n\nfillGap <- function(dataset,corPeriod = 'daily'){\n  message('Fill gaps. First column should be the Date')\n  \n  Date <- as.Date(dataset[,1])\n  data <- data.frame(dataset[,2:dim(dataset)[2]])\n  names <- colnames(data)\n  \n  corN <- fillGap_cor(data, corPeriod = corPeriod, Date = Date)\n  cat('\\nCorrelation Coefficient\\n')\n  print(corN)\n  \n  corOrder <- apply(corN, MARGIN = 1, FUN = function(x) order(-x))\n  corOrder <- corOrder[2:dim(corOrder)[1],]\n  corOrderName <- t(apply(corOrder, MARGIN = 2, FUN = function(x) names[x]))\n  \n  cat ('\\nCorrelation Order\\n')\n  colnames(corOrderName) <- seq(1 : dim(corOrderName)[2])\n  print (corOrderName)\n  \n  lmCoef <- fillGap_lmCoef(data, corOrder)\n  cat ('\\nLinear Coeficients\\n')\n  rownames(lmCoef) <- seq(1 : dim(corOrderName)[2])\n  print (t(lmCoef))\n  \n  output <- lapply(1:dim(data)[2], fillGap_column, data = data,\n                  corOrder = corOrder, lmCoef = lmCoef)\n  output <- data.frame(output)\n  colnames(output) <- names\n  \n  output <- cbind(Date, output)\n  \n  return (output)\n}\n\n\n################################ For Analysis of Time series\n\ngetLMom <- function(dis){\n  \n  LMom <- lmom::samlmu(dis,nmom=4,ratios=T)\n  \n  mean <- LMom[1]\n  LCV <- LMom[2]/LMom[1]\n  Lskew <- LMom[3]\n  Lkur <- LMom[4]\n  \n  output <- data.frame(mean=mean,Lcv=LCV,Lskew=Lskew,Lkur = Lkur)\n  return (output)\n}\n\n\ngetMoment <- function(dis) {\n  mean <- mean(dis,na.rm=T)\n  variance <- var(dis,na.rm=T)\n  skewness <- skewness(dis,na.rm=T)\n  kurtosis <- kurtosis(dis,na.rm=T)\n  \n  output <- data.frame(mean=mean, Variance = variance, Skewness = skewness, Kurtosis = kurtosis)\n\n  return (output)\n}\n\n\n\n############################ Ploting and Analysis ################################################################\n\n##################################################################################################################\n\n\n\n\n########################################### Read files \n\nfilePath <- file.choose()\na <- read.table(filePath,sep=',')\nfolderName <- choose.dir()\ntest <- collectData_excel_anarbe(folderName,'surfaceArea')\n\ntest1 <- collectData_txt_anarbe(folderName,rangeWord = c('D?a       ',-1,'M?x.      ',-5))\ntest <- collectData_csv_anarbe(folderName)\ntest <- collectData_anarbe('Precipitation')\ntest <- dget(filePath)\ndata <- read.table(filePath,sep=',',header=T)\n\n\n############################################# Rainfall plotting\n\nfilePath <- file.choose()\ndatalist <- dget(filePath) # read list file for different rainfall\nrainfall <- extractPeriod(datalist,commonPeriod = T) # extract Common Period\nrainfall <- list2Dataframe(rainfall)# convert to dataframe\n\n\n## Fill Gap\n# rainfall has to be dataframe, and the first column should be as Date\nfilled_rainfall <- fillGap(rainfall,'monthly')\n\nnewFileName <- file.choose()\n#### write to file\nwrite.table(test[[16]], file = newFileName, row.names = F, col.names = T, sep = ',')\n\n\ndata <- melt(filled, id.vars = 'Date')\n\n# For daily rainfall\nmainLayer <- ggplot(data)+\n  aes(x = Date, y = value , color = variable)+\n  geom_line(stat='identity',width=0.8)\nprint(mainLayer)\n\n# For annual rainfall, for each dataframe, calculate each year's annual rainfall\n\nannuals <- getAnnual(datalist)\n\ndata <- melt(annuals, var.id = c('yearUnique','name'))\n\nmainLayer <- ggplot(data)+\n  geom_bar(aes(x = as.Date(yearUnique,format = '%Y'), y = value , fill = name),stat='identity')+\n  facet_grid(variable~name,scales='free')\nprint (mainLayer)\n\n# For mean annual rainfall\n\nmeanAnnuals <- getAnnual_mean(datalist)\n\n\n############################################# Discharge Comparison\n\nfilePath <- file.choose()\n\nANA <- read.table(filePath,sep=',',header=T)\ncolnames(web) <- c('Date','ANA')\n\nERE <- read.table(filePath,sep=',',header=T)\ncolnames(excel) <- c('Date','ERE')\n\na <- list(ANA,ERE) \na1 <- extractPeriod(a,commonPeriod = T)\na2 <- list2Dataframe(a1)\ncolnames(a2) <- c('Date','ANA','ERE')\n\n\ndata <- melt(a2, id.vars = 'Date')\n\n\nmainLayer <- ggplot(data)+\n  aes(x = as.Date(Date), y = value , color = variable)+\n  geom_line(stat='identity',width=0.8)+\n  coord_cartesian(xlim = c(as.Date('1999-1-1'),as.Date('2015-5-1')),ylim=c(0,250))\nprint(mainLayer)\n\n########### Accumulative\n\na3 <- a2\na3[which(is.na(a3[,2])),2] <- 0 \na3[which(is.na(a3[,3])),3] <- 0 \n\na4 <- a3\na4[,2] <- cumsum(a4[,2])\na4[,3] <- cumsum(a4[,3])\n\n\ndata1 <- melt(a4, id.vars = 'Date')\n\nmainLayer <- ggplot(data1)+\n  aes(x = as.Date(Date), y = value , color = variable)+\n  geom_line(stat='identity',size=1)+\n  coord_cartesian(xlim = c(as.Date('1999-1-1'),as.Date('2015-5-1')),ylim=NULL)\nprint(mainLayer)\n\n\nnewFileName <- file.choose(new = T)\nwrite.table(a2,file=newFileName,\n            row.names = F, col.names = T,sep=',')\n\n############################################### Analyze rainfall from website\n\ndata <- read.table(filePath,sep=',',header=T)\n\ndata$Date <- as.Date(data$Date)\nmon <- format(data$Date,'%m')\nyear <- format(data$Date,'%Y')\nday <- format(data$Date,'%d')\n\ndata_annual <- data[,2:7]\n\nmeanAnnualPreci <- apply(data_annual,MARGIN=2,FUN=getAnnual,year=year)\nmeanAnnualPreci_NAnum <- apply(data_annual,MARGIN=2,FUN=getNAnum,year=year)\n\nannualPreci <- apply(data_annual,MARGIN=2,FUN=getAnnual,year=year,full=T)\nannualPreci_NAnum <- apply(data_annual,MARGIN=2,FUN=getNAnum,year=year,full=T)\n\n\nelevation <- c(183,313,97,25,323,273)\n\nplotData <- data.frame(Name = names(meanAnnualPreci),ele=elevation,meanAnnualPreci=meanAnnualPreci)\n\n\n\n############################################ For plot the text file\ndata1 <- melt(annualPreci)\ndata2 <- melt(annualPreci_NAnum)\n\nmainLayer <- ggplot(data1)+\n  aes(x=Var1,y=value,fill=data1$Var2)+\n  geom_bar(stat='identity',position='dodge',width=0.5)\nprint(mainLayer)\n\n\n\nmainLayer <- ggplot(data1)+\n  aes(x=Var1,y=value,colour=data1$Var2)+\n  geom_line(stat='identity',size=1)\nprint(mainLayer)\n\n###### Analyse NA number of data\n\nAnnual <- lapply(seq(1,6),FUN=NAnumCombine)\nAnnual1 <- do.call('rbind',Annual)\ncolnames(Annual1) <- c('year','NO','NAnum','annualPreci')\n#melt() can capture rownames which it is a matrix, not a dataframe\n#but if you don't want rownames to be captured, it has to be converted to data.frame.\n#matrix is just a matrix, with two dimension, row and column. so they will be captured automatically,\n#while data.frame can have more than one column, in this case, rownames not captured\ndata3 <- melt(data.frame(Annual1),id.vars=c('year','NO'))\ndata3$NO <- as.factor(data3$NO)\nlevels(data3$NO) <- c('Ana','Art','Arr','Ere','Goi','End')\n\nmainLayer <- ggplot(data3)+\n  geom_bar(aes(x=year,y=value,fill=variable),stat='identity',position='dodge')+\n  facet_grid(variable~NO,scales='free')\nprint (mainLayer)\n\n\n################### Plot elevation and precipitation\n\nmainLayer <- ggplot(data=plotData)+\n  aes(x=ele,y=meanAnnualPreci,fill=Name,colour=Name)+\n  geom_point(size = 10)+\n  geom_smooth(method=lm,aes(group=1))+\n  coord_cartesian(xlim = NULL,ylim=c(0,2500))\n\nprint (mainLayer)\n\n#plot rainfall\nmainLayer <- ggplot(data)+\n  geom_line(aes(x=as.Date(Date),y=Art,group=1))+\n  scale_x_date()\n\nprint(mainLayer)\n\n############################################ Frequency analysis\n\n##plot hist\n\nmainLayer <- ggplot(data)+\n  #geom_histogram(aes(x=Ere),bin=1)+\n  geom_histogram(aes(x=Ere),colour='blue',binwidth =5,na.rm=T)+\n#  geom_histogram(aes(x=Ana),colour='red',na.rm=T)+\n  coord_cartesian(xlim = NULL,ylim=NULL)\n\nprint (mainLayer)\n\n##density plot\n\nmainLayer <- ggplot(data)+\n  #geom_histogram(aes(x=Ere),bin=1)+\n  geom_density(aes(x=Ere),colour='blue',binwidth =5,na.rm=T)+\n  #  geom_histogram(aes(x=Ana),colour='red',na.rm=T)+\n  coord_cartesian(xlim = c(10,100),ylim=NULL)\n\nprint (mainLayer)\n\n\n## CDF \nmainLayer <- ggplot(data)+\n  stat_ecdf(aes(x=Ere))+\n  coord_cartesian(xlim=NULL)\n\nprint (mainLayer)\n\n##plot position\n\nmainLayer <- ggplot(data)+\n  geom_point(aes(x=reorder(Date,-Ere),y=Ere))\n\nprint (mainLayer)\n\n\n##########################################for plot the excel files\nmainLayer <- ggplot(data = test)+\n  geom_line(aes(x=Date,y=waterLevel,group=1),stat='identity',colour='black',fill='lightblue',width=.6)+\n  scale_x_date()+\n  xlab('Year')+\n  ylab('Water Level(mm)')+\n  ggtitle('Water Level in Reservoir')+\n  theme(plot.title=element_text(size=20,face='bold'),\n        axis.title.x=element_text(size = 18),\n        axis.title.y = element_text(size = 18))\n\n\n+\n  geom_text(x=min(xlim)+0.95*(max(xlim)-min(xlim)),y=min(ylim)+0.15*(max(ylim)-min(ylim)),label=word)+\n  geom_hline(yintercept=meanValue)+\n  geom_text(x=min(xlim)+0.3*(max(xlim)-min(xlim)),y=meanValue+3,label=plotMean)+\n  geom_hline(yintercept=medianValue,colour='red')+\n  geom_text(x=min(xlim)+0.6*(max(xlim)-min(xlim)),y=medianValue+3,label=plotMedian,colour='red')\n",
    "created" : 1434493450977.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "3130025617",
    "id" : "175AE876",
    "lastKnownWriteTime" : 1434059035,
    "path" : "C:/DHI_Projects/11811405/Seasonal_Forecasting/R/Data_Analysis/Data_extraction.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}