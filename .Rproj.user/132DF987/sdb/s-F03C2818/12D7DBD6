{
    "contents" : "###Main Program\n\n#version 1.2\n\n#functions used in Start.\n\n\n#Libraries\n#########################################################################################################################\n\n#the library speacially designed for the model, and used for getting data from the model\nrequire(ecomsUDG.Raccess)#for loading online forcast data\nrequire(downscaleR)\nrequire(raster)\nrequire(R.utils)\n#require(fields)#for showing basic basemap\nrequire(rgdal)#for read shape file\nrequire(ggplot2)\nrequire(reshape2)\nrequire(maps)\nrequire(rgeos)\nrequire(maptools)\nrequire(plyr)\n#library(gWidgets)#for GUI\n#library(gWidgetsRGtk2)#for GUI\n\n\n#Functions\n#########################################################################################################################\n\n\ngetSpatialMap <- function(dataset, catchment = NULL,points = NULL, method = NULL, outputData = TRUE, \n                          plotScale = 'identity'){\n  message('used for showing the spatial map for parameters like precipitation.\n  different method are provided for analysing the parameters\n  catchment needs shape file\n  points needs data.frame, with colume \"name, lon, lat, z, value\" in data.frame()\n  method = NULL means no method calculated on the cell')\n  \n  #range of the dataset just loaded \n  lon <- dataset$xyCoords$x\n  lat <- dataset$xyCoords$y\n  startTime <- as.POSIXlt(dataset$Dates$start,tz = 'GMT')\n  yearIndex <- startTime$year + 1900\n  monthIndex <-startTime$mon + 1\n  data <- dataset$Data\n  \n  if (is.null(method)){\n    #in case the dataset is ready to plot and no need to calculate\n  }else if(method == 'meanAnnual'){\n    #mean value of the annual precipitation over the period of the data \n    #time <- proc.time()\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex,  method = 'meanAnnualPreci')\n    #newTime <- proc.time() - time\n    title  <- 'Mean Annual Precipitation (mm / year)'\n    \n  }else if(method == 'winter'){\n    #mean value of the seasonal precipitation, in this case, winter\n    \n    #time <- proc.time()\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'winter')\n    #newTime <- proc.time() - time\n    title <- 'Mean Winter Precipitation (mm / winter)'\n    \n  }else if(method == 'spring'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'spring')\n   \n    title <- 'Mean Spring Precipitation (mm / spring)'\n    \n  }else if (method == 'summer'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'summer')\n    \n    title <- 'Mean Summer Precipitation (mm / summer)'\n    \n  }else if (method == 'autumn'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex, \n                      method = 'autumn')\n    \n    title <- 'Mean Autumn Precipitation (mm / autumn)'\n    \n  }else if(method == 'mean'){\n    #sum value of the dataset, this procedure is to get the mean value\n    data_new <- apply(data, MARGIN = c(2,3), FUN = mean)  \n  }else if(method == 'max'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = max)   \n  }else if(method == 'min'){\n    data_new <- apply(data, MARGIN = c(2,3), FUN = min)\n  }else{\n    wrongMethod <- method\n    stop (paste('no method called',wrongMethod))\n  }\n  \n\n  zlim <- NULL\n  if(method == 'winter'| method == 'spring' | method == 'autumn'| method == 'summer') zlim = c(0,730)\n   \n  plotMax <- round(max(data_new,na.rm=TRUE),2)\n  plotMin <- round(min(data_new,na.rm=TRUE),2)\n  plotMean <- round(mean(data_new,na.rm=TRUE),2)\n  plotMedian <- round(median(data_new,na.rm=T),2)\n  word <- paste(paste('Max',' = ',plotMax),'\\n',paste('Min',' = ',plotMin),'\\n',\n                paste('Mean',' = ',plotMean),'\\n',paste('Median',' = ',plotMedian))\n  \n  #set names for the matrix, in order to be better converted later in ggplot.\n  colnames(data_new) <- round(lon,2)\n  rownames(data_new) <- round(lat,2)\n  \n  world_map <- ggplot2::map_data('world')\n  \n  \n  #ggplot\n  #for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function\n  #get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use \n  #data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available \n  #in the environment.\n  #in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them\n  #outside aes() as normal parameters.\n  \n  data_ggplot <- melt(data_new,na.rm = T)\n  colnames(data_ggplot) <- c('lat','lon','value')\n  theme_set(theme_bw())\n  mainLayer <- ggplot(data = data_ggplot)+ \n    geom_tile(aes(x=lon,y=lat,fill = value))+\n    scale_fill_gradientn(colours = c('yellow','orange','red'),\n                         na.value='transparent',trans=plotScale)+#usually scale = 'sqrt'\n    geom_map(data = world_map,map=world_map,aes(map_id=region),fill='transparent',color='black')+\n    guides(fill=guide_colorbar(title='Rainfall (mm)',barheight = 10))+\n    xlab('Longitude')+\n    ylab('Latitude')+\n    ggtitle(title)+\n    theme(plot.title=element_text(size=20,face='bold'),\n          axis.title.x=element_text(size = 18),\n          axis.title.y = element_text(size = 18))+\n#     geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),\n#               xmax=min(lon)+0.99*(max(lon)-min(lon)),\n#               ymin=min(lat)+0.02*(max(lat)-min(lat)),\n#               ymax=min(lat)+0.28*(max(lat)-min(lat)),\n#               fill='white',colour='black')+\n    annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)\n        \n  printLayer <- mainLayer\n  \n  #catchment conversion\n  if(is.null(catchment) == FALSE){\n    a <- catchment\n    a@data$id <- rownames(a@data)\n    b <- fortify(a,region='id')\n    c <- join(b,a@data,by='id')\n    catchmentLayer <- geom_polygon(data=c,aes(long,lat,group=group),color='black',fill='transparent')\n    \n    printLayer <- printLayer + catchmentLayer\n  }\n  \n  if(is.null(points) == FALSE){\n    pointLayer <- geom_point(data = points,aes(x = lon, y = lat, size = value, colour = z))\n    \n    printLayer <- printLayer + pointLayer\n  }\n  \n  print (printLayer)\n  \n  if(outputData == TRUE) return(data_new)\n}\n\n\n\ngetSpatialRange <- function(filePath){\n  #getting range of longitude and latitude of the reasearch area\n  \n  lonRange <- downscaleR::dataInventory(filePath)$pr$Dimensions$lon$Values\n  latRange <- downscaleR::dataInventory(filePath)$pr$Dimensions$lat$Values\n  \n  x1 <- head(lonRange,1)\n  x2 <- tail(lonRange,1)\n  y1 <- head(latRange,1)\n  y2 <- tail(latRange,1)\n  \n  return (c(x1,x2,y1,y2))\n  \n}\n\n\n\n\n\ngetPreciBar <- function(dataset, method, outputData = T, plotRange = T){\n  \n  data <- dataset$Data\n  startTime <- as.POSIXlt(dataset$Dates$start,tz = 'GMT')\n  yearIndex <- startTime$year + 1900\n  monthIndex <-startTime$mon + 1\n  TS <- apply(data, MARGIN = 1,FUN = mean, na.rm = TRUE) \n  \n  \n  if (method == 'meanMonthly'){\n    \n    monthlypreci <- tapply(TS, INDEX = list(yearIndex,monthIndex),FUN = sum,na.rm = TRUE)\n    meanMonthlyPreci <- apply(monthlypreci, MARGIN = 2, FUN = mean, na.rm=TRUE)\n\n    title <- 'Mean Monthly Precipitation'\n    xlab <- 'Month'\n    \n    plotPreci <- data.frame(index=month.abb[1:12],preci=meanMonthlyPreci)\n    plotPreci$index <- factor(plotPreci$index,levels=plotPreci$index,ordered=T)\n    \n    if(plotRange){\n      maxValue <- apply(monthlypreci, MARGIN = 2, FUN = max, na.rm=TRUE)\n      minValue <- apply(monthlypreci, MARGIN = 2, FUN = min, na.rm=TRUE)\n      \n      plotPreci$maxValue <- maxValue\n      plotPreci$minValue <- minValue\n      \n      ylim <- c(0,max(maxValue,na.rm=TRUE)*1.1)\n      \n    }else{\n      ylim <- c(0,max(meanMonthlyPreci,na.rm=TRUE)*1.1)\n    }\n    \n    \n  }else if (method == 'annual'){\n    annualPreci <- tapply(TS, INDEX = yearIndex, FUN = sum, na.rm = TRUE)\n    title <- 'Annual Precipitation'\n    xlab <- 'Year'\n    plotName <- names(annualPreci)\n    \n    plotPreci <- data.frame(index=names(annualPreci),preci=annualPreci)\n    plotPreci$index <- factor(plotPreci$index,levels=plotPreci$index,ordered=T)\n    \n    ylim <- c(0,max(annualPreci,na.rm=TRUE)*1.1)\n    \n  }else if (is.numeric(method)){\n    month <- method\n    monthlyPreci <- tapply(TS, INDEX = list(yearIndex,monthIndex),FUN = sum)[,month]\n\n    plotPreci <- data.frame(index=names(monthlyPreci),preci=monthlyPreci)\n    plotPreci$index <- factor(plotPreci$index,levels=plotPreci$index,ordered=T)\n    \n    title <- paste(month.abb[month],'Precipitation over Whole Period',sep = ' ')\n    xlab <- 'Year'\n    ylim <- c(0,max(monthlyPreci,na.rm=TRUE)*1.1)\n    \n  }\n    \n  \n  xlim <- c(0,length(rownames(plotPreci))) \n  meanValue <- round(mean(plotPreci$preci, na.rm =TRUE),2)\n  medianValue <- round(median(plotPreci$preci,na.rm=T),2)\n  plotMean <- paste('Mean',' = ',meanValue)\n  plotMedian <- paste('Median',' = ',medianValue)\n  \n  plotMax <- round(max(plotPreci$preci,na.rm=TRUE),2)\n  plotMin <- round(min(plotPreci$preci,na.rm=TRUE),2)\n  word <- paste(paste(' Max',' = ',plotMax),'\\n',paste('Min',' = ',plotMin))\n  \n  \n  \n  \n  mainLayer <- ggplot(plotPreci)+\n    geom_bar(aes(x=index,y=preci),stat='identity',colour='black',fill='lightblue',width=.6)+\n    xlab(xlab)+\n    ylab('Precipitation (mm)')+\n    ggtitle(title)+\n    theme(plot.title=element_text(size=20,face='bold'),\n          axis.title.x=element_text(size = 18),\n          axis.title.y = element_text(size = 18))+\n    geom_text(x=min(xlim)+0.95*(max(xlim)-min(xlim)),y=min(ylim)+0.15*(max(ylim)-min(ylim)),label=word)+\n    geom_hline(yintercept=meanValue)+\n    geom_text(x=min(xlim)+0.3*(max(xlim)-min(xlim)),y=meanValue+3,label=plotMean)+\n    geom_hline(yintercept=medianValue,colour='red')+\n    geom_text(x=min(xlim)+0.6*(max(xlim)-min(xlim)),y=medianValue+3,label=plotMedian,colour='red')\n    \n  \n  if(plotRange){\n    if(is.null(plotPreci$maxValue)){\n      stop ('There is no plotRange for this method, set it as False')\n    }else{\n      rangeLayer <- geom_errorbar(aes(x = index,ymax=maxValue,ymin=minValue),width=0.3)\n      print(mainLayer+rangeLayer)\n    }\n    \n  }else{\n    print(mainLayer)\n  } \n  \n  if (outputData == TRUE) return(plotPreci)\n}\n\n\n\n\n#This function is an important function in getSpatialMap(), get mean value for each cell\n#In addition, it can generate time series of mean values, if fullResults == TRUE, all the results will be output\ngetMeanPreci <- function(inputTS, method = NULL, yearIndex = NULL, monthIndex = NULL,\n                         fullResults = FALSE){\n  #converting daily preci to the wanted preci.\n\n  if(method == 'meanAnnualPreci'){\n    ###yearIndex <- startTime$year + 1900\n    annualPreci <- tapply(inputTS,INDEX = yearIndex,FUN = sum, na.rm = FALSE)#here is used in map, so NA not removed\n    if(fullResults == TRUE) output <- annualPreci else output <- mean(annualPreci)\n    \n  }else if(method == 'winter'){\n    #winter is the most tricky part, because it starts from Dec to Feb next year, it's a year-crossing season,\n    #so we have to make some changes to the monthIndex\n    #e.g.data from 1950.1.1 - 2008.3.31 if we want to calculate the mean winter preci, to calculate winter month\n    #December, we have to move the yearIndex one month forwards or two months backwards, to make 12,1,2 in one year      \n    ###yearIndex <- startTime$year + 1900\n    ###monthIndex <- startTime$mon + 1\n    \n    #we move the yearIndex one month backwards\n    yearIndex_new <- c(yearIndex[32:length(yearIndex)],rep(tail(yearIndex,1),31))\n    \n    winterIndex <- which(monthIndex == 12 | monthIndex == 1 | monthIndex == 2)\n    winterYear <- yearIndex_new[winterIndex]#this index is used for calculation\n    \n    #because we don't have 1949.Dec, so the first winter is not intact, so first two months are elemenated\n    \n    startIndex <- length(which(winterYear == yearIndex[1])) + 1\n    winterOfLastYear <- length(which(winterYear == tail(yearIndex,1)))\n    if (winterOfLastYear > 91) {\n      endIndex <- length(winterYear) - 31 #in case the data set ends at Dec.31\n    }else if (winterOfLastYear < 90){ # incase the data ends at Jan 31\n      endIndex <- length(winterYear) - length(which(winterYear == tail(yearIndex,1)))\n    }else{\n      endIndex <- length(winterYear)\n    }\n    \n    inputTS <- inputTS[winterIndex][startIndex:endIndex]#needs two process with inputPreci, first, extract\n    #the winter preci, second, delete first two month of 1950\n    \n    winterYear <- winterYear[startIndex:endIndex]#needs one process, delete two months\n    \n    seasonalPreci <- tapply(inputTS,INDEX = winterYear, FUN = sum, na.rm = FALSE)\n    if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)  \n    \n  }else if (method == 'spring'){\n    springIndex <- which(monthIndex == 3 | monthIndex == 4 | monthIndex == 5)\n    springYear <- yearIndex[springIndex]\n    inputTS <- inputTS[springIndex]\n    seasonalPreci <- tapply(inputTS, INDEX = springYear, FUN = sum, na.rm = FALSE)\n    if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)\n    \n  }else if (method == 'summer'){\n    summerIndex <- which(monthIndex == 6 | monthIndex == 7 | monthIndex == 8)\n    summerYear <- yearIndex[summerIndex]\n    inputTS <- inputTS[summerIndex]\n    seasonalPreci <- tapply(inputTS, INDEX = summerYear, FUN = sum, na.rm = FALSE)\n    if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)\n    \n  }else if (method == 'autumn'){\n    autumnIndex <- which(monthIndex == 9 | monthIndex == 10 | monthIndex == 11)\n    autumnYear <- yearIndex[autumnIndex]\n    inputTS <- inputTS[autumnIndex]\n    seasonalPreci <- tapply(inputTS, INDEX = autumnYear, FUN = sum, na.rm = FALSE)\n    if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)\n  }\n   \n  return (output)\n}\n\n\n\n\n\n\n\n\n",
    "created" : 1433330334970.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3704833405",
    "id" : "12D7DBD6",
    "lastKnownWriteTime" : 1434027193,
    "path" : "C:/DHI_Projects/11811405/Seasonal_Forecasting/R/Data_Analysis/Main.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "type" : "r_source"
}