aaa <- biasCorrect(frc, hindcast, obs)
debug(biasCorrect)
aaa <- biasCorrect(frc, hindcast, obs)
as.POSIXlt(hindcast[, 1]) != as.POSIXlt(obs[, 1])
hindcast[, 1] != obs[, 1]
as.POSIXlt(hindcast[, 1]) != as.POSIXlt(obs[, 1])
as.POSIXlt(hindcast[, 1]) != as.POSIXlt(obs[, 1])
aaa <- biasCorrect(frc, hindcast, obs)
hindcast[, 1] != obs[, 1]
as.POSIXlt(hindcast[, 1]) != as.POSIXlt(obs[, 1])
obs
obs[, 2]
#' Biascorrect the input timeseries or hyfo dataset
#'
#' Biascorrect the input time series or dataset, the input time series or dataset should consist of observation, hindcast, and forecast.
#' observation and hindcast should belong to the same period, in order to calibrate. Then the modified forecast
#' will be returned. If the input is a time series, first column should be date column and rest columns should be
#' the value column. If the input is a hyfo dataset, the dataset should be the result of \code{loadNcdf}, or a list
#' file with the same format.
#'
#' @param frc a hyfo grid data output or a dataframe (time series) consists of Date column and one or more value columns,
#' representing the forecast to be calibrated.
#' @param hindcast a hyfo grid data output or a dataframe(time series) consists of Date column and one or more value columns,
#' representing the hindcast data. This data will be used in the calibration of the forecast, so it's better to have the same date period as
#' observation data. Check details for more information.
#' @param obs a hyfo grid data output or a dataframe (time series) consists of Date column and one or more value columns,
#' representing the observation data.
#' @param method bias correct method, including 'delta', 'scaling'...
#' @param scaleType only when the method "scaling" is chosen, scaleType will be available. Two different types
#' of scaling method, 'add' and 'mult', which means additive and multiplicative scaling method. More info check
#' details.
#' @param input If input is a time series, \code{input = 'TS'} needs to be assigned, or hyfo will take it as
#' an hyfo output grid file. Default is time series input, where in most of the cases we prefer. If your input
#' is a hyfo output file, \code{input = 'hyfo'}.
#' @param preci If the precipitation is biascorrected, then you have to assign \code{preci = TRUE}. Since for
#' precipitation, some biascorrect methods may not apply to, or some methods are specially for precipitation.
#' Default is FALSE.
#' @details
#'
#' \strong {Hindcast}
#'
#' Since climate forecast is based on global condition, when downscaling to different regions, it may include
#' some bias, biascorrection is used then to fix the bias. In order to bias correct, we need to pick up some
#' data from the forecast to train with the observation, which is called hindcast in this function. Hindcast
#' should have \strong{EVERY} attributes that forecast has.
#'
#' Hindcast is also called re-forecast, is the forecast of the past. E.g. you have a forecast from year 2000-2010, assuming now you are in 2005. So from 2000-2005, this period
#' is the hindcast period, and 2005-2010, this period is the forecast period.
#'
#'
#' \strong {How it works}
#'
#' Forecast product has to be calibrated, usually the system is doing forecast in real time. So, e.g., if the
#' forecast starts from year 2000, assuming you are in year 2003, then you will have 3 years' hindcast
#' data (year 2000 - 2003), which can be used to calibrate. And your forecast period is (2003-2004)
#'
#' E.g. you have observation from 2001 - 2002, this is your input obs. Then you can take the same
#' period (2001-2002) from the forecast, which is the hindcast period. For forecast, you can take any period.
#' The program will evaluate the obs and hindcast, to get the modification of the forecast, and then add the
#' modification to the forecast data.
#'
#' \strong {method}
#'
#' Different methods used in the bias correction.
#'
#' \strong {delta}
#' This method consists on adding to the observations the mean change signal (delta method).
#' This method is applicable to any kind of variable but it is preferable to avoid it for bounded variables
#'  (e.g. precipitation, wind speed, etc.) because values out of the variable range could be obtained
#'  (e.g. negative wind speeds...)
#'
#'
#'
#' @references
#' Bias correction methods come from \code{biasCorrection} from \code{dowscaleR}
#' Santander Meteorology Group (2015). downscaleR: Climate data manipulation and statistical downscaling. R
#' package version 0.6-0. https://github.com/SantanderMetGroup/downscaleR/wiki
#' @export
biasCorrect <- function(frc, hindcast, obs, method = 'delta', scaleType = 'multi', input = 'TS', preci = FALSE){
if (input == 'TS') {
# First check if the first column is Date
if (!grepl('-|/', obs[1, 1]) | !grepl('-|/', hindcast[1, 1]) | !grepl('-|/', frc[1, 1])) {
stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base}
and use as.Date to convert.If your input is a hyfo dataset, put input = "hyfo" as an
argument, check help for more info.')
}
# change to date type is easier, but in case in future the flood part is added, Date type doesn't have
# hour, min and sec, so, it's better to convert it into POSIxlt.
if (as.POSIXlt(hindcast[, 1]) != as.POSIXlt(obs[, 1])) {
warning('time of obs and time of hindcast are not the same, which may cause inaccuracy in
the calibration.')
}
if (ncol(frc) == 2) {
frc_data <- biasCorrect_core(frc[, 2], hindcast[, 2], obs[, 2], method = method,
scaleType = scaleType, preci = preci)
} else if (ncol(frc) > 2) {
# In this case more than one value columns exist in the dataset, both frc and hindcast.
n <- ncol(frc)
# For every column, it's biascorrected respectively.
frc_data <- lapply(2:n, function(x) biasCorrect_core(frc[, x], hindcast[, x], obs[, 2], method = method,
scaleType = scaleType, preci = preci))
frc_data <- do.call('cbind', frc_data)
} else stop('Wrong TS input, check your TS dimension.')
} else if (input == 'hyfo') {
print('Under development...')
}
names <- colnames(frc)
frc <- data.frame(frc[, 1], frc_data)
colnames(frc) <- names
return(frc)
}
# this is only used to calculate the value column,
biasCorrect_core <- function(frc, hindcast, obs, method = 'delta', scaleType = 'multi', preci = FALSE){
# default is the simplest method in biascorrection, just do simple addition and subtraction.
if (method == 'delta') {
# comes from downscaleR biascorrection method
frcMean <- mean(obs, na.rm = TRUE)
hindcastMean <- mean(hindcast, na.rm = TRUE)
frc <- obs - hindcastMean + frcMean
} else if (method == 'scaling') {
obsMean <- mean(obs, na.rm = TRUE)
hindcastMean <- mean(hindcast, na.rm = TRUE)
if (scaleType == 'multi') {
frc <- frc / hindcastMean * obsMean
} else if (scaleType == 'add') {
frc <- frc - hindcastMean + obsMean
}
} else if (method == 'eqm') {
# To be added, right now too complicated and not so much use.
}
return(frc)
}
aaa <- biasCorrect(frc, hindcast, obs)
aaa
aaa1 <- biasCorrect(frc, hindcast, obs, method = 'scaling', scaleType = 'multi')
aaa1
aaa1 == aaa
aaa1 <- biasCorrect(frc, hindcast, obs, method = 'scaling', scaleType = 'multi')
debug(biasCorrect)
aaa1 <- biasCorrect(frc, hindcast, obs, method = 'scaling', scaleType = 'multi')
as.POSIXlt(hindcast[, 1]) - as.POSIXlt(obs[, 1])
typeof(as.POSIXlt(hindcast[, 1]))
typeof(as.POSIXlt(hindcast[1, 1]))
str(as.POSIXlt(hindcast[1, 1]))
str(as.Date(hindcast[1, 1]))
as.POSIXlt(hindcast[, 1]) != as.POSIXlt(obs[, 1])
str(as.Date(hindcast[1, 1]))
str(as.Date(hindcast[1, 1]))
as.POSIXlt(hindcast[, 1]) == as.POSIXlt(obs[, 1])
!(as.POSIXlt(hindcast[, 1]) == as.POSIXlt(obs[, 1]))
#' Biascorrect the input timeseries or hyfo dataset
#'
#' Biascorrect the input time series or dataset, the input time series or dataset should consist of observation, hindcast, and forecast.
#' observation and hindcast should belong to the same period, in order to calibrate. Then the modified forecast
#' will be returned. If the input is a time series, first column should be date column and rest columns should be
#' the value column. If the input is a hyfo dataset, the dataset should be the result of \code{loadNcdf}, or a list
#' file with the same format.
#'
#' @param frc a hyfo grid data output or a dataframe (time series) consists of Date column and one or more value columns,
#' representing the forecast to be calibrated.
#' @param hindcast a hyfo grid data output or a dataframe(time series) consists of Date column and one or more value columns,
#' representing the hindcast data. This data will be used in the calibration of the forecast, so it's better to have the same date period as
#' observation data. Check details for more information.
#' @param obs a hyfo grid data output or a dataframe (time series) consists of Date column and one or more value columns,
#' representing the observation data.
#' @param method bias correct method, including 'delta', 'scaling'...
#' @param scaleType only when the method "scaling" is chosen, scaleType will be available. Two different types
#' of scaling method, 'add' and 'mult', which means additive and multiplicative scaling method. More info check
#' details.
#' @param input If input is a time series, \code{input = 'TS'} needs to be assigned, or hyfo will take it as
#' an hyfo output grid file. Default is time series input, where in most of the cases we prefer. If your input
#' is a hyfo output file, \code{input = 'hyfo'}.
#' @param preci If the precipitation is biascorrected, then you have to assign \code{preci = TRUE}. Since for
#' precipitation, some biascorrect methods may not apply to, or some methods are specially for precipitation.
#' Default is FALSE.
#' @details
#'
#' \strong {Hindcast}
#'
#' Since climate forecast is based on global condition, when downscaling to different regions, it may include
#' some bias, biascorrection is used then to fix the bias. In order to bias correct, we need to pick up some
#' data from the forecast to train with the observation, which is called hindcast in this function. Hindcast
#' should have \strong{EVERY} attributes that forecast has.
#'
#' Hindcast is also called re-forecast, is the forecast of the past. E.g. you have a forecast from year 2000-2010, assuming now you are in 2005. So from 2000-2005, this period
#' is the hindcast period, and 2005-2010, this period is the forecast period.
#'
#'
#' \strong {How it works}
#'
#' Forecast product has to be calibrated, usually the system is doing forecast in real time. So, e.g., if the
#' forecast starts from year 2000, assuming you are in year 2003, then you will have 3 years' hindcast
#' data (year 2000 - 2003), which can be used to calibrate. And your forecast period is (2003-2004)
#'
#' E.g. you have observation from 2001 - 2002, this is your input obs. Then you can take the same
#' period (2001-2002) from the forecast, which is the hindcast period. For forecast, you can take any period.
#' The program will evaluate the obs and hindcast, to get the modification of the forecast, and then add the
#' modification to the forecast data.
#'
#' \strong {method}
#'
#' Different methods used in the bias correction.
#'
#' \strong {delta}
#' This method consists on adding to the observations the mean change signal (delta method).
#' This method is applicable to any kind of variable but it is preferable to avoid it for bounded variables
#'  (e.g. precipitation, wind speed, etc.) because values out of the variable range could be obtained
#'  (e.g. negative wind speeds...)
#'
#'
#'
#' @references
#' Bias correction methods come from \code{biasCorrection} from \code{dowscaleR}
#' Santander Meteorology Group (2015). downscaleR: Climate data manipulation and statistical downscaling. R
#' package version 0.6-0. https://github.com/SantanderMetGroup/downscaleR/wiki
#' @export
biasCorrect <- function(frc, hindcast, obs, method = 'delta', scaleType = 'multi', input = 'TS', preci = FALSE){
if (input == 'TS') {
# First check if the first column is Date
if (!grepl('-|/', obs[1, 1]) | !grepl('-|/', hindcast[1, 1]) | !grepl('-|/', frc[1, 1])) {
stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base}
and use as.Date to convert.If your input is a hyfo dataset, put input = "hyfo" as an
argument, check help for more info.')
}
# change to date type is easier, but in case in future the flood part is added, Date type doesn't have
# hour, min and sec, so, it's better to convert it into POSIxlt.
if (! (as.POSIXlt(hindcast[, 1]) == as.POSIXlt(obs[, 1]))) {
warning('time of obs and time of hindcast are not the same, which may cause inaccuracy in
the calibration.')
}
if (ncol(frc) == 2) {
frc_data <- biasCorrect_core(frc[, 2], hindcast[, 2], obs[, 2], method = method,
scaleType = scaleType, preci = preci)
} else if (ncol(frc) > 2) {
# In this case more than one value columns exist in the dataset, both frc and hindcast.
n <- ncol(frc)
# For every column, it's biascorrected respectively.
frc_data <- lapply(2:n, function(x) biasCorrect_core(frc[, x], hindcast[, x], obs[, 2], method = method,
scaleType = scaleType, preci = preci))
frc_data <- do.call('cbind', frc_data)
} else stop('Wrong TS input, check your TS dimension.')
} else if (input == 'hyfo') {
print('Under development...')
}
names <- colnames(frc)
frc <- data.frame(frc[, 1], frc_data)
colnames(frc) <- names
return(frc)
}
# this is only used to calculate the value column,
biasCorrect_core <- function(frc, hindcast, obs, method = 'delta', scaleType = 'multi', preci = FALSE){
# default is the simplest method in biascorrection, just do simple addition and subtraction.
if (method == 'delta') {
# comes from downscaleR biascorrection method
frcMean <- mean(obs, na.rm = TRUE)
hindcastMean <- mean(hindcast, na.rm = TRUE)
frc <- obs - hindcastMean + frcMean
} else if (method == 'scaling') {
obsMean <- mean(obs, na.rm = TRUE)
hindcastMean <- mean(hindcast, na.rm = TRUE)
if (scaleType == 'multi') {
frc <- frc / hindcastMean * obsMean
} else if (scaleType == 'add') {
frc <- frc - hindcastMean + obsMean
}
} else if (method == 'eqm') {
# To be added, right now too complicated and not so much use.
}
return(frc)
}
debug(biasCorrect)
aaa1 <- biasCorrect(frc, hindcast, obs, method = 'scaling', scaleType = 'multi')
obsMean
#' Biascorrect the input timeseries or hyfo dataset
#'
#' Biascorrect the input time series or dataset, the input time series or dataset should consist of observation, hindcast, and forecast.
#' observation and hindcast should belong to the same period, in order to calibrate. Then the modified forecast
#' will be returned. If the input is a time series, first column should be date column and rest columns should be
#' the value column. If the input is a hyfo dataset, the dataset should be the result of \code{loadNcdf}, or a list
#' file with the same format.
#'
#' @param frc a hyfo grid data output or a dataframe (time series) consists of Date column and one or more value columns,
#' representing the forecast to be calibrated.
#' @param hindcast a hyfo grid data output or a dataframe(time series) consists of Date column and one or more value columns,
#' representing the hindcast data. This data will be used in the calibration of the forecast, so it's better to have the same date period as
#' observation data. Check details for more information.
#' @param obs a hyfo grid data output or a dataframe (time series) consists of Date column and one or more value columns,
#' representing the observation data.
#' @param method bias correct method, including 'delta', 'scaling'...
#' @param scaleType only when the method "scaling" is chosen, scaleType will be available. Two different types
#' of scaling method, 'add' and 'mult', which means additive and multiplicative scaling method. More info check
#' details.
#' @param input If input is a time series, \code{input = 'TS'} needs to be assigned, or hyfo will take it as
#' an hyfo output grid file. Default is time series input, where in most of the cases we prefer. If your input
#' is a hyfo output file, \code{input = 'hyfo'}.
#' @param preci If the precipitation is biascorrected, then you have to assign \code{preci = TRUE}. Since for
#' precipitation, some biascorrect methods may not apply to, or some methods are specially for precipitation.
#' Default is FALSE.
#' @details
#'
#' \strong {Hindcast}
#'
#' Since climate forecast is based on global condition, when downscaling to different regions, it may include
#' some bias, biascorrection is used then to fix the bias. In order to bias correct, we need to pick up some
#' data from the forecast to train with the observation, which is called hindcast in this function. Hindcast
#' should have \strong{EVERY} attributes that forecast has.
#'
#' Hindcast is also called re-forecast, is the forecast of the past. E.g. you have a forecast from year 2000-2010, assuming now you are in 2005. So from 2000-2005, this period
#' is the hindcast period, and 2005-2010, this period is the forecast period.
#'
#'
#' \strong {How it works}
#'
#' Forecast product has to be calibrated, usually the system is doing forecast in real time. So, e.g., if the
#' forecast starts from year 2000, assuming you are in year 2003, then you will have 3 years' hindcast
#' data (year 2000 - 2003), which can be used to calibrate. And your forecast period is (2003-2004)
#'
#' E.g. you have observation from 2001 - 2002, this is your input obs. Then you can take the same
#' period (2001-2002) from the forecast, which is the hindcast period. For forecast, you can take any period.
#' The program will evaluate the obs and hindcast, to get the modification of the forecast, and then add the
#' modification to the forecast data.
#'
#' \strong {method}
#'
#' Different methods used in the bias correction.
#'
#' \strong {delta}
#' This method consists on adding to the observations the mean change signal (delta method).
#' This method is applicable to any kind of variable but it is preferable to avoid it for bounded variables
#'  (e.g. precipitation, wind speed, etc.) because values out of the variable range could be obtained
#'  (e.g. negative wind speeds...)
#'
#'
#'
#' @references
#' Bias correction methods come from \code{biasCorrection} from \code{dowscaleR}
#' Santander Meteorology Group (2015). downscaleR: Climate data manipulation and statistical downscaling. R
#' package version 0.6-0. https://github.com/SantanderMetGroup/downscaleR/wiki
#' @export
biasCorrect <- function(frc, hindcast, obs, method = 'delta', scaleType = 'multi', input = 'TS', preci = FALSE){
if (input == 'TS') {
# First check if the first column is Date
if (!grepl('-|/', obs[1, 1]) | !grepl('-|/', hindcast[1, 1]) | !grepl('-|/', frc[1, 1])) {
stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base}
and use as.Date to convert.If your input is a hyfo dataset, put input = "hyfo" as an
argument, check help for more info.')
}
# change to date type is easier, but in case in future the flood part is added, Date type doesn't have
# hour, min and sec, so, it's better to convert it into POSIxlt.
# if condition only accepts one condition, for list comparison, there are a lot of conditions, better
# further process it, like using any.
if (any(as.POSIXlt(hindcast[, 1]) != as.POSIXlt(obs[, 1]))) {
warning('time of obs and time of hindcast are not the same, which may cause inaccuracy in
the calibration.')
}
if (ncol(frc) == 2) {
frc_data <- biasCorrect_core(frc[, 2], hindcast[, 2], obs[, 2], method = method,
scaleType = scaleType, preci = preci)
} else if (ncol(frc) > 2) {
# In this case more than one value columns exist in the dataset, both frc and hindcast.
n <- ncol(frc)
# For every column, it's biascorrected respectively.
frc_data <- lapply(2:n, function(x) biasCorrect_core(frc[, x], hindcast[, x], obs[, 2], method = method,
scaleType = scaleType, preci = preci))
frc_data <- do.call('cbind', frc_data)
} else stop('Wrong TS input, check your TS dimension.')
} else if (input == 'hyfo') {
print('Under development...')
}
names <- colnames(frc)
frc <- data.frame(frc[, 1], frc_data)
colnames(frc) <- names
return(frc)
}
# this is only used to calculate the value column,
biasCorrect_core <- function(frc, hindcast, obs, method = 'delta', scaleType = 'multi', preci = FALSE){
# default is the simplest method in biascorrection, just do simple addition and subtraction.
if (method == 'delta') {
# comes from downscaleR biascorrection method
frcMean <- mean(obs, na.rm = TRUE)
hindcastMean <- mean(hindcast, na.rm = TRUE)
frc <- obs - hindcastMean + frcMean
} else if (method == 'scaling') {
obsMean <- mean(obs, na.rm = TRUE)
hindcastMean <- mean(hindcast, na.rm = TRUE)
if (scaleType == 'multi') {
frc <- frc / hindcastMean * obsMean
} else if (scaleType == 'add') {
frc <- frc - hindcastMean + obsMean
}
} else if (method == 'eqm') {
# To be added, right now too complicated and not so much use.
}
return(frc)
}
aaa1 <- biasCorrect(frc, hindcast, obs, method = 'scaling', scaleType = 'multi')
debug(biasCorrect)
aaa1 <- biasCorrect(frc, hindcast, obs, method = 'scaling', scaleType = 'multi')
aaa1 <- biasCorrect(frc, hindcast, obs, method = 'scaling', scaleType = 'multi')
obsMean
hindcastMean
frc
frc1 <- frc / hindcastMean * obsMean
frc1
frc1 - frc
frc1/obsMean
frc1/obsMean * hindcastMean
frc
frc1/obsMean * hindcastMean == frc
frc
frc * 3
frc * 100
frc * 100 /5
frc
frc1
obsMean
hindcastMean
obs / hindcastMean
frc1
frc
0.09 * 0.108
0.093 * 0.108
frc1
frc[35]
frc[35] /hindcastMean * obsMean
frc1[35]
frc1
q
devtools::document()
?extractPeriod
data(testdl)
datalist <- extractPeriod(testdl, startDate = '1994-1-1', endDate = '1995-10-1')
frc <- datalist[[1]]
hindcast <- datalist[[2]]
obs <- datalist[[3]]
# default method is delta
frc_new <- biasCorrect(frc, hindcast, obs)
undebug(biasCorrect)
frc_new
frc_new <- biasCorrect(frc, hindcast, obs, method = 'scaling', scaleType = 'multi')
frc_new
devtools::build()
?biasCorrection
??biasCorrection
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::build()
devtools::build()
install.packages("~/hyfo_1.1.7.tar.gz", repos = NULL, type = "source")
?biasCorrection
library(hyfo)
?biasCorrection
?biasCorrect
devtools::document()
devtools::build()
install.packages("~/hyfo_1.1.7.tar.gz", repos = NULL, type = "source")
library(hyfo)
?biasCorrect
datalist <- extractPeriod(testdl, startDate = '1994-1-1', endDate = '1995-10-1')
frc <- datalist[[1]]
hindcast <- datalist[[2]]
obs <- datalist[[3]]
frc_new <- biasCorrect(frc, hindcast, obs)
frc_new
frc_new <- biasCorrect(frc, hindcast, obs, method = 'scaling', scaleType = 'multi')
frc_new
?getFrcEnsem
filePath <- system.file("extdata", "tnc.nc", package = "hyfo")
varname <- getNcdfVar(filePath)
nc <- loadNcdf(filePath, varname)
a <- getFrcEnsem(nc)
a1 <- getFrcEnsem(tgridData)
a <- getFrcEnsem(nc, cell = c(6,2))
b <- getFrcEnsem(nc, coord = c(-1.4, 43.2))
devtools::install_github('Yuanchao-Xu/hyfo')
devtools::install_github('Yuanchao-Xu/hyfo')
library(hyfo)
?biasCorrect
?layer
?structure
structure(1:6, dim = 2:3)
a <- structure(1:6, dim = 2:3)
attr(a)
attrs(a)
attributes(a)
a <- structure(1:6, dim = 2:3, dimnames(dalkf,dafda))
a <- structure(1:6, dim = 2:3, dimnames(1,2))
a <- structure(1:6, dim = 2:3, dimnames(1))
a <- structure(1:6, dim = 2:3, dimnames = 1: 3)
a <- structure(1:6, dim = 2:3, dimnames = c('dafa', 'dafda'))
?UseMethod()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::build()
install.packages("~/hyfo_1.1.8.tar.gz", repos = NULL, type = "source")
devtools::document()
devtools::check()
devtools::build()
install.packages("~/hyfo_1.1.9.tar.gz", repos = NULL, type = "source")
devtools::document()
devtools::check()
