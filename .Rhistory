name <- gridData$Variable$varName
# First defines dimensions.
dimLon <- dim.def.ncdf('lon', 'degree', gridData$xyCoords$x)
dimLat <- dim.def.ncdf('lat', 'degree', gridData$xyCoords$y)
dimMem <- NULL
if (!is.null(gridData$Members)) {
dimMem <- dim.def.ncdf('member', 'members', 1:length(gridData$Members))
}
# Time needs to be treated seperately
dates <- as.POSIXlt(gridData$Dates$start)
time <- difftime(dates, dates[1], units = 'days')
timeUnits <- paste('days since', dates[1])
dimTime <- dim.def.ncdf('time', timeUnits, time)
# Depending on whether there is a member part of the dataset.
dimList <- list(dimLon, dimLat, dimTime, dimMem)
# delete the NULL list, in order that there is no member part in the data.
dimList <- Filter(Negate(is.null), dimList)
# Then difines data
var <- var.def.ncdf( name, "units", dimList, 1e20 )
nc <- create.ncdf(filePath, var)
#   This part comes from the library downscaleR
#   att.put.ncdf(nc, "time", "standard_name","time")
#   att.put.ncdf(nc, "time", "axis","T")
#   att.put.ncdf(nc, "time", "_CoordinateAxisType","Time")
#   #att.put.ncdf(nc, "time", "_ChunkSize",1)
#   att.put.ncdf(nc, "lon", "standard_name","longitude")
#   att.put.ncdf(nc, "lon", "_CoordinateAxisType","Lon")
#   att.put.ncdf(nc, "lat", "standard_name","latitude")
#   att.put.ncdf(nc, "lat", "_CoordinateAxisType","Lat")
att.put.ncdf(nc, 0, "Conventions","CF-1.4")
dimIndex <- match(c('lon', 'lat', 'time', 'member'), attributes(gridData$Data)$dimensions)
dimIndex <- na.omit(dimIndex)
data <- aperm(gridData$Data, dimIndex)
put.var.ncdf(nc, name, data)
close.ncdf(nc)
}
#'@import ncdf
getExtralDim <- function(...) {
dimList <- list(...)
}
loadNcdf(filePath, 'pr')
#' Get variable name in the NetCDF file. After knowning the name, you can use \code{loadNcdf} to load
#' the target variable.
#'
#' @param filePath A path pointing to the netCDF file.
#' @return The names of the varialbes in the file.
#' @import ncdf
#' @export
getNcdfVar <- function(filePath) {
nc <- open.ncdf(filePath)
names <- names(nc$var)
return(names)
}
#' Load NetCDF file
#'
#' @param filePath A path pointing to the NetCDF file, version3.
#' @param varname A character representing the variable name, you can use \code{getNcdfVar} to
#' get the basic information about the variables and select the target.
#' @return A list object from \code{hyfo} containing the information to be used in the analysis,
#' or biascorrection.
#'
#' @export
#'@import ncdf
loadNcdf <- function(filePath, varname) {
nc <- open.ncdf(filePath)
var <- nc$var
# Use name to locate the variable
call_1 <- as.call(c(
list(as.name('$'), var, varname)
))
var <- eval(call_1)
if(is.null(var)) stop('No such variable name, check source file.')
# First needs to identify the variable name, load the right data
message('Loading data...')
nc_data <- get.var.ncdf(nc, var)
message('Processing...')
dimNames <- unlist(lapply(1:length(var$dim), function(x) var$dim[[x]]$name))
# Only deals with the most common dimensions, futher dimensions will be added in future.
dimIndex <- match(c('lon', 'lat', 'time', 'member'), dimNames)
gridData <- list()
gridData$Variable$varName <- varname
gridData$xyCoords$x <- var$dim[[dimIndex[1]]]$vals
gridData$xyCoords$y <- var$dim[[dimIndex[2]]]$vals
# Time part needs to be taken seperately
DateDiff <- var$dim[[dimIndex[3]]]$vals
# To get real time, time since when has to be grabbed from the dataset.
timeSince <- as.POSIXlt(strsplit(var$dim[[dimIndex[3]]]$units, split = 'since')[[1]][2])
Date <- rep(timeSince, length(DateDiff))
Date$mday <- Date$mday + DateDiff
gridData$Dates$start <- as.character(Date)
# Assing data to grid data
gridData$Data <- nc_data
attributes(gridData$Data)$dimensions <- dimNames
if (!is.na(dimIndex[4])) gridData$Members <- var$dim[[dimIndex[4]]]$vals
gridData$Source <- 'from hyfo package, http://yuanchao-xu.github.io/hyfo/'
return(gridData)
}
#' Write to NetCDF file using hyfo list file
#' @param gridData A hyfo list file or the list file from \code{loadECOMS{ecomsUDG.Raccess}}
#'  or \code{loadGridData{ecomsUDG.Raccess}}
#' @param filePath A path of the new NetCDF file, should end with ".nc"
#' @return An NetCDF version 3 file.
#' @export
#' @import ncdf
writeNcdf <- function(gridData, filePath) {
name <- gridData$Variable$varName
# First defines dimensions.
dimLon <- dim.def.ncdf('lon', 'degree', gridData$xyCoords$x)
dimLat <- dim.def.ncdf('lat', 'degree', gridData$xyCoords$y)
dimMem <- NULL
if (!is.null(gridData$Members)) {
dimMem <- dim.def.ncdf('member', 'members', 1:length(gridData$Members))
}
# Time needs to be treated seperately
dates <- as.POSIXlt(gridData$Dates$start)
time <- difftime(dates, dates[1], units = 'days')
timeUnits <- paste('days since', dates[1])
dimTime <- dim.def.ncdf('time', timeUnits, time)
# Depending on whether there is a member part of the dataset.
dimList <- list(dimLon, dimLat, dimTime, dimMem)
# delete the NULL list, in order that there is no member part in the data.
dimList <- Filter(Negate(is.null), dimList)
# Then difines data
var <- var.def.ncdf( name, "units", dimList, 1e20 )
nc <- create.ncdf(filePath, var)
#   This part comes from the library downscaleR
#   att.put.ncdf(nc, "time", "standard_name","time")
#   att.put.ncdf(nc, "time", "axis","T")
#   att.put.ncdf(nc, "time", "_CoordinateAxisType","Time")
#   #att.put.ncdf(nc, "time", "_ChunkSize",1)
#   att.put.ncdf(nc, "lon", "standard_name","longitude")
#   att.put.ncdf(nc, "lon", "_CoordinateAxisType","Lon")
#   att.put.ncdf(nc, "lat", "standard_name","latitude")
#   att.put.ncdf(nc, "lat", "_CoordinateAxisType","Lat")
att.put.ncdf(nc, 0, "Conventions","CF-1.4")
dimIndex <- match(c('lon', 'lat', 'time', 'member'), attributes(gridData$Data)$dimensions)
dimIndex <- na.omit(dimIndex)
data <- aperm(gridData$Data, dimIndex)
put.var.ncdf(nc, name, data)
close.ncdf(nc)
}
#'@import ncdf
getExtralDim <- function(...) {
dimList <- list(...)
}
loadNcdf(filePath, 'pr')
a <- loadNcdf(filePath, 'pr')
filePath
filePath <- file.choose()
writeNcdf(a, filePath)
b <- loadNcdf(filePath, 'pr')
str(b)
devtools::document()
devtools::check()
devtools::build()
filePath <- file.choose()
getNcdfVar(filePath)
#' Get variable name in the NetCDF file. After knowning the name, you can use \code{loadNcdf} to load
#' the target variable.
#'
#' @param filePath A path pointing to the netCDF file.
#' @return The names of the varialbes in the file.
#' @import ncdf
#' @export
getNcdfVar <- function(filePath) {
nc <- open.ncdf(filePath)
names <- names(nc$var)
return(names)
}
#' Load NetCDF file
#'
#' @param filePath A path pointing to the NetCDF file, version3.
#' @param varname A character representing the variable name, you can use \code{getNcdfVar} to
#' get the basic information about the variables and select the target.
#' @param tz A string representing the time zone, default is GMT, if you know what time zone is
#' you can assign it in the argument. If \code{tz = ''}, current time zone will be taken.
#' @return A list object from \code{hyfo} containing the information to be used in the analysis,
#' or biascorrection.
#'
#' @export
#'@import ncdf
loadNcdf <- function(filePath, varname, tz = 'GMT') {
nc <- open.ncdf(filePath)
var <- nc$var
# Use name to locate the variable
call_1 <- as.call(c(
list(as.name('$'), var, varname)
))
var <- eval(call_1)
if(is.null(var)) stop('No such variable name, check source file.')
# First needs to identify the variable name, load the right data
message('Loading data...')
nc_data <- get.var.ncdf(nc, var)
message('Processing...')
dimNames <- unlist(lapply(1:length(var$dim), function(x) var$dim[[x]]$name))
# Only deals with the most common dimensions, futher dimensions will be added in future.
dimIndex <- match(c('lon', 'lat', 'time', 'member'), dimNames)
gridData <- list()
gridData$Variable$varName <- varname
gridData$xyCoords$x <- var$dim[[dimIndex[1]]]$vals
gridData$xyCoords$y <- var$dim[[dimIndex[2]]]$vals
# Time part needs to be taken seperately
timeUnit <- strsplit(var$dim[[dimIndex[3]]]$units, split = ' since')[[1]][1]
timeDiff <- var$dim[[dimIndex[3]]]$vals
# To get real time, time since when has to be grabbed from the dataset.
timeSince <- as.POSIXlt(strsplit(var$dim[[dimIndex[3]]]$units, split = 'since')[[1]][2], tz = tz)
#  Date <- rep(timeSince, length(timeDiff))
unitDic <- data.frame(weeks = 'weeks', days = 'days', hours = 'hours',
minutes = 'mins', seconds = 'secs')
timeDiff <- as.difftime(timeDiff, units = as.character(unitDic[1, timeUnit]))
#   if (grepl('day', timeUnit)) {
#     Date$mday <- Date$mday + timeDiff
#   } else if (grepl('second', timeUnit)) {
#     Date$sec <- Date$sec + timeDiff
#   }
Date <- timeSince + timeDiff
if (length(Date) == 1) {
warning("Only one time step is taken, time dimension is dropped in the original data.
But after loading, the time dimension (with length : 1) will be added.")
}
gridData$Dates$start <- as.character(Date)
# Assing data to grid data
# At leaset should be 3 dimensions, lon, lat, time. So if less than 3,
if (length(dim(nc_data)) < 3) {
dim(nc_data) <- c(dim(nc_data), 1)
message('Time dimension is added, make sure in your original data, only time dimension is dropped.')
}
gridData$Data <- nc_data
attributes(gridData$Data)$dimensions <- dimNames
if (!is.na(dimIndex[4])) gridData$Members <- var$dim[[dimIndex[4]]]$vals
gridData$Loaded <- 'by hyfo package, http://yuanchao-xu.github.io/hyfo/'
return(gridData)
}
#' Write to NetCDF file using hyfo list file
#' @param gridData A hyfo list file or the list file from \code{loadECOMS{ecomsUDG.Raccess}}
#'  or \code{loadGridData{ecomsUDG.Raccess}}
#' @param filePath A path of the new NetCDF file, should end with ".nc"
#' @param missingValue A number representing the missing value in the NetCDF file, default
#' is 1e20
#' #' @param tz A string representing the time zone, default is GMT, if you know what time zone is
#' you can assign it in the argument. If \code{tz = ''}, current time zone will be taken.
#' @param units A string showing in which unit you are putting in the NetCDF file, it can be
#' seconds or days and so on. If not specified, the function will pick up the possible largest
#' time units from \code{c('weeks', 'days', 'hours', 'mins', 'secs')}
#' @return An NetCDF version 3 file.
#' @export
#' @import ncdf
writeNcdf <- function(gridData, filePath, missingValue = 1e20, tz = 'GMT', units = NULL) {
name <- gridData$Variable$varName
# First defines dimensions.
dimLon <- dim.def.ncdf('lon', 'degree', gridData$xyCoords$x)
dimLat <- dim.def.ncdf('lat', 'degree', gridData$xyCoords$y)
dimMem <- NULL
if (!is.null(gridData$Members)) {
dimMem <- dim.def.ncdf('member', 'members', 1:length(gridData$Members))
}
# Time needs to be treated seperately
dates <- as.POSIXlt(gridData$Dates$start, tz = tz)
if (is.null(units)) {
units <- getTimeUnit(dates)
time <- difftime(dates, dates[1], units = units)
} else {
time <- difftime(dates, dates[1], units = units)
}
timeUnits <- paste(units, 'since', dates[1])
dimTime <- dim.def.ncdf('time', timeUnits, time)
# Depending on whether there is a member part of the dataset.
dimList <- list(dimLon, dimLat, dimTime, dimMem)
# delete the NULL list, in order that there is no member part in the data.
dimList <- Filter(Negate(is.null), dimList)
# Then difines data
var <- var.def.ncdf( name, "units", dimList, missingValue)
nc <- create.ncdf(filePath, var)
# This part comes from the library downscaleR, can be deleted if you don't
# use {ecomsUDG.Raccess}, by adding this, the file can be read by the package {ecomsUDG.Raccess}
att.put.ncdf(nc, "time", "standard_name","time")
att.put.ncdf(nc, "time", "axis","T")
att.put.ncdf(nc, "time", "_CoordinateAxisType","Time")
#att.put.ncdf(nc, "time", "_ChunkSize",1)
att.put.ncdf(nc, "lon", "standard_name","longitude")
att.put.ncdf(nc, "lon", "_CoordinateAxisType","Lon")
att.put.ncdf(nc, "lat", "standard_name","latitude")
att.put.ncdf(nc, "lat", "_CoordinateAxisType","Lat")
if (!is.null(dimMem)){
att.put.ncdf(nc, "member", "standard_name","realization")
att.put.ncdf(nc, "member", "_CoordinateAxisType","Ensemble")
#att.put.ncdf(nc, "member", "ref","http://www.uncertml.org/samples/realisation")
}
# This part has to be put
att.put.ncdf(nc, 0, "Conventions","CF-1.4")
att.put.ncdf(nc, 0, 'WrittenBy', 'hyfo(http://yuanchao-xu.github.io/hyfo/)')
dimIndex <- match(c('lon', 'lat', 'time', 'member'), attributes(gridData$Data)$dimensions)
dimIndex <- na.omit(dimIndex)
data <- aperm(gridData$Data, dimIndex)
put.var.ncdf(nc, name, data)
close.ncdf(nc)
}
# For internaluse by writeNcdf
getTimeUnit <- function(dates) {
units <- c('weeks', 'days', 'hours', 'mins', 'secs')
output <- NULL
for (unit in units) {
time <- difftime(dates, dates[1], units = unit)
rem <- sapply(time, function(x) x%%1)
if (!any(rem != 0)) {
output <- unit
break
}
}
return(output)
}
# Save for future use.
#'@import ncdf
getExtralDim <- function(...) {
dimList <- list(...)
}
library(ncdf)
getNcdfVar(filePath)
a <- loadNcdf(filePath, "PRATE_surface")
name <- "PRATE_surface"
str(a)
writePath <- file.choose()
writeNcdf(a, writePath)
writeNcdf(a, writePath, units = 'seconds')
writeNcdf(a, writePath, units = 'secs')
b <- loadNcdf(writePath, name)
debug(loadNcdf)
b <- loadNcdf(writePath, name)
str(nc)
#' Get variable name in the NetCDF file. After knowning the name, you can use \code{loadNcdf} to load
#' the target variable.
#'
#' @param filePath A path pointing to the netCDF file.
#' @return The names of the varialbes in the file.
#' @import ncdf
#' @export
getNcdfVar <- function(filePath) {
nc <- open.ncdf(filePath)
names <- names(nc$var)
return(names)
}
#' Load NetCDF file
#'
#' @param filePath A path pointing to the NetCDF file, version3.
#' @param varname A character representing the variable name, you can use \code{getNcdfVar} to
#' get the basic information about the variables and select the target.
#' @param tz A string representing the time zone, default is GMT, if you know what time zone is
#' you can assign it in the argument. If \code{tz = ''}, current time zone will be taken.
#' @return A list object from \code{hyfo} containing the information to be used in the analysis,
#' or biascorrection.
#'
#' @export
#'@import ncdf
loadNcdf <- function(filePath, varname, tz = 'GMT') {
nc <- open.ncdf(filePath)
var <- nc$var
# Use name to locate the variable
call_1 <- as.call(c(
list(as.name('$'), var, varname)
))
var <- eval(call_1)
if(is.null(var)) stop('No such variable name, check source file.')
# First needs to identify the variable name, load the right data
message('Loading data...')
nc_data <- get.var.ncdf(nc, var)
message('Processing...')
dimNames <- unlist(lapply(1:length(var$dim), function(x) var$dim[[x]]$name))
# Only deals with the most common dimensions, futher dimensions will be added in future.
dimIndex <- match(c('lon', 'lat', 'time', 'member'), dimNames)
gridData <- list()
gridData$Variable$varName <- varname
gridData$xyCoords$x <- var$dim[[dimIndex[1]]]$vals
gridData$xyCoords$y <- var$dim[[dimIndex[2]]]$vals
# Time part needs to be taken seperately
timeUnit <- strsplit(var$dim[[dimIndex[3]]]$units, split = ' since')[[1]][1]
timeDiff <- var$dim[[dimIndex[3]]]$vals
# To get real time, time since when has to be grabbed from the dataset.
timeSince <- as.POSIXlt(strsplit(var$dim[[dimIndex[3]]]$units, split = 'since')[[1]][2], tz = tz)
#  Date <- rep(timeSince, length(timeDiff))
unitDic <- data.frame(weeks = 'weeks', days = 'days', hours = 'hours',
minutes = 'mins', seconds = 'secs')
timeDiff <- as.difftime(timeDiff, units = as.character(unitDic[1, timeUnit]))
#   if (grepl('day', timeUnit)) {
#     Date$mday <- Date$mday + timeDiff
#   } else if (grepl('second', timeUnit)) {
#     Date$sec <- Date$sec + timeDiff
#   }
Date <- timeSince + timeDiff
if (length(Date) == 1) {
warning("Only one time step is taken, time dimension is dropped in the original data.
But after loading, the time dimension (with length : 1) will be added.")
}
gridData$Dates$start <- as.character(Date)
# Assing data to grid data
# At leaset should be 3 dimensions, lon, lat, time. So if less than 3,
if (length(dim(nc_data)) < 3) {
dim(nc_data) <- c(dim(nc_data), 1)
message('Time dimension is added, make sure in your original data, only time dimension is dropped.')
}
gridData$Data <- nc_data
attributes(gridData$Data)$dimensions <- dimNames
if (!is.na(dimIndex[4])) gridData$Members <- var$dim[[dimIndex[4]]]$vals
gridData$Loaded <- 'by hyfo package, http://yuanchao-xu.github.io/hyfo/'
return(gridData)
}
#' Write to NetCDF file using hyfo list file
#' @param gridData A hyfo list file or the list file from \code{loadECOMS{ecomsUDG.Raccess}}
#'  or \code{loadGridData{ecomsUDG.Raccess}}
#' @param filePath A path of the new NetCDF file, should end with ".nc"
#' @param missingValue A number representing the missing value in the NetCDF file, default
#' is 1e20
#' #' @param tz A string representing the time zone, default is GMT, if you know what time zone is
#' you can assign it in the argument. If \code{tz = ''}, current time zone will be taken.
#' @param units A string showing in which unit you are putting in the NetCDF file, it can be
#' seconds or days and so on. If not specified, the function will pick up the possible largest
#' time units from \code{c('weeks', 'days', 'hours', 'mins', 'secs')}
#' @return An NetCDF version 3 file.
#' @export
#' @import ncdf
writeNcdf <- function(gridData, filePath, missingValue = 1e20, tz = 'GMT', units = NULL) {
name <- gridData$Variable$varName
# First defines dimensions.
dimLon <- dim.def.ncdf('lon', 'degree', gridData$xyCoords$x)
dimLat <- dim.def.ncdf('lat', 'degree', gridData$xyCoords$y)
dimMem <- NULL
if (!is.null(gridData$Members)) {
dimMem <- dim.def.ncdf('member', 'members', 1:length(gridData$Members))
}
# Time needs to be treated seperately
dates <- as.POSIXlt(gridData$Dates$start, tz = tz)
if (is.null(units)) {
units <- getTimeUnit(dates)
time <- difftime(dates, dates[1], units = units)
} else {
time <- difftime(dates, dates[1], units = units)
}
unitDic <- data.frame(weeks = 'weeks', days = 'days', hours = 'hours',
mins = 'minutes', secs = 'seconds')
timeUnits <- paste(unitDic[1, units], 'since', dates[1])
dimTime <- dim.def.ncdf('time', timeUnits, time)
# Depending on whether there is a member part of the dataset.
dimList <- list(dimLon, dimLat, dimTime, dimMem)
# delete the NULL list, in order that there is no member part in the data.
dimList <- Filter(Negate(is.null), dimList)
# Then difines data
var <- var.def.ncdf( name, "units", dimList, missingValue)
nc <- create.ncdf(filePath, var)
# This part comes from the library downscaleR, can be deleted if you don't
# use {ecomsUDG.Raccess}, by adding this, the file can be read by the package {ecomsUDG.Raccess}
att.put.ncdf(nc, "time", "standard_name","time")
att.put.ncdf(nc, "time", "axis","T")
att.put.ncdf(nc, "time", "_CoordinateAxisType","Time")
#att.put.ncdf(nc, "time", "_ChunkSize",1)
att.put.ncdf(nc, "lon", "standard_name","longitude")
att.put.ncdf(nc, "lon", "_CoordinateAxisType","Lon")
att.put.ncdf(nc, "lat", "standard_name","latitude")
att.put.ncdf(nc, "lat", "_CoordinateAxisType","Lat")
if (!is.null(dimMem)){
att.put.ncdf(nc, "member", "standard_name","realization")
att.put.ncdf(nc, "member", "_CoordinateAxisType","Ensemble")
#att.put.ncdf(nc, "member", "ref","http://www.uncertml.org/samples/realisation")
}
# This part has to be put
att.put.ncdf(nc, 0, "Conventions","CF-1.4")
att.put.ncdf(nc, 0, 'WrittenBy', 'hyfo(http://yuanchao-xu.github.io/hyfo/)')
dimIndex <- match(c('lon', 'lat', 'time', 'member'), attributes(gridData$Data)$dimensions)
dimIndex <- na.omit(dimIndex)
data <- aperm(gridData$Data, dimIndex)
put.var.ncdf(nc, name, data)
close.ncdf(nc)
}
# For internaluse by writeNcdf
getTimeUnit <- function(dates) {
units <- c('weeks', 'days', 'hours', 'mins', 'secs')
output <- NULL
for (unit in units) {
time <- difftime(dates, dates[1], units = unit)
rem <- sapply(time, function(x) x%%1)
if (!any(rem != 0)) {
output <- unit
break
}
}
return(output)
}
# Save for future use.
#'@import ncdf
getExtralDim <- function(...) {
dimList <- list(...)
}
b <- loadNcdf(writePath, name)
debug(loadNcdf)
b <- loadNcdf(writePath, name)
as.character(unitDic[1, timeUnit])
unitDic[1, timeUnit]
timeUnit
unitDic[1, timeUnit]
writeNcdf(a, writePath, units = 'seconds')
writeNcdf(a, writePath, units = 'secs')
b <- loadNcdf(writePath, name)
str(c)
str(b)
debug(loadNcdf)
b <- loadNcdf(writePath, name)
str(nc)
b <- loadGridData(writePath, name, dic = F)
require(ecomsUDG.Raccess)
b <- loadGridData(writePath, name, dic = F)
devtools::document()
devtools::check()
devtools::build()
Q
