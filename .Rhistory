print(mainLayer)
}else{
rangeLayer <- geom_errorbar(aes(x = Index, ymax = maxValue, ymin = minValue), width = 0.3)
print(mainLayer + rangeLayer)
}
}else{
print(mainLayer)
}
if (output == 'plot') {
return(mainLayer)
}else if (output == 'ggplot') {
plotPreci$Name <- rep(title, dim(plotPreci)[1])
return(plotPreci)
}else{
return(plotPreci)
}
}
#' Combine bars together
#' @param ... different barplots generated by \code{getPreciBar(, output = 'ggplot')}, refer to details.
#' @details
#' ..., representing different ouput generated by \code{getPreciBar(, output = 'ggplot')}, they
#' have to be of the same type, e.g.,
#' 1. Jan precipitation of different years, Feb precipitation of different years, and...
#' They are both monthly precipitation, and they share x axis.
#'
#' 2. Mean monthly precipitation of different dataset. e.g., long term mean monthly precipitation
#' and short term mean monthly precipitation. They are both mean monthly precipitation.
#'
#' @param nrow A number showing the number of rows.
#' @param list If input is a list containing different ggplot data, use l\code{list = inputlist}.
#' @return A combined barplot.
#' @examples
#'
#' data(gridData)# the result of \code{loadGridData{ecomsUDG.Raccess}}
#' #output type of getPreciBar() has to be 'ggplot'.
#' b1 <- getPreciBar(gridData, method = 2, output = 'ggplot')
#' b2 <- getPreciBar(gridData, method = 3, output = 'ggplot')
#'
#' getPreciBar_comb(b1, b2)
#'
#' @export
#' @import ggplot2
getPreciBar_comb <- function(..., list = NULL, nrow = 1){
if(!is.null(list)){
data_ggplot <- do.call('rbind', list)
}else{
bars <- list(...)
data_ggplot <- do.call('rbind', bars)
}
data_ggplot$Name <- factor(data_ggplot$Name, levels = data_ggplot$Name, ordered = TRUE)
theme_set(theme_bw())
mainLayer <- with(data_ggplot, {
mainLayer <- ggplot(data_ggplot)+
geom_bar(aes(x = Index, y = Preci, fill = Name), stat = 'identity', colour = 'black', width = .6)+
facet_wrap( ~ Name, nrow = nrow)
})
print (mainLayer)
}
getPreciBar(gridData, method = 'annual')
getPreciBar(gridData, method = 'meanMonthly')
#' Get spatial map of the input dataset.
#'
#' @param dataset A list containing different information, should be the result of reading netcdf file using
#' \code{library(ecomsUDG.Raccess)}.
#' @param method A string showing different calculating method for the map.
#' @param ... Check \code{?getSpatialMap_mat} for details, e.g., x, y, title, catchment,
#' points, output,
#' @return A matrix representing the raster map is returned, and the map is plotted.
#' @examples
#'
#' #gridData provided in the package is the result of \code {loadGridData{ecomsUDG.Raccess}}
#' getSpatialMap(gridData, method = 'meanAnnual')
#' getSpatialMap(gridData, method = 'winter')
#'
#'
#' getSpatialMap(gridData, method = 'winter', catchment = testCat)
#'
#' file <- system.file("extdata", "points.txt", package = "hyfo")
#' points <- read.table(file, header = TRUE, sep = ',' )
#' getSpatialMap(gridData, method = 'winter', catchment = testCat, points = points)
#'
#' @export
getSpatialMap <- function(dataset, method = NULL, ...){
#check input dataset
checkWord <- c('Data', 'xyCoords', 'Dates')
if(any(is.na(match(checkWord, attributes(dataset)$names)))){
stop ('Input dataset is incorrect, it should contain "Data", "xyCoords", and "Dates",
check help for details.')
}
#range of the dataset just loaded
lon <- dataset$xyCoords$x
lat <- dataset$xyCoords$y
startTime <- as.POSIXlt(dataset$Dates$start, tz = 'GMT')
yearIndex <- startTime$year + 1900
monthIndex <-startTime$mon + 1
data <- dataset$Data
if (is.null(method)){
warning ('You should shoose a method, unless input is a matrix directly to be plotted.')
#in case the dataset is ready to plot and no need to calculate
}else if(method == 'meanAnnual'){
#mean value of the annual precipitation over the period of the data
#time <- proc.time()
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex,  method = 'meanAnnualPreci')
#newTime <- proc.time() - time
title  <- 'Mean Annual Precipitation (mm / year)'
}else if(method == 'winter'){
#mean value of the seasonal precipitation, in this case, winter
#time <- proc.time()
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'winter')
#newTime <- proc.time() - time
title <- 'Mean Winter Precipitation (mm / winter)'
}else if(method == 'spring'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'spring')
title <- 'Mean Spring Precipitation (mm / spring)'
}else if (method == 'summer'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'summer')
title <- 'Mean Summer Precipitation (mm / summer)'
}else if (method == 'autumn'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'autumn')
title <- 'Mean Autumn Precipitation (mm / autumn)'
}else if(method == 'mean'){
#sum value of the dataset, this procedure is to get the mean value
data_new <- apply(data, MARGIN = c(2,3), FUN = mean)
title <- 'Mean Daily Precipitation (mm / day)'
}else if(method == 'max'){
data_new <- apply(data, MARGIN = c(2,3), FUN = max)
title <- 'Max Daily Precipitation (mm / day)'
}else if(method == 'min'){
data_new <- apply(data, MARGIN = c(2,3), FUN = min)
title <- 'Min Daily Precipitation (mm / day)'
}else{
wrongMethod <- method
stop (paste('no method called', wrongMethod))
}
#this is to give attributes to the matrix and better be melted in ggplot.
colnames(data_new) <- round(lon, 2)
rownames(data_new) <- round(lat, 2)
output <- getSpatialMap_mat(data_new, title, ...)
return (output)
}
#' Get spatial map of the input dataset, and a matrix representing the raster map will be returned.
#'
#' @param matrix A matrix raster, should be the result of \code{getSpatialMap()}, output should be default
#' or 'data'
#' @param title A string showing the title of the plot, defaut is NULL.
#' @param catchment A catchment file geting from \code{shp2cat()} in the package, if a catchment is available for background.
#' @param points A dataframe, showing other information, e.g., location of the gauging stations. The
#' the data.frame should be with columes "name, lon, lat, z, value".
#' @param output A string showing the type of the output, if \code{output = 'ggplot'}, the returned
#' data can be used in ggplot and \code{getSpatialMap_comb()}; if \code{output = 'plot'}, the returned data is the plot containing all
#' layers' information, and can be plot directly or used in grid.arrange; if not set, the raster matrix data
#' will be returned.
#' @param info A boolean showing whether the information of the map, e.g., max, mean ..., default is T.
#' @param scale A string showing the plot scale, 'identity' or 'sqrt'.
#' @param ... \code{title, y} showing the title and x and y axis of the plot, default is about precipitation.
#' @return A matrix representing the raster map is returned, and the map is plotted.
#' @examples
#' data(gridData)# the result of \code{loadGridData{ecomsUDG.Raccess}}
#' #the output type of has to be default or 'data'.
#' a1 <- getSpatialMap(gridData, method = 'mean')
#' a2 <- getSpatialMap(gridData, method = 'max')
#' a3 <- getSpatialMap(gridData, method = 'winter')
#' a4 <- getSpatialMap(gridData, method = 'summer')
#' #For example, if we want to investigate the difference between mean value and max.
#'
#' a5 <- a2 - a1
#' getSpatialMap_mat(a4)
#'
#' #Or to investigate the difference between winter value and summer value.
#' a6 <- a3 - a4
#' getSpatialMap_mat(a6)
#'
#' @export
#' @import ggplot2 rgdal plyr maps
getSpatialMap_mat <- function(matrix, title = NULL, catchment = NULL, points = NULL, output = 'data',
info = TRUE, scale = 'identity', ...){
#check input
checkWord <- c('lon', 'lat', 'z', 'value')
if (is.null(attributes(matrix)$dimnames)){
stop ('Input matrix is incorrect, check help to know how to get the matrix.')
}else if (!is.null(catchment) & class(catchment) != "SpatialPolygonsDataFrame"){
stop ('Catchment format is incorrect, check help to get more details. ')
}else if (!is.null(points) & any(is.na(match(checkWord, attributes(points)$names)))){
stop ('Points should be a dataframe with colnames "lon, lat, z, value".')
}
#ggplot
#for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function
#get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use
#data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available
#in the environment.
#in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them
#outside aes() as normal parameters.
if (info == T) {
plotMax <- round(max(matrix, na.rm = TRUE), 2)
plotMin <- round(min(matrix, na.rm = TRUE), 2)
plotMean <- round(mean(matrix, na.rm = TRUE), 2)
plotMedian <- round(median(matrix, na.rm = TRUE), 2)
word <- paste('\n\n', paste('Max', '=', plotMax), ',', paste('Min', '=', plotMin), ',',
paste('Mean', '=', plotMean), ',', paste('Median', '=', plotMedian))
}else{
word <- NULL
}
x_word <- paste('Longitude', word)
world_map <- map_data('world')
data_ggplot <- melt(matrix, na.rm = T)
colnames(data_ggplot) <- c('lat', 'lon', 'value')
theme_set(theme_bw())
mainLayer <- with(data_ggplot, {
mainLayer <- ggplot(data = data_ggplot)+
geom_tile(aes(x = lon, y = lat, fill = value))+
#scale_fill_gradient(high = 'red', low = 'yellow')+
scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent',
guide = guide_colorbar(title='Rainfall (mm)', barheight = 15), trans = scale)+#usually scale = 'sqrt'
geom_map(data = world_map, map = world_map, aes(map_id = region), fill='transparent', color='black')+
#    guides(fill = guide_colorbar(title='Rainfall (mm)', barheight = 15))+
xlab(x_word)+
ylab('Latitude')+
ggtitle(title)+
labs(empty = NULL, ...)+#in order to pass "...", arguments shouldn't be empty.
theme(plot.title = element_text(size = 20, face = 'bold'),
axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18))
#     geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),
#               xmax=min(lon)+0.99*(max(lon)-min(lon)),
#               ymin=min(lat)+0.02*(max(lat)-min(lat)),
#               ymax=min(lat)+0.28*(max(lat)-min(lat)),
#               fill='white',colour='black')+
#     annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)
})
printLayer <- mainLayer
#catchment conversion
if(is.null(catchment) == FALSE){
a <- catchment
a@data$id <- rownames(a@data)
b <- fortify(a, region = 'id')
c <- join(b, a@data, by = 'id')
catchmentLayer <- geom_polygon(data = c, aes(long, lat, group = group), color = 'black',
fill = 'transparent')
printLayer <- printLayer + catchmentLayer
}
#plot points
if(is.null(points) == FALSE){
pointLayer <- geom_point(data = points,aes(x = lon, y = lat, size = value, colour = z))
printLayer <- printLayer + pointLayer
}
print (printLayer)
if(output == 'ggplot') {
data_ggplot$Name <- rep(title, dim(data_ggplot)[1])
return (data_ggplot)
}else if (output == 'plot'){
return(printLayer)
}else{
return(matrix)
}
}
#' Combine maps together
#' @param ... different maps generated by \code{getSpatialMap(, output = 'ggplot')}
#' @param nrow A number showing the number of rows.
#' @param list If input is a list containing different ggplot data, use l\code{list = inputlist}.
#' @return A combined map.
#' @examples
#' data(gridData)# the result of \code{loadGridData{ecomsUDG.Raccess}}
#' #The output should be 'ggplot'
#' a1 <- getSpatialMap(gridData, method = 'summer', output = 'ggplot')
#' a2 <- getSpatialMap(gridData, method = 'winter', output = 'ggplot')
#'
#' getSpatialMap_comb(a1, a2)
#'
#' @export
#' @import ggplot2 maps
getSpatialMap_comb <- function(..., list = NULL, nrow = 1){
if (!is.null(list)){
data_ggplot <- do.call('rbind', list)
}else{
maps <- list(...)
data_ggplot <- do.call('rbind', maps)
}
world_map <- map_data('world')
theme_set(theme_bw())
mainLayer <- ggplot(data = data_ggplot)+
geom_tile(aes(x = lon, y = lat, fill = value))+
#scale_fill_gradient(high = 'red', low = 'yellow')+
scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent')+#usually scale = 'sqrt'
geom_map(data = world_map, map = world_map, aes(map_id = region), fill = 'transparent', color = 'black')+
facet_wrap(~ Name, nrow = nrow)
print (mainLayer)
}
getSpatialMap(gridData, method = 'mean')
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
render("input.Rmd", "pdf_document")
library(rmarkdown)
render("input.Rmd", "pdf_document")
render("hyfo.Rmd", "pdf_document")
render("hyfo.Rmd", "pdf_document")
install.packages('pdfLatex')
pdflatex -v
#' Collect data from different csv files.
#' @param folderName A string showing the path of the folder holding different csv files.
#' @param fileType A string showing the file type, e.g. "txt", "csv", "excel".
#' @param range A vector containing startRow, endRow, startColumn, endColumn, e.g.,
#' c(2,15,2,3)
#' @param sheetIndex A number showing the sheetIndex in the excel file, if fileType is excel,
#' sheetIndex has to be provided, default is 1.
#' @return The collected data from different files in the folder.
#' @examples
#'
#' #use internal data as an example.
#' file <- system.file("extdata", "1999.csv", package = "hyfo")
#' folder <- strsplit(file, '1999')[[1]][1]
#' a <- collectData(folder, fileType = 'csv', range = c(10, 20, 1,2))
#'
#' @export
collectData <- function(folderName, fileType = NULL, range = NULL, sheetIndex = 1){
message ('All the files in the folder should have the same format')
if (is.null(fileType)) stop ('Please enter fileType, "txt", "csv" or "excel".')
if(length(range) > 4){
stop ('"range" should be c(startRow, endRow, startCol, endCol)')
}else if (is.null(range)){
stop('"range" can not be blank, e.g., range <- c(startRow, endRow, startCol, endCol).')
}
if (fileType == 'csv') {
fileNames <- list.files(folderName, pattern = '*.csv', full.names = TRUE)
if (length(fileNames) == 0) stop ('No csv file in the folder.')
data <- lapply(fileNames, readCsv, range = range)
data <- do.call('rbind', data)
}else if (fileType == 'txt'){
fileNames <- list.files(folderName, pattern = '*.txt', full.names = TRUE)
if (length(fileNames) == 0){
fileNames <- list.files(folderName, pattern = '*.TXT', full.names = TRUE)
}
if (length(fileNames) == 0) stop ('No text file in the folder.')
message ('For txt file, only startRow and endRow will be considered.')
data <- lapply(fileNames, readTxt, range = range)
data <- unlist(data)
}else if (fileType == 'excel'){
fileNames <- list.files(folderName, pattern = '*.xlsx', full.names = TRUE)
if (length(fileNames) == 0){
fileNames <- list.files(folderName, pattern = '*.xls', full.names = TRUE)
}
if (length(fileNames) == 0) stop ('No excel in the folder.')
data <- lapply(fileNames, readExcel, range = range, sheetIndex = sheetIndex)
checkBind(data, 'rbind')
data <- do.call('rbind', data)
}else{
stop ('fileType should be "txt", "csv" or "excel".')
}
return (data)
}
readExcel <- function(fileName, range, sheetIndex){
data <- xlsx::read.xlsx(fileName, sheetIndex = sheetIndex, rowIndex = seq(range[1], range[2]),
colIndex = seq(range[3], range[4]))
colnames(data) <- seq(1, dim(data)[2])
message (fileName)
return (data)
}
readTxt <- function(fileName, range){
data <- readLines(fileName)
data <- data[range[1]:range[2]]
return (data)
}
readCsv <- function(fileName, range){
data <- read.csv(fileName, skip = range[1] - 1, header = FALSE)
data <- data[1:(range[2] - range[1] + 1), range[3]:range[4]]
return (data)
}
collectData
collectData(daf)
str(a)
x <- dget(file.choose())
devtools::use_data(x)
```{r, fig.show='hold'}
library(hyfo)#load the package.
file <- system.file("extdata", "1999.csv", package = "hyfo")
folder <- strsplit(file, '1999')[[1]][1] # get the folder containing different csv (or other type) files.
# extract and combine content from different files and in each file, the extracted zone is from row 10 to row 20, #column 1 to column2.
a <- collectData(folder, fileType = 'csv', range = c(10, 20, 1,2))
str(a)
a
a <- list(a)
getAnnual(a)
debug(getAnnual)
getAnnual(a)
Date
dataset[,1]
str(a)
?as.Date
a
a[,1]
dim(a)
length(a)
as.frame(a)
xxxxxx <- data.frame(a)
dim(xxxxxx)
a_start<- a [,1]
a <- data.frame(a)
a[,1]
a[1,1]
a_end <- tail(a[, 1])
a_end
a_end <- tail(a[, 1], 1)
a_end
a_date <- seq('1999-1-6', '2000-1-16', 1)
a_date <- seq(as.Date('1999-1-6'), as.Date('2000-1-16'), 1)
a_date
a[, 1] <- a_date
str(a)
a
a[, 1]
xx <- as.Date(a[, 1])
xx
xx <- as.Date(a[, 1], format = '%m/%d/Y')
xx
xx <- as.Date('06/01/1999', format = '%m/%d/Y')
xx
xx <- as.Date('06/01/1999', format = '%m/%d/Y')
xx
xx <- as.Date('6/1/1999', format = '%m/%d/Y')
xx
debug(as.Date)
xx <- as.Date('6/1/1999', format = '%m/%d/Y')
res
format
carToDate(x)
charToDate(x)
res
res
xx
xx <- as.Date('06/01/1999', format = '%m/%d/Y')
missing(format)
y
strptime
?strptime
x
format
format
a_date <- a[, 1]
a_date
a_date <- as.Date(a_date, format = '%d/%m/%Y')
C
undebug(as.Date)
a_date <- as.Date(a_date, format = '%d/%m/%Y')
a_date
a <- dget()
a <- dget(file.choose())
str(a)
datalist
data(datalist)
datalist
str(datalsit)
str(datalist)
datalist[[1]]
datalist[[1]][,2]
a[[1]][,2]
datalist[[1]][,2] <- a[[1]][, 2] * 0.93
datalist[[1]][,2] <- a[[1]][1:2348, 2] * 0.93
datalist[[2]][,2] <- a[[2]][1:2348, 2] * 0.93
datalist[[2]][,2] <- a[[2]][1:2106, 2] * 0.9
datalist[[3]][,2] <- a[[3]][1:2106, 2] * 0.9
datalist[[3]][,2] <- a[[3]][1:2891, 2] * 0.6
str(datalist)
getAnnual(datalist)
testdl <- datalist
devtools::use_data(testdl)
data(gridData)
tgridData <- gridData
devtools::use_data(tgridData)
data(x)
str(x)
devtools::document()
devtools::check()
data(testdl)
str(testdl)
dput(testdl, file.choose())
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
s
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::build()
library(hyfo)
data(testdl)
testdl
testdl
devtools::document()
devtools::document()
devtools::document()
library(stringi)
Q
devtools::document()
devtools::document()
install.packages('stringi')
devtools::document()
