#sum value of the dataset, this procedure is to get the mean value
data_new <- apply(data, MARGIN = c(2,3), FUN = mean)
}else if(method == 'max'){
data_new <- apply(data, MARGIN = c(2,3), FUN = max)
}else if(method == 'min'){
data_new <- apply(data, MARGIN = c(2,3), FUN = min)
}else{
wrongMethod <- method
stop (paste('no method called',wrongMethod))
}
if (info == T) {
plotMax <- round(max(data_new,na.rm=TRUE),2)
plotMin <- round(min(data_new,na.rm=TRUE),2)
plotMean <- round(mean(data_new,na.rm=TRUE),2)
plotMedian <- round(median(data_new,na.rm=T),2)
word <- paste('\n\n', paste('Max','=',plotMax), paste('Min','=',plotMin),
paste('Mean','=',plotMean), paste('Median', '=', plotMedian), sep = '  ')
}else{
x_word <- paste('Longitude', word)
}
#set names for the matrix, in order to be better converted later in ggplot.
colnames(data_new) <- round(lon,2)
rownames(data_new) <- round(lat,2)
world_map <- ggplot2::map_data('world')
#ggplot
#for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function
#get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use
#data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available
#in the environment.
#in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them
#outside aes() as normal parameters.
data_ggplot <- reshape2::melt(data_new, na.rm = T)
colnames(data_ggplot) <- c('lat', 'lon', 'value')
theme_set(theme_bw())
mainLayer <- ggplot(data = data_ggplot)+
geom_tile(aes(x=lon,y=lat,fill = value))+
scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent', ...)+#usually scale = 'sqrt'
geom_map(data = world_map, map = world_map, aes(map_id = region), fill='transparent', color='black')+
guides(fill = guide_colorbar(title='Rainfall (mm)', barheight = 15))+
xlab(x_word)+
ylab('Latitude')+
ggtitle(title)+
theme(plot.title=element_text(size=20, face='bold'),
axis.title.x=element_text(size = 18),
axis.title.y = element_text(size = 18))
#     geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),
#               xmax=min(lon)+0.99*(max(lon)-min(lon)),
#               ymin=min(lat)+0.02*(max(lat)-min(lat)),
#               ymax=min(lat)+0.28*(max(lat)-min(lat)),
#               fill='white',colour='black')+
#   annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)
printLayer <- mainLayer
#catchment conversion
if(is.null(catchment) == FALSE){
a <- catchment
a@data$id <- rownames(a@data)
b <- fortify(a,region='id')
c <- plyr::join(b,a@data,by='id')
catchmentLayer <- geom_polygon(data=c, aes(long,lat,group=group), color='black', fill='transparent')
printLayer <- printLayer + catchmentLayer
}
if(is.null(points) == FALSE){
pointLayer <- geom_point(data = points,aes(x = lon, y = lat, size = value, colour = z))
printLayer <- printLayer + pointLayer
}
print (printLayer)
if(outputData == TRUE) return(data_new)
}
a <- getSpatialMap(b, me = 'meanAnnual', trans = 'sqrt', info = F)
#' Get spatial map of the input dataset, and a matrix representing the raster map will be returned.
#'
#' @param dataset A list containing different information, should be the result of reading netcdf file using
#' \code{library(ecomsUDG.Raccess)}.
#' @param catchment A catchment file geting from \code{shp2cat()} in the package, if a catchment is available for background.
#' @param points A shape file showing other information, e.g., location of the gauging stations.
#' @param method A string showing different calculating method for the map.
#' @param outputData A boolean showing whether the raster matrix will be returned, default is T.
#' @param ... arguments which will be passed to \code{scale_fill_gradientn()}, including \code{trans},
#' \code{limits}, \code{breaks}, see \code{scale_fill_gradientn()} for more details.
#' @return A matrix representing the raster map is returned, and the map is plotted.
#' @export
#' @import ggplot2 rgdal gridExtra
getSpatialMap <- function(dataset, catchment = NULL,points = NULL, method = NULL, outputData = TRUE,
info = T, ...){
message('used for showing the spatial map for parameters like precipitation.
different method are provided for analysing the parameters
catchment needs shape file
points needs data.frame, with colume "name, lon, lat, z, value" in data.frame()
method = NULL means no method calculated on the cell')
#range of the dataset just loaded
lon <- dataset$xyCoords$x
lat <- dataset$xyCoords$y
startTime <- as.POSIXlt(dataset$Dates$start,tz = 'GMT')
yearIndex <- startTime$year + 1900
monthIndex <-startTime$mon + 1
data <- dataset$Data
if (is.null(method)){
#in case the dataset is ready to plot and no need to calculate
}else if(method == 'meanAnnual'){
#mean value of the annual precipitation over the period of the data
#time <- proc.time()
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex,  method = 'meanAnnualPreci')
#newTime <- proc.time() - time
title  <- 'Mean Annual Precipitation (mm / year)'
}else if(method == 'winter'){
#mean value of the seasonal precipitation, in this case, winter
#time <- proc.time()
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'winter')
#newTime <- proc.time() - time
title <- 'Mean Winter Precipitation (mm / winter)'
}else if(method == 'spring'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'spring')
title <- 'Mean Spring Precipitation (mm / spring)'
}else if (method == 'summer'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'summer')
title <- 'Mean Summer Precipitation (mm / summer)'
}else if (method == 'autumn'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'autumn')
title <- 'Mean Autumn Precipitation (mm / autumn)'
}else if(method == 'mean'){
#sum value of the dataset, this procedure is to get the mean value
data_new <- apply(data, MARGIN = c(2,3), FUN = mean)
}else if(method == 'max'){
data_new <- apply(data, MARGIN = c(2,3), FUN = max)
}else if(method == 'min'){
data_new <- apply(data, MARGIN = c(2,3), FUN = min)
}else{
wrongMethod <- method
stop (paste('no method called',wrongMethod))
}
if (info == T) {
plotMax <- round(max(data_new,na.rm=TRUE),2)
plotMin <- round(min(data_new,na.rm=TRUE),2)
plotMean <- round(mean(data_new,na.rm=TRUE),2)
plotMedian <- round(median(data_new,na.rm=T),2)
word <- paste('\n\n', paste('Max','=',plotMax), paste('Min','=',plotMin),
paste('Mean','=',plotMean), paste('Median', '=', plotMedian), sep = '  ')
}
x_word <- paste('Longitude', word)
#set names for the matrix, in order to be better converted later in ggplot.
colnames(data_new) <- round(lon,2)
rownames(data_new) <- round(lat,2)
world_map <- ggplot2::map_data('world')
#ggplot
#for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function
#get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use
#data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available
#in the environment.
#in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them
#outside aes() as normal parameters.
data_ggplot <- reshape2::melt(data_new, na.rm = T)
colnames(data_ggplot) <- c('lat', 'lon', 'value')
theme_set(theme_bw())
mainLayer <- ggplot(data = data_ggplot)+
geom_tile(aes(x=lon,y=lat,fill = value))+
scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent', ...)+#usually scale = 'sqrt'
geom_map(data = world_map, map = world_map, aes(map_id = region), fill='transparent', color='black')+
guides(fill = guide_colorbar(title='Rainfall (mm)', barheight = 15))+
xlab(x_word)+
ylab('Latitude')+
ggtitle(title)+
theme(plot.title=element_text(size=20, face='bold'),
axis.title.x=element_text(size = 18),
axis.title.y = element_text(size = 18))
#     geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),
#               xmax=min(lon)+0.99*(max(lon)-min(lon)),
#               ymin=min(lat)+0.02*(max(lat)-min(lat)),
#               ymax=min(lat)+0.28*(max(lat)-min(lat)),
#               fill='white',colour='black')+
#   annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)
printLayer <- mainLayer
#catchment conversion
if(is.null(catchment) == FALSE){
a <- catchment
a@data$id <- rownames(a@data)
b <- fortify(a,region='id')
c <- plyr::join(b,a@data,by='id')
catchmentLayer <- geom_polygon(data=c, aes(long,lat,group=group), color='black', fill='transparent')
printLayer <- printLayer + catchmentLayer
}
if(is.null(points) == FALSE){
pointLayer <- geom_point(data = points,aes(x = lon, y = lat, size = value, colour = z))
printLayer <- printLayer + pointLayer
}
print (printLayer)
if(outputData == TRUE) return(data_new)
}
a <- getSpatialMap(b, me = 'meanAnnual', trans = 'sqrt', info = F)
#' Get spatial map of the input dataset, and a matrix representing the raster map will be returned.
#'
#' @param dataset A list containing different information, should be the result of reading netcdf file using
#' \code{library(ecomsUDG.Raccess)}.
#' @param catchment A catchment file geting from \code{shp2cat()} in the package, if a catchment is available for background.
#' @param points A shape file showing other information, e.g., location of the gauging stations.
#' @param method A string showing different calculating method for the map.
#' @param outputData A boolean showing whether the raster matrix will be returned, default is T.
#' @param ... arguments which will be passed to \code{scale_fill_gradientn()}, including \code{trans},
#' \code{limits}, \code{breaks}, see \code{scale_fill_gradientn()} for more details.
#' @return A matrix representing the raster map is returned, and the map is plotted.
#' @export
#' @import ggplot2 rgdal gridExtra
getSpatialMap <- function(dataset, catchment = NULL,points = NULL, method = NULL, outputData = TRUE,
info = T, ...){
message('used for showing the spatial map for parameters like precipitation.
different method are provided for analysing the parameters
catchment needs shape file
points needs data.frame, with colume "name, lon, lat, z, value" in data.frame()
method = NULL means no method calculated on the cell')
#range of the dataset just loaded
lon <- dataset$xyCoords$x
lat <- dataset$xyCoords$y
startTime <- as.POSIXlt(dataset$Dates$start,tz = 'GMT')
yearIndex <- startTime$year + 1900
monthIndex <-startTime$mon + 1
data <- dataset$Data
if (is.null(method)){
#in case the dataset is ready to plot and no need to calculate
}else if(method == 'meanAnnual'){
#mean value of the annual precipitation over the period of the data
#time <- proc.time()
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex,  method = 'meanAnnualPreci')
#newTime <- proc.time() - time
title  <- 'Mean Annual Precipitation (mm / year)'
}else if(method == 'winter'){
#mean value of the seasonal precipitation, in this case, winter
#time <- proc.time()
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'winter')
#newTime <- proc.time() - time
title <- 'Mean Winter Precipitation (mm / winter)'
}else if(method == 'spring'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'spring')
title <- 'Mean Spring Precipitation (mm / spring)'
}else if (method == 'summer'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'summer')
title <- 'Mean Summer Precipitation (mm / summer)'
}else if (method == 'autumn'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'autumn')
title <- 'Mean Autumn Precipitation (mm / autumn)'
}else if(method == 'mean'){
#sum value of the dataset, this procedure is to get the mean value
data_new <- apply(data, MARGIN = c(2,3), FUN = mean)
}else if(method == 'max'){
data_new <- apply(data, MARGIN = c(2,3), FUN = max)
}else if(method == 'min'){
data_new <- apply(data, MARGIN = c(2,3), FUN = min)
}else{
wrongMethod <- method
stop (paste('no method called',wrongMethod))
}
if (info == T) {
plotMax <- round(max(data_new,na.rm=TRUE),2)
plotMin <- round(min(data_new,na.rm=TRUE),2)
plotMean <- round(mean(data_new,na.rm=TRUE),2)
plotMedian <- round(median(data_new,na.rm=T),2)
word <- paste('\n\n', paste('Max','=',plotMax), paste('Min','=',plotMin),
paste('Mean','=',plotMean), paste('Median', '=', plotMedian), sep = '  ')
}else{
word <- NULL
}
x_word <- paste('Longitude', word)
#set names for the matrix, in order to be better converted later in ggplot.
colnames(data_new) <- round(lon,2)
rownames(data_new) <- round(lat,2)
world_map <- ggplot2::map_data('world')
#ggplot
#for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function
#get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use
#data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available
#in the environment.
#in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them
#outside aes() as normal parameters.
data_ggplot <- reshape2::melt(data_new, na.rm = T)
colnames(data_ggplot) <- c('lat', 'lon', 'value')
theme_set(theme_bw())
mainLayer <- ggplot(data = data_ggplot)+
geom_tile(aes(x=lon,y=lat,fill = value))+
scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent', ...)+#usually scale = 'sqrt'
geom_map(data = world_map, map = world_map, aes(map_id = region), fill='transparent', color='black')+
guides(fill = guide_colorbar(title='Rainfall (mm)', barheight = 15))+
xlab(x_word)+
ylab('Latitude')+
ggtitle(title)+
theme(plot.title=element_text(size=20, face='bold'),
axis.title.x=element_text(size = 18),
axis.title.y = element_text(size = 18))
#     geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),
#               xmax=min(lon)+0.99*(max(lon)-min(lon)),
#               ymin=min(lat)+0.02*(max(lat)-min(lat)),
#               ymax=min(lat)+0.28*(max(lat)-min(lat)),
#               fill='white',colour='black')+
#   annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)
printLayer <- mainLayer
#catchment conversion
if(is.null(catchment) == FALSE){
a <- catchment
a@data$id <- rownames(a@data)
b <- fortify(a,region='id')
c <- plyr::join(b,a@data,by='id')
catchmentLayer <- geom_polygon(data=c, aes(long,lat,group=group), color='black', fill='transparent')
printLayer <- printLayer + catchmentLayer
}
if(is.null(points) == FALSE){
pointLayer <- geom_point(data = points,aes(x = lon, y = lat, size = value, colour = z))
printLayer <- printLayer + pointLayer
}
print (printLayer)
if(outputData == TRUE) return(data_new)
}
a <- getSpatialMap(b, me = 'meanAnnual', trans = 'sqrt', info = F)
a <- getSpatialMap(b, me = 'meanAnnual', trans = 'sqrt')
#' Get spatial map of the input dataset, and a matrix representing the raster map will be returned.
#'
#' @param dataset A list containing different information, should be the result of reading netcdf file using
#' \code{library(ecomsUDG.Raccess)}.
#' @param catchment A catchment file geting from \code{shp2cat()} in the package, if a catchment is available for background.
#' @param points A shape file showing other information, e.g., location of the gauging stations.
#' @param method A string showing different calculating method for the map.
#' @param outputData A boolean showing whether the raster matrix will be returned, default is T.
#' @
#' @param ... arguments which will be passed to \code{scale_fill_gradientn()}, including \code{trans},
#' \code{limits}, \code{breaks}, see \code{scale_fill_gradientn()} for more details.
#' @return A matrix representing the raster map is returned, and the map is plotted.
#' @export
#' @import ggplot2 rgdal gridExtra
getSpatialMap <- function(dataset, catchment = NULL,points = NULL, method = NULL, outputData = TRUE,
info = T, ...){
message('used for showing the spatial map for parameters like precipitation.
different method are provided for analysing the parameters
catchment needs shape file
points needs data.frame, with colume "name, lon, lat, z, value" in data.frame()
method = NULL means no method calculated on the cell')
#range of the dataset just loaded
lon <- dataset$xyCoords$x
lat <- dataset$xyCoords$y
startTime <- as.POSIXlt(dataset$Dates$start,tz = 'GMT')
yearIndex <- startTime$year + 1900
monthIndex <-startTime$mon + 1
data <- dataset$Data
if (is.null(method)){
#in case the dataset is ready to plot and no need to calculate
}else if(method == 'meanAnnual'){
#mean value of the annual precipitation over the period of the data
#time <- proc.time()
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex,  method = 'meanAnnualPreci')
#newTime <- proc.time() - time
title  <- 'Mean Annual Precipitation (mm / year)'
}else if(method == 'winter'){
#mean value of the seasonal precipitation, in this case, winter
#time <- proc.time()
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'winter')
#newTime <- proc.time() - time
title <- 'Mean Winter Precipitation (mm / winter)'
}else if(method == 'spring'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'spring')
title <- 'Mean Spring Precipitation (mm / spring)'
}else if (method == 'summer'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'summer')
title <- 'Mean Summer Precipitation (mm / summer)'
}else if (method == 'autumn'){
data_new <- apply(data, MARGIN = c(2,3), FUN = getMeanPreci, yearIndex = yearIndex, monthIndex = monthIndex,
method = 'autumn')
title <- 'Mean Autumn Precipitation (mm / autumn)'
}else if(method == 'mean'){
#sum value of the dataset, this procedure is to get the mean value
data_new <- apply(data, MARGIN = c(2,3), FUN = mean)
}else if(method == 'max'){
data_new <- apply(data, MARGIN = c(2,3), FUN = max)
}else if(method == 'min'){
data_new <- apply(data, MARGIN = c(2,3), FUN = min)
}else{
wrongMethod <- method
stop (paste('no method called',wrongMethod))
}
if (info == T) {
plotMax <- round(max(data_new,na.rm=TRUE),2)
plotMin <- round(min(data_new,na.rm=TRUE),2)
plotMean <- round(mean(data_new,na.rm=TRUE),2)
plotMedian <- round(median(data_new,na.rm=T),2)
word <- paste('\n\n', paste('Max','=',plotMax), ',', paste('Min','=',plotMin), ',',
paste('Mean','=',plotMean), ',', paste('Median', '=', plotMedian))
}else{
word <- NULL
}
x_word <- paste('Longitude', word)
#set names for the matrix, in order to be better converted later in ggplot.
colnames(data_new) <- round(lon,2)
rownames(data_new) <- round(lat,2)
world_map <- ggplot2::map_data('world')
#ggplot
#for the aes option in ggplot, it's independent from any other command through all ggplot, and aes() function
#get data from the main dataset, in this case, data_ggplot. for other functions in ggplot, if it wants to use
#data from the main dataset as parameters, it has to use aes() function. if not, it has to use data available
#in the environment.
#in other words, all the parameters in aes(), they have to come from the main dataset. Otherwise, just put them
#outside aes() as normal parameters.
data_ggplot <- reshape2::melt(data_new, na.rm = T)
colnames(data_ggplot) <- c('lat', 'lon', 'value')
theme_set(theme_bw())
mainLayer <- ggplot(data = data_ggplot)+
geom_tile(aes(x=lon,y=lat,fill = value))+
scale_fill_gradientn(colours = c('yellow', 'orange', 'red'), na.value = 'transparent', ...)+#usually scale = 'sqrt'
geom_map(data = world_map, map = world_map, aes(map_id = region), fill='transparent', color='black')+
guides(fill = guide_colorbar(title='Rainfall (mm)', barheight = 15))+
xlab(x_word)+
ylab('Latitude')+
ggtitle(title)+
theme(plot.title=element_text(size=20, face='bold'),
axis.title.x=element_text(size = 18),
axis.title.y = element_text(size = 18))
#     geom_rect(xmin=min(lon)+0.72*(max(lon)-min(lon)),
#               xmax=min(lon)+0.99*(max(lon)-min(lon)),
#               ymin=min(lat)+0.02*(max(lat)-min(lat)),
#               ymax=min(lat)+0.28*(max(lat)-min(lat)),
#               fill='white',colour='black')+
#   annotate('text', x = min(lon), y = min(lat), label=word, hjust = 0, vjust = -1)
printLayer <- mainLayer
#catchment conversion
if(is.null(catchment) == FALSE){
a <- catchment
a@data$id <- rownames(a@data)
b <- fortify(a,region='id')
c <- plyr::join(b,a@data,by='id')
catchmentLayer <- geom_polygon(data=c, aes(long,lat,group=group), color='black', fill='transparent')
printLayer <- printLayer + catchmentLayer
}
if(is.null(points) == FALSE){
pointLayer <- geom_point(data = points,aes(x = lon, y = lat, size = value, colour = z))
printLayer <- printLayer + pointLayer
}
print (printLayer)
if(outputData == TRUE) return(data_new)
}
a <- getSpatialMap(b, me = 'meanAnnual', trans = 'sqrt')
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::build()
devtools::install_github('Yuanchao-Xu\hyfo')
devtools::install_github('Yuanchao-Xu/hyfo')
? getSpatialMap
?getSpatialMap
??getSpatialMap
loginECOMS_UDG("ber","AgernAlle5")#log in the forecast data
require(ecomsUDG.Raccess)#for loading online forcast data
loginECOMS_UDG("ber","AgernAlle5")#log in the forecast data
devtools::install_github('Yuanchao-Xu/hyfo')
library(hyfo)
filePath
filePath <- file.choose()
b <- loadGridData(filePath, "pr", year = 1950:2015,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
b <- loadGridData(filePath, "pr", year = 1950:2007,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
b <- loadGridData(filePath, "pr", year = 1999:2007,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
b <- loadGridData(filePath, "pr", year = NULL,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
require(ecomsUDG.Raccess)#for loading online forcast data
library(hyfo)
filePath <- file.choose()
b <- loadGridData(filePath, "pr", year = NULL,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
require(downscaleR)
b <- loadGridData(filePath, "pr", year = NULL,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
b <- loadGridData(filePath, "pr", year = 1950:1980,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
b <- loadGridData(filePath, "pr", year = 1950:1990,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
b <- loadGridData(filePath, "pr", year = 1950:2000,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
library(rJava)
b <- loadGridData(filePath, "pr", year = 1950:2000,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
trace()
traceback()
b <- loadGridData(filePath, "pr", year = 1950:2000,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
require(ecomsUDG.Raccess)#for loading online forcast data
filePath <- file.choose()
b <- loadGridData(filePath, "pr", year = NULL,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
find.java <- function() {
for (root in c("HLM", "HCU")) for (key in c("Software\\JavaSoft\\Java Runtime Environment",
"Software\\JavaSoft\\Java Development Kit")) {
hive <- try(utils::readRegistry(key, root, 2),
silent = TRUE)
if (!inherits(hive, "try-error"))
return(hive)
}
hive
}
find.java()
b <- loadGridData(filePath, "pr", year = NULL,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
?loadECOMS
??loadECOMS
??loadGridData
require(ecomsUDG.Raccess)#for loading online forcast data
source("C:\\DHI_Projects\\11811405\\Seasonal_Forecasting\\R\\Data_Analysis\\Main.R")
filePath <- file.choose()
b <- loadGridData(filePath, "pr", year = NULL,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
b <- loadGridData(filePath, "pr", year = NULL,latLim= c(36,43.8) , lonLim=c(0.1,4.4) , season = NULL, dictionary=FALSE)
b <- loadGridData(filePath, "pr", year = NULL,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
install.packages('rJava')
install.packages("rJava")
require(ecomsUDG.Raccess)#for loading online forcast data
b <- loadGridData(filePath, "pr", year = NULL,latLim= c(36,43.8) , lonLim=c(-9.2,4.4) , season = NULL, dictionary=FALSE)
library(hyfo)
hyfo::getMeanPreci(b, method = 'meanAnnual')
hyfo::getSpatialMap(b, method = 'meanAnnual')
hyfo::getSpatialMap(b, method = 'meanAnnual', limits = c(1500, 1600))
