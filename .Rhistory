#' 2. Mean monthly precipitation of different dataset. e.g., long term mean monthly precipitation
#' and short term mean monthly precipitation. They are both mean monthly precipitation.
#'
#' @param nrow A number showing the number of rows.
#' @param list If input is a list containing different ggplot data, use l\code{list = inputlist}.
#' @return A combined barplot.
#' @example
#' data(gridData)# the result of loadGridData{ecomsUDG.Raccess}
#' #output type of getPreciBar() has to be 'ggplot'.
#' b1 <- getPreciBar(gridData, method = 2, output = 'ggplot')
#' b2 <- getPreciBar(gridData, method = 3, output = 'ggplot')
#'
#' getPreciBar_comb(b1, b2)
#'
#' @export
#' @import ggplot2
getPreciBar_comb <- function(..., list = NULL, nrow = 1){
if(!is.null(list)){
data_ggplot <- do.call('rbind', list)
}else{
bars <- list(...)
data_ggplot <- do.call('rbind', bars)
}
data_ggplot$Name <- factor(data_ggplot$Name, levels = data_ggplot$Name, ordered = TRUE)
theme_set(theme_bw())
mainLayer <- ggplot(data_ggplot)+
geom_bar(aes(x = Index, y = Preci, fill = Name), stat = 'identity', colour = 'black', width = .6)+
facet_wrap( ~ Name, nrow = nrow)
print (mainLayer)
}
devtools::document()
gridData
datalist
data(datalist)
str(datalist)
names(datalist)
name(datalist)
names(datalist)
names(datalist) <- c('AAA','BBB','CCC')
str(datalist)
devtools::use_data(datalist, overwrite = T)
str(datalist)
data(gridData)
str(gridData)
devtools::document()
devtools::check()
devtools::document()
gridData
devtools::document()
devtools::document()
devtools::document()
devtools::document()
getSpatialMap
getSpatialMap(gridData, method = 'mean')
devtools::document()
hyfo::datalist
devtools::document()
devtools::document()
devtools::document()
devtools::build()
data(datalist)
data(gridData)
datalist
gridData
devtools::use_data(datalist, gridData)
devtools::document()
devtools::document()
getSpatialMap(gridData, method = 'meanAnnual')
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
data(datalist)
TS  <- datalist[[1]][, 2]
year = as.numeric(format(TS[, 1], '%Y'))
TS[,1]
TS
TS  <- datalist[[1]]
year = as.numeric(format(TS[, 1], '%Y'))
devtools::document()
devtools::check()
a <- getAnnual(datalist)
b <- getAnnual(datalist, output = 'mean', minRecords = 350)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
Depends: R (>= 3.0.1)
Depends: R (>= 3.0.1)
devtools::document()
devtools::document()
devtools::document()
sessioninfo(pack = NULL)
sessionInfo(pack = NULL)
sessionInfo(pack = ggplot2)
sessionInfo(pack = 'ggplot2')
devtools::document()
devtools::document()
devtools::document()
devtools::check()
file <- system.file("extdata", "cat.shp", package = "hyfo")
catchment <- shp2cat(file)
file
devtools::document()
devtools::document()
catchment <- shp2cat(file)
debug(shp2cat)
catchment <- shp2cat(file)
catName
catName1
folderName
catName2
catName1
filePath <- file.choose()
filePath
filePath
filePath <- "C:\\data\\hyfo\\inst\\extdata\\cat.shp"
catName <- tail(strsplit(filePath,'\\\\')[[1]], 1)#needs to be four \, caused by some window system problem
catName1 <- strsplit(catName, '\\.')[[1]][1]
catName2 <- paste('\\\\', catName, sep = '')
folderName <- strsplit(filePath, catName2)[[1]]
folderName
catName
catName1
filePath <- "C:/data/hyfo/inst/extdata/cat.shp"
catName <- tail(strsplit(filePath,'\/')[[1]], 1)#needs to be four \, caused by some window system problem
catName <- tail(strsplit(filePath,'/')[[1]], 1)#needs to be four \, caused by some window system problem
catName
catName1 <- strsplit(catName, '\\.')[[1]][1]
catName1
catName2 <- paste('/', catName, sep = '')
catName2
filePath
folderName <- strsplit(filePath, catName2)[[1]]
folderName
devtools::document()
file <- system.file("extdata", "cat.shp", package = "hyfo")
catchment <- shp2cat(file)
file
grepl('/', filePath)
grepl('/', file)
#' Get a catchment object from selected shape file.
#' @param filePath A string representing the path of the shape file.
#' @return A catchment object can be used in \code{getSpatialMap()}.
#' @export
#' @examples
#' #open internal file
#' file <- system.file("extdata", "cat.shp", package = "hyfo")
#' catchment <- shp2cat(file)
#'
#' @import rgdal
shp2cat <- function(filePath){
#if the path <- file.choose(), the seperator is '\\'
if (grepl('\\', filePath)) {
catName <- tail(strsplit(filePath,'\\\\')[[1]], 1)#needs to be four \, caused by some window system problem
catName1 <- strsplit(catName, '\\.')[[1]][1]
catName2 <- paste('\\\\', catName, sep = '')
folderName <- strsplit(filePath, catName2)[[1]]
n <- list.files(folderName, pattern = catName1)
if(length(n) == 1) stop ('Please place the shp file in the folder containing
full related files, not only the shape file')
#the other seperator is '/'
}else if (grepl('/', filePath)){
catName <- tail(strsplit(filePath,'/')[[1]], 1)#needs to be four \, caused by some window system problem
catName1 <- strsplit(catName, '.')[[1]][1]
catName2 <- paste('/', catName, sep = '')
folderName <- strsplit(filePath, catName2)[[1]]
n <- list.files(folderName, pattern = catName1)
if(length(n) == 1) stop ('Please place the shp file in the folder containing
full related files, not only the shape file')
}
catchment <- readOGR(folderName, catName1)
return (catchment)
}
#' Get a catchment object from selected shape file.
#' @param filePath A string representing the path of the shape file.
#' @return A catchment object can be used in \code{getSpatialMap()}.
#' @export
#' @examples
#' #open internal file
#' file <- system.file("extdata", "cat.shp", package = "hyfo")
#' catchment <- shp2cat(file)
#'
#' @import rgdal
shp2cat <- function(filePath){
#if the path <- file.choose(), the seperator is '\\'
if (grepl('\\', filePath)) {
catName <- tail(strsplit(filePath,'\\\\')[[1]], 1)#needs to be four \, caused by some window system problem
catName1 <- strsplit(catName, '\\.')[[1]][1]
catName2 <- paste('\\\\', catName, sep = '')
folderName <- strsplit(filePath, catName2)[[1]]
n <- list.files(folderName, pattern = catName1)
if(length(n) == 1) stop ('Please place the shp file in the folder containing
full related files, not only the shape file')
#the other seperator is '/'
}else if (grepl('/', filePath)){
catName <- tail(strsplit(filePath,'/')[[1]], 1)#needs to be four \, caused by some window system problem
catName1 <- strsplit(catName, '\\.')[[1]][1]
catName2 <- paste('/', catName, sep = '')
folderName <- strsplit(filePath, catName2)[[1]]
n <- list.files(folderName, pattern = catName1)
if(length(n) == 1) stop ('Please place the shp file in the folder containing
full related files, not only the shape file')
}
catchment <- readOGR(folderName, catName1)
return (catchment)
}
catchment <- shp2cat(file)
debug(shp2cat)
catchment <- shp2cat(file)
catchment <- shp2cat(file)
grepl('\\', filePath
)
grepl('\\', filePath)
filePath <- file.choose()
grepl('\\', filePath)
grepl('\\\\', filePath)
#' Get a catchment object from selected shape file.
#' @param filePath A string representing the path of the shape file.
#' @return A catchment object can be used in \code{getSpatialMap()}.
#' @export
#' @examples
#' #open internal file
#' file <- system.file("extdata", "cat.shp", package = "hyfo")
#' catchment <- shp2cat(file)
#'
#' @import rgdal
shp2cat <- function(filePath){
#if the path <- file.choose(), the seperator is '\\'
if (grepl('\\\\', filePath)) {
catName <- tail(strsplit(filePath,'\\\\')[[1]], 1)#needs to be four \, caused by some window system problem
catName1 <- strsplit(catName, '\\.')[[1]][1]
catName2 <- paste('\\\\', catName, sep = '')
folderName <- strsplit(filePath, catName2)[[1]]
n <- list.files(folderName, pattern = catName1)
if(length(n) == 1) stop ('Please place the shp file in the folder containing
full related files, not only the shape file')
#the other seperator is '/'
}else if (grepl('/', filePath)){
catName <- tail(strsplit(filePath,'/')[[1]], 1)#needs to be four \, caused by some window system problem
catName1 <- strsplit(catName, '\\.')[[1]][1]
catName2 <- paste('/', catName, sep = '')
folderName <- strsplit(filePath, catName2)[[1]]
n <- list.files(folderName, pattern = catName1)
if(length(n) == 1) stop ('Please place the shp file in the folder containing
full related files, not only the shape file')
}
catchment <- readOGR(folderName, catName1)
return (catchment)
}
file <- system.file("extdata", "cat.shp", package = "hyfo")
catchment <- shp2cat(file)
library(rgdal)
catchment <- shp2cat(file)
testCat <- catchment
devtools::use_data(testCat)
file
file <- file.choose()
catchment <- shp2cat(file)
file
data(testCat)
getSpatialMap(gridData, method = 'winter', catchment = testCat)
file <- file.choose()
a <- read.table(file, header = T)
a
str(a)
a <- read.table(file, header = T, sep = ',')
a
points <- system.file("extdata", "points", package = "hyfo")
getSpatialMap(gridData, method = 'winter', catchment = testCat, points = points)
points
points <- system.file("extdata", "points", package = "hyfo")
points
points <- system.file("extdata", "points.txt", package = "hyfo")
points
points <- read.table(file, header = TRUE, sep = ',' )
getSpatialMap(gridData, method = 'winter', catchment = testCat, points = points)
points
file <- system.file("extdata", "points.txt", package = "hyfo")
points <- read.table(file, header = TRUE, sep = ',' )
getSpatialMap(gridData, method = 'winter', catchment = testCat, points = points)
devtools::document()
devtools::check()
file <- system.file("extdata", "cat.shp", package = "hyfo")
file
#' Get a catchment object from selected shape file.
#' @param filePath A string representing the path of the shape file.
#' @return A catchment object can be used in \code{getSpatialMap()}.
#' @export
#' @examples
#' #open internal file
#' file <- system.file("extdata", "cat.shp", package = "hyfo")
#' catchment <- shp2cat(file)
#'
#' @import rgdal
shp2cat <- function(filePath){
#if the path <- file.choose(), the seperator is '\\'
if (grepl('\\\\', filePath)) {
catName <- tail(strsplit(filePath,'\\\\')[[1]], 1)#needs to be four \, caused by some window system problem
catName1 <- strsplit(catName, '\\.')[[1]][1]
catName2 <- paste('\\\\', catName, sep = '')
folderName <- strsplit(filePath, catName2)[[1]]
n <- list.files(folderName, pattern = catName1)
if(length(n) == 1) stop ('Please place the shp file in the folder containing
full related files, not only the shape file')
#the other seperator is '/'
}else if (grepl('/', filePath)){
catName <- tail(strsplit(filePath,'/')[[1]], 1)#needs to be four \, caused by some window system problem
catName1 <- strsplit(catName, '\\.')[[1]][1]
catName2 <- paste('/', catName, sep = '')
folderName <- strsplit(filePath, catName2)[[1]]
n <- list.files(folderName, pattern = catName1)
if(length(n) == 1) stop ('Please place the shp file in the folder containing
full related files, not only the shape file')
}
if (length(folderName) == 0) stop ('No shape file found, make sure the shp file is selected.')
catchment <- readOGR(folderName, catName1)
return (catchment)
}
file <- system.file("extdata", "testCat.shp", package = "hyfo")
devtools::document()
devtools::check()
devtools::document()
devtools::check()
data(testCat
ï¼‰
str(testCat)
devtools::document()
devtools::check()
file <- system.file("extdata", "1999.csv", package = "hyfo")
file
system.folder()
system.dir()
?read.xlsx
file
file <- system.file("extdata", "1999.txt", package = "hyfo")
file
strsplit(file, '1999')
strsplit(file, '1999')[1]
strsplit(file, '1999')[[1]]
strsplit(file, '1999')[[1]][1]
folder <- strsplit(file, '1999')[[1]][1]
folder
cellectData(folder, fileType = 'txt')
#' Collect data from different csv files.
#' @param folderName A string showing the path of the folder holding different csv files.
#' @param fileType A string showing the file type, e.g. "txt", "csv", "excel".
#' @param range A vector containing startRow, endRow, startColumn, endColumn, e.g.,
#' c(2,15,2,3)
#' @param sheetIndex A number showing the sheetIndex in the excel file, if fileType is excel,
#' sheetIndex has to be provided, default is 1.
#' @return The collected data from different files in the folder.
#' @examples
#'
#' #use internal data as an example.
#' file <- system.file("extdata", "1999.txt", package = "hyfo")
#' folder <- strsplit(file, '1999')[[1]][1]
#'
#' @export
collectData <- function(folderName, fileType = NULL, range = NULL, sheetIndex = 1){
message ('All the files in the folder should have the same format')
if (is.null(fileType)) stop ('Please enter fileType, "txt", "csv" or "excel".')
if(length(range) > 4){
stop ('"range" should be c(startRow, endRow, startCol, endCol)')
}else if (is.null(range)){
stop('"range" can not be blank, e.g., range <- c(startRow, endRow, startCol, endCol).')
}
if (fileType == 'csv') {
fileNames <- list.files(folderName, pattern = '*.csv', full.names = TRUE)
if (length(fileNames) == 0) stop ('No csv file in the folder.')
data <- lapply(fileNames, readCsv, range = range)
data <- do.call('rbind', data)
}else if (fileType == 'txt'){
fileNames <- list.files(folderName, pattern = '*.txt', full.names = TRUE)
if (length(fileNames) == 0){
fileNames <- list.files(folderName, pattern = '*.TXT', full.names = TRUE)
}
if (length(fileNames) == 0) stop ('No text file in the folder.')
message ('For txt file, only startRow and endRow will be considered.')
data <- lapply(fileNames, readTxt, range = range)
data <- unlist(data)
}else if (fileType == 'excel'){
fileNames <- list.files(folderName, pattern = '*.xlsx', full.names = TRUE)
if (length(fileNames) == 0){
fileNames <- list.files(folderName, pattern = '*.xls', full.names = TRUE)
}
if (length(fileNames) == 0) stop ('No excel in the folder.')
data <- lapply(fileNames, readExcel, range = range, sheetIndex = sheetIndex)
checkBind(data, 'rbind')
data <- do.call('rbind', data)
}else{
stop ('fileType should be "txt", "csv" or "excel".')
}
return (data)
}
readExcel <- function(fileName, range, sheetIndex){
data <- xlsx::read.xlsx(fileName, sheetIndex = sheetIndex, rowIndex = seq(range[1], range[2]),
colIndex = seq(range[3], range[4]))
colnames(data) <- seq(1, dim(data)[2])
message (fileName)
return (data)
}
readTxt <- function(fileName, range){
data <- readLines(fileName)
data <- data[range[1]:range[2]]
return (data)
}
readCsv <- function(fileName, range){
data <- read.csv(fileName, skip = range[1] - 1, header = FALSE)
data <- data[1:(range[2] - range[1] + 1), range[3]:range[4]]
return (data)
}
cellectData(folder, fileType = 'txt')
cellectData(folder, fileType = 'txt')
#' Collect data from different csv files.
#' @param folderName A string showing the path of the folder holding different csv files.
#' @param fileType A string showing the file type, e.g. "txt", "csv", "excel".
#' @param range A vector containing startRow, endRow, startColumn, endColumn, e.g.,
#' c(2,15,2,3)
#' @param sheetIndex A number showing the sheetIndex in the excel file, if fileType is excel,
#' sheetIndex has to be provided, default is 1.
#' @return The collected data from different files in the folder.
#' @examples
#'
#' #use internal data as an example.
#' file <- system.file("extdata", "1999.txt", package = "hyfo")
#' folder <- strsplit(file, '1999')[[1]][1]
#'
#' @export
collectData <- function(folderName, fileType = NULL, range = NULL, sheetIndex = 1){
message ('All the files in the folder should have the same format')
if (is.null(fileType)) stop ('Please enter fileType, "txt", "csv" or "excel".')
if(length(range) > 4){
stop ('"range" should be c(startRow, endRow, startCol, endCol)')
}else if (is.null(range)){
stop('"range" can not be blank, e.g., range <- c(startRow, endRow, startCol, endCol).')
}
if (fileType == 'csv') {
fileNames <- list.files(folderName, pattern = '*.csv', full.names = TRUE)
if (length(fileNames) == 0) stop ('No csv file in the folder.')
data <- lapply(fileNames, readCsv, range = range)
data <- do.call('rbind', data)
}else if (fileType == 'txt'){
fileNames <- list.files(folderName, pattern = '*.txt', full.names = TRUE)
if (length(fileNames) == 0){
fileNames <- list.files(folderName, pattern = '*.TXT', full.names = TRUE)
}
if (length(fileNames) == 0) stop ('No text file in the folder.')
message ('For txt file, only startRow and endRow will be considered.')
data <- lapply(fileNames, readTxt, range = range)
data <- unlist(data)
}else if (fileType == 'excel'){
fileNames <- list.files(folderName, pattern = '*.xlsx', full.names = TRUE)
if (length(fileNames) == 0){
fileNames <- list.files(folderName, pattern = '*.xls', full.names = TRUE)
}
if (length(fileNames) == 0) stop ('No excel in the folder.')
data <- lapply(fileNames, readExcel, range = range, sheetIndex = sheetIndex)
checkBind(data, 'rbind')
data <- do.call('rbind', data)
}else{
stop ('fileType should be "txt", "csv" or "excel".')
}
return (data)
}
readExcel <- function(fileName, range, sheetIndex){
data <- xlsx::read.xlsx(fileName, sheetIndex = sheetIndex, rowIndex = seq(range[1], range[2]),
colIndex = seq(range[3], range[4]))
colnames(data) <- seq(1, dim(data)[2])
message (fileName)
return (data)
}
readTxt <- function(fileName, range){
data <- readLines(fileName)
data <- data[range[1]:range[2]]
return (data)
}
readCsv <- function(fileName, range){
data <- read.csv(fileName, skip = range[1] - 1, header = FALSE)
data <- data[1:(range[2] - range[1] + 1), range[3]:range[4]]
return (data)
}
collectData(folder, fileType = 'txt')
collectData(folder, fileType = 'txt', range = c(5,9,5,9))
collectData(folder, fileType = 'txt', range = c(10, 20, 1,5))
collectData(folder, fileType = 'txt', range = c(40, 50, 1,5))
debug(collectData)
collectData(folder, fileType = 'txt', range = c(40, 50, 1,5))
data
collectData(folder, fileType = 'txt', range = c(10, 20, 1,2))
collectData(folder, fileType = 'csv', range = c(10, 20, 1,2))
a <- collectData_csv_anarbe(folder, fileType = 'csv', range = c(10, 20, 1,2))
a <- collectData_csv_anarbe(folder)
collectData(folder, fileType = 'csv', range = c(10, 20, 1,2))
a
a <- collectData_csv_anarbe(folder)
a <- collectData_txt_anarbe(folder)
a
head(a)
devtools::document()
devtools::check()
devtools::build()
