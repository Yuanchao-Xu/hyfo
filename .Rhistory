#' b1 <- fillGap(b) # if corPeriod is missing, 'daily' is taken as default.
#'
#' data(testdl)
#' a <- extractPeriod(testdl, commonPeriod = TRUE)
#' a1 <- list2Dataframe(a)
#' a2 <- fillGap(a1)
#'
#' @references
#' Gap fiiling method based on correlation and linear regression.
#' @export
fillGap <- function(dataset, corPeriod = 'daily'){
if (!grepl('-|/', dataset[1, 1])) {
stop ('First column is not date or Wrong Date formate, check the format in ?as.Date{base}
and use as.Date to convert.')
}
Date <- as.Date(dataset[, 1])
data <- data.frame(dataset[, 2:dim(dataset)[2]])
names <- colnames(data)
corN <- fillGap_cor(data, corPeriod = corPeriod, Date = Date)
cat('\nCorrelation Coefficient\n')
print(corN)
corOrder <- apply(corN, MARGIN = 1, FUN = function(x) order(-x))
corOrder <- corOrder[2:dim(corOrder)[1], ]
corOrderName <- t(apply(corOrder, MARGIN = 2, FUN = function(x) names[x]))
cat ('\nCorrelation Order\n')
colnames(corOrderName) <- seq(1 : dim(corOrderName)[2])
print (corOrderName)
lmCoef <- fillGap_lmCoef(data, corOrder)
cat ('\nLinear Coefficients\n')
rownames(lmCoef) <- seq(1 : dim(corOrderName)[2])
print (t(lmCoef))
output <- lapply(1:dim(data)[2], fillGap_column, data = data,
corOrder = corOrder, lmCoef = lmCoef)
output <- data.frame(output)
colnames(output) <- names
output <- cbind(Date, output)
return (output)
}
#' Get monthly rainfall
#'
#' @param TS A rainfall time series.
#' @param year A list showing the year index of the time series.
#' @param mon A list showing the mon index of the time series.
#' @return the monthly rainfall matrix of the rainfall time series.
#' @export
monthlyPreci <- function(TS, year, mon){
monTS <- tapply(TS, INDEX = list(year, mon), FUN = mean, na.rm = TRUE)
output <- t(monTS)
dim(output) <- c(dim(monTS)[1] * dim(monTS)[2], 1)
return (output)
}
fillGap_column <- function(i, data, corOrder, lmCoef){
TS <- data[, i] # extract target column
l <- dim(data)[2] # length
for (j in 1:l){
if (!any(is.na(TS))) break
NAindex <- which(is.na(TS))
TS[NAindex] <- round(lmCoef[j, i] * data[NAindex, corOrder[j, i]], 3)
if (j == l) stop ('Error: One time consists of all NA values')
}
return(TS)
}
#' @import stats
fillGap_cor <- function(data, corPeriod = 'daily', Date){
names <- colnames(data)
year <- format(Date, '%Y')
if (corPeriod == 'monthly'){
#based on monthly rainfall
mon <- format(Date, '%m')
monthlyPreci <- lapply(data, FUN = monthlyPreci, year = year, mon = mon)
corData <- do.call('cbind', monthlyPreci)
}else if (corPeriod == 'yearly'){
year <- format(Date, '%Y')
annualPreci <- lapply(data, FUN = function(x) tapply(x, INDEX = year, FUN = mean, na.rm = TRUE))
corData <- do.call('cbind', annualPreci)
}else if (corPeriod == 'daily'){
corData <- data
}else{
stop ('Pleas choose among "daily", "monthly", "yearly".')
}
corData <- data.frame(na.omit(corData))
colnames(corData) <- names
corN <- cor(corData)
return (corN)
}
fillGap_lmCoef <- function(data, corOrder){
l <- dim(data)[2]
m <- diag(l)# m is the coeficients matrix
m[lower.tri(m)] <- combn(data, 2, function(x) coef(lm(x[, 2] ~ x[, 1] + 0)))
tm <- t(m)
tm[lower.tri(tm)] <- combn(data, 2, function(x) coef(lm(x[, 1] ~ x[, 2] + 0)))
m <- t(tm)
lmCoef <- lapply(1 : l, function(x) m[x,corOrder[, x]])
lmCoef <- do.call('rbind', lmCoef)
rownames(lmCoef) <- colnames(data)
return(t(lmCoef))
}
debug(fillGap)
df_filled <- fillGap(df, corPeriod = 'yearly')
q
df_filled <- fillGap(df, corPeriod = 'monthly)
df_filled <- fillGap(df, corPeriod = 'monthly')
df_filled <- fillGap(df, corPeriod = 'monthly')
mon
monTS
output
output
monthlyPreci
corData
corData
data
str(data)
corData
corN
df_filled <- fillGap(df, corPeriod = 'yearly')
df_filled <- fillGap(df, corPeriod = 'yearly')
undebug(fillGap)
df_filled <- fillGap(df, corPeriod = 'yearly')
head(df_filled)
df_filled <- fillGap(df, corPeriod = 'monthly')
head(df_filled)
TS  <- testdl[[1]]
TS
year = as.numeric(format(TS[, 1], '%Y'))
month = as.numeric(format(TS[, 1], '%m'))
inputTS <- TS
yearIndex <- year
monthIndex <- month
method <- 9
is.numeric(method)
methodIndex <- which(monthIndex == method)
methodIndex
omitNA <- T
methodPreci <- tapply(inputTS, INDEX = methodIndex, FUN = sum, na.rm = omitNA)
inputTS <- inputTS[methodIndex]
methodIndex
inputTS
inputTS <- inputTS[, 2]
inputTS
inputTS <- inputTS[methodIndex]
inputTS
month <- method
monthlyPreci <- tapply(TS, INDEX = list(yearIndex, monthIndex), FUN = sum)[, month]
yearIndex
monthIndex
TS
inputTS <- TS[, 2]
monthlyPreci <- tapply(TS, INDEX = list(yearIndex, monthIndex),
FUN = sum, na.rm = omitNA)[, month]
length(TS)
inputTS
length(inputTS)
length(yearIndex)
length(monthIndex)
monthlyPreci <- tapply(inputTS, INDEX = list(yearIndex, monthIndex),
FUN = sum, na.rm = omitNA)[, month]
monthlyPreci
tapply(inputTS, INDEX = list(yearIndex, monthIndex),
FUN = sum, na.rm = omitNA)
tapply(inputTS, INDEX = list(monthIndex, yearIndex),
FUN = sum, na.rm = omitNA)
monthlyPreci
month
#' Get mean rainfall data, e.g. mean annual rainfall, mean monthly rainfall and mean winter rainfall.
#'
#' @param inputTS A time series with only data column (1 column).
#' @param method A string showing the method used to calculate mean value, e.g., "meanAnnualPreci".
#' more information please refer to details.
#' @param yearIndex A numeric list showing the year index of the time series.
#' @param monthIndex A numeric list showing the month index of the time series.
#' @param fullResults A boolean showing whether the full results are shown, default is FALSE. If
#' FALSE, only mean value will be returned, if TRUE, the sequence of values will be returned.
#' @param omitNA in the calculation, whether NA is omitted, default is FALSE.
#' @details
#' there are following methods to be selected, "meanAnnualPreci", "winter", "spring", "autumn", "summer".
#' @return The mean value of the input time series or the full results before calculating mean.
#' @examples
#' data(testdl)
#' TS  <- testdl[[1]]
#' year = as.numeric(format(TS[, 1], '%Y'))
#' month = as.numeric(format(TS[, 1], '%m'))
#'
#' a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month)
#' a <- getMeanPreci(TS[, 2], method = 'winter', yearIndex = year, monthIndex = month, omitNA = TRUE,
#' fullResults = TRUE)
#'
#'
#' @export
getMeanPreci <- function(inputTS, method = NULL, yearIndex = NULL, monthIndex = NULL,
fullResults = FALSE, omitNA = FALSE){
#converting daily preci to the wanted preci.
if(method == 'meanAnnualPreci'){
###yearIndex <- startTime$year + 1900
annualPreci <- tapply(inputTS, INDEX = yearIndex, FUN = sum, na.rm = omitNA)#ggplot is able not to show NA, so choose TRUE
if(fullResults == TRUE) output <- annualPreci else output <- mean(annualPreci)
}else if(method == 'winter'){
#winter is the most tricky part, because it starts from Dec to Feb next year, it's a year-crossing season,
#so we have to make some changes to the monthIndex
#e.g.data from 1950.1.1 - 2008.3.31 if we want to calculate the mean winter preci, to calculate winter month
#December, we have to move the yearIndex one month forwards or two months backwards, to make 12,1,2 in one year
###yearIndex <- startTime$year + 1900
###monthIndex <- startTime$mon + 1
#we move the yearIndex one month backwards
yearIndex_new <- c(yearIndex[32:length(yearIndex)], rep(tail(yearIndex, 1), 31))
winterIndex <- which(monthIndex == 12 | monthIndex == 1 | monthIndex == 2)
winterYear <- yearIndex_new[winterIndex]#this index is used for calculation
#because we don't have 1949.Dec, so the first winter is not intact, so first two months are elemenated
startIndex <- length(which(winterYear == yearIndex[1])) + 1
winterOfLastYear <- length(which(winterYear == tail(yearIndex, 1)))
if (winterOfLastYear > 91) {
endIndex <- length(winterYear) - 31 #in case the data set ends at Dec.31
}else if (winterOfLastYear < 90){ # incase the data ends at Jan 31
endIndex <- length(winterYear) - length(which(winterYear == tail(yearIndex, 1)))
}else{
endIndex <- length(winterYear)
}
inputTS <- inputTS[winterIndex][startIndex:endIndex]#needs two process with inputPreci, first, extract
#the winter preci, second, delete first two month of 1950
winterYear <- winterYear[startIndex:endIndex]#needs one process, delete two months
seasonalPreci <- tapply(inputTS,INDEX = winterYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)
}else if (method == 'spring'){
springIndex <- which(monthIndex == 3 | monthIndex == 4 | monthIndex == 5)
springYear <- yearIndex[springIndex]
inputTS <- inputTS[springIndex]
seasonalPreci <- tapply(inputTS, INDEX = springYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)
}else if (method == 'summer'){
summerIndex <- which(monthIndex == 6 | monthIndex == 7 | monthIndex == 8)
summerYear <- yearIndex[summerIndex]
inputTS <- inputTS[summerIndex]
seasonalPreci <- tapply(inputTS, INDEX = summerYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)
}else if (method == 'autumn'){
autumnIndex <- which(monthIndex == 9 | monthIndex == 10 | monthIndex == 11)
autumnYear <- yearIndex[autumnIndex]
inputTS <- inputTS[autumnIndex]
seasonalPreci <- tapply(inputTS, INDEX = autumnYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)
}else if (is.numeric(method)){
month <- method
monthlyPreci <- tapply(inputTS, INDEX = list(yearIndex, monthIndex),
FUN = sum, na.rm = omitNA)[, month]
if (fullResults == TRUE) output <- monthlyPreci else output <- mean(monthlyPreci)
}
return (output)
}
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month)
a
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month, full = T)
a
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month, full = T, omi = T)
a
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month, full = T)
debug(getMeanPreci)
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month, full = T)
springIndex
monthIndex
month = as.numeric(format(TS[, 1], '%m'))
month
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month)
a
a <- getMeanPreci(TS[, 2], method = 'winter', yearIndex = year, monthIndex = month, omitNA = TRUE,
fullResults = TRUE)
a
a <- getMeanPreci(TS[, 2], method = 'winter', yearIndex = year, monthIndex = month, full = T)
a
#' Get mean rainfall data, e.g. mean annual rainfall, mean monthly rainfall and mean winter rainfall.
#'
#' @param inputTS A time series with only data column (1 column).
#' @param method A string showing the method used to calculate mean value, e.g., "meanAnnualPreci".
#' more information please refer to details.
#' @param yearIndex A numeric list showing the year index of the time series.
#' @param monthIndex A numeric list showing the month index of the time series.
#' @param fullResults A boolean showing whether the full results are shown, default is FALSE. If
#' FALSE, only mean value will be returned, if TRUE, the sequence of values will be returned.
#' @param omitNA in the calculation, whether NA is omitted, default is FALSE.
#' @details
#' there are following methods to be selected, "meanAnnualPreci", "winter", "spring", "autumn", "summer".
#' @return The mean value of the input time series or the full results before calculating mean.
#' @examples
#' data(testdl)
#' TS  <- testdl[[1]]
#' year = as.numeric(format(TS[, 1], '%Y'))
#' month = as.numeric(format(TS[, 1], '%m'))
#'
#' a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month)
#' a <- getMeanPreci(TS[, 2], method = 'winter', yearIndex = year, monthIndex = month, omitNA = TRUE,
#' fullResults = TRUE)
#'
#'
#' @export
getMeanPreci <- function(inputTS, method = NULL, yearIndex = NULL, monthIndex = NULL,
fullResults = FALSE, omitNA = FALSE){
#converting daily preci to the wanted preci.
if(method == 'meanAnnualPreci'){
###yearIndex <- startTime$year + 1900
annualPreci <- tapply(inputTS, INDEX = yearIndex, FUN = sum, na.rm = omitNA)#ggplot is able not to show NA, so choose TRUE
if(fullResults == TRUE) output <- annualPreci else output <- mean(annualPreci)
}else if(method == 'winter'){
#winter is the most tricky part, because it starts from Dec to Feb next year, it's a year-crossing season,
#so we have to make some changes to the monthIndex
#e.g.data from 1950.1.1 - 2008.3.31 if we want to calculate the mean winter preci, to calculate winter month
#December, we have to move the yearIndex one month forwards or two months backwards, to make 12,1,2 in one year
###yearIndex <- startTime$year + 1900
###monthIndex <- startTime$mon + 1
#we move the yearIndex one month backwards
yearIndex_new <- c(yearIndex[32:length(yearIndex)], rep(tail(yearIndex, 1), 31))
winterIndex <- which(monthIndex == 12 | monthIndex == 1 | monthIndex == 2)
winterYear <- yearIndex_new[winterIndex]#this index is used for calculation
#because we don't have 1949.Dec, so the first winter is not intact, so first two months are elemenated
startIndex <- length(which(winterYear == yearIndex[1])) + 1
winterOfLastYear <- length(which(winterYear == tail(yearIndex, 1)))
if (winterOfLastYear > 91) {
endIndex <- length(winterYear) - 31 #in case the data set ends at Dec.31
}else if (winterOfLastYear < 90){ # incase the data ends at Jan 31
endIndex <- length(winterYear) - length(which(winterYear == tail(yearIndex, 1)))
}else{
endIndex <- length(winterYear)
}
inputTS <- inputTS[winterIndex][startIndex:endIndex]#needs two process with inputPreci, first, extract
#the winter preci, second, delete first two month of 1950
winterYear <- winterYear[startIndex:endIndex]#needs one process, delete two months
seasonalPreci <- tapply(inputTS,INDEX = winterYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)
}else if (method == 'spring'){
springIndex <- which(monthIndex == 3 | monthIndex == 4 | monthIndex == 5)
springYear <- yearIndex[springIndex]
inputTS <- inputTS[springIndex]
seasonalPreci <- tapply(inputTS, INDEX = springYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)
}else if (method == 'summer'){
summerIndex <- which(monthIndex == 6 | monthIndex == 7 | monthIndex == 8)
summerYear <- yearIndex[summerIndex]
inputTS <- inputTS[summerIndex]
seasonalPreci <- tapply(inputTS, INDEX = summerYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)
}else if (method == 'autumn'){
autumnIndex <- which(monthIndex == 9 | monthIndex == 10 | monthIndex == 11)
autumnYear <- yearIndex[autumnIndex]
inputTS <- inputTS[autumnIndex]
seasonalPreci <- tapply(inputTS, INDEX = autumnYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci)
}else if (is.numeric(method)){
month <- method
monthlyPreci <- tapply(inputTS, INDEX = list(yearIndex, monthIndex),
FUN = sum, na.rm = omitNA)[, month]
if (fullResults == TRUE) output <- monthlyPreci else output <- mean(monthlyPreci)
}
return (output)
}
a
a <- getMeanPreci(TS[, 2], method = 'winter', yearIndex = year, monthIndex = month, omitNA = TRUE)
a
a <- getMeanPreci(TS[, 2], method = 'winter', yearIndex = year, monthIndex = month, omitNA = TRUE, full = T)
mean(a, na.rm = T)
a
a <- getMeanPreci(TS[, 2], method = 'winter', yearIndex = year, monthIndex = month, omitNA = F, full = T)
a
mean(a, na.rm = T)
sum(NA,NA,NA)
sum(NA,NA,NA, na.rm = T)
is.na(NA,NA,NA)
is.na(c(NA,NA,NA))
any(!is.na(inputTS))
any(!is.na(c(NA,NA,NA,NA)))
any(!is.na(c(NA,NA,NA,NA)))
any(!is.na(c(NA,NA,NA,3)))
install.packages("lintr")
lintr::lint_package()
data(testdl)
TS  <- testdl[[1]]
year = as.numeric(format(TS[, 1], '%Y'))
month = as.numeric(format(TS[, 1], '%m'))
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month)
a
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month, full = TRUE)
a
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month, fullResults = TRUE)
a
a <- getMeanPreci(TS[, 2], method = 1, yearIndex = year, monthIndex = month, fullResults = TRUE)
a
a <- getMeanPreci(TS[, 2], method = 12, yearIndex = year, monthIndex = month, fullResults = TRUE)
a
getMeanPreci(TS[, 2], method = 10, yearIndex = year, monthIndex = month, fullResults = TRUE)
getMeanPreci(TS[, 2], method = 9, yearIndex = year, monthIndex = month, fullResults = TRUE)
getMeanPreci(TS[, 2], method = 10, yearIndex = year, monthIndex = month, fullResults = TRUE)
getMeanPreci(TS[, 2], method = 10, yearIndex = year, monthIndex = month, fullResults = TRUE, omi=T)
getMeanPreci(TS[, 2], method = 1, yearIndex = year, monthIndex = month, fullResults = TRUE, omi=T)
getMeanPreci(TS[, 2], method = 2, yearIndex = year, monthIndex = month, fullResults = TRUE, omi=T)
getMeanPreci(TS[, 2], method = 3, yearIndex = year, monthIndex = month, fullResults = TRUE, omi=T)
getMeanPreci(TS[, 2], method = 8, yearIndex = year, monthIndex = month, fullResults = TRUE, omi=T)
getMeanPreci(TS[, 2], method = 9, yearIndex = year, monthIndex = month, fullResults = TRUE, omi=T)
getMeanPreci(TS[, 2], method = 10, yearIndex = year, monthIndex = month, fullResults = TRUE, omi=T)
str(testdl)
data(testdl)
TS  <- testdl[[1]]
year = as.numeric(format(TS[, 1], '%Y'))
month = as.numeric(format(TS[, 1], '%m'))
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month, fullResults = TRUE)
a
data(testdl)
testdl
TS  <- testdl[[1]]
year = as.numeric(format(TS[, 1], '%Y'))
month = as.numeric(format(TS[, 1], '%m'))
# Get the mean spring precipitation.
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month)
a
# Get the series of spring precipitation, set fullResults = TRUE.
a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month,
fullResults = TRUE)
a
# If missing value is excluded, set omitNA = TRUE.
a <- getMeanPreci(TS[, 2], method = 'winter', yearIndex = year, monthIndex = month,
omitNA = TRUE, fullResults = TRUE)
a
# Get special month precipitation, e.g. march.
a <- getMeanPreci(TS[, 2], method = 3, yearIndex = year, monthIndex = month,
fullResults = TRUE)
a
#' Get mean rainfall data, e.g. mean annual rainfall, mean monthly rainfall and mean winter rainfall.
#'
#' @param inputTS A time series with only data column (1 column).
#' @param method A string showing the method used to calculate mean value, e.g., "meanAnnualPreci".
#' more information please refer to details.
#' @param yearIndex A numeric list showing the year index of the time series.
#' @param monthIndex A numeric list showing the month index of the time series.
#' @param fullResults A boolean showing whether the full results are shown, default is FALSE. If
#' FALSE, only mean value will be returned, if TRUE, the sequence of values will be returned.
#' @param omitNA in the calculation, whether NA is omitted, default is FALSE.
#' @details
#' there are following methods to be selected, "meanAnnualPreci", "winter", "spring", "autumn", "summer".
#' @return The mean value of the input time series or the full results before calculating mean.
#' @examples
#' data(testdl)
#' TS  <- testdl[[1]]
#' year = as.numeric(format(TS[, 1], '%Y'))
#' month = as.numeric(format(TS[, 1], '%m'))
#'
#' a <- getMeanPreci(TS[, 2], method = 'spring', yearIndex = year, monthIndex = month, fullResults = TRUE)
#'
#' # If missing value is included, set omitNA = TRUE.
#' a <- getMeanPreci(TS[, 2], method = 'winter', yearIndex = year, monthIndex = month, omitNA = TRUE,
#' fullResults = TRUE)
#'
#'
#' @export
getMeanPreci <- function(inputTS, method = NULL, yearIndex = NULL, monthIndex = NULL,
fullResults = FALSE, omitNA = FALSE) {
# First check if all the records are NA.
if (!is.na(inputTS)) {
#converting daily preci to the wanted preci.
if (method == 'meanAnnualPreci') {
###yearIndex <- startTime$year + 1900
annualPreci <- tapply(inputTS, INDEX = yearIndex, FUN = sum, na.rm = omitNA)#ggplot is able not to show NA, so choose TRUE
if (fullResults == TRUE) output <- annualPreci else output <- mean(annualPreci, na.rm = omitNA)
} else if (method == 'winter') {
#winter is the most tricky part, because it starts from Dec to Feb next year, it's a year-crossing season,
#so we have to make some changes to the monthIndex
#e.g.data from 1950.1.1 - 2008.3.31 if we want to calculate the mean winter preci, to calculate winter month
#December, we have to move the yearIndex one month forwards or two months backwards, to make 12,1,2 in one year
###yearIndex <- startTime$year + 1900
###monthIndex <- startTime$mon + 1
#we move the yearIndex one month backwards
yearIndex_new <- c(yearIndex[32:length(yearIndex)], rep(tail(yearIndex, 1), 31))
winterIndex <- which(monthIndex == 12 | monthIndex == 1 | monthIndex == 2)
winterYear <- yearIndex_new[winterIndex]#this index is used for calculation
#because we don't have 1949.Dec, so the first winter is not intact, so first two months are elemenated
startIndex <- length(which(winterYear == yearIndex[1])) + 1
winterOfLastYear <- length(which(winterYear == tail(yearIndex, 1)))
if (winterOfLastYear > 91) {
endIndex <- length(winterYear) - 31 #in case the data set ends at Dec.31
} else if (winterOfLastYear < 90) { # incase the data ends at Jan 31
endIndex <- length(winterYear) - length(which(winterYear == tail(yearIndex, 1)))
} else {
endIndex <- length(winterYear)
}
inputTS <- inputTS[winterIndex][startIndex:endIndex]#needs two process with inputPreci, first, extract
#the winter preci, second, delete first two month of 1950
winterYear <- winterYear[startIndex:endIndex]#needs one process, delete two months
seasonalPreci <- tapply(inputTS,INDEX = winterYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci, na.rm = omitNA)
} else if (method == 'spring') {
springIndex <- which(monthIndex == 3 | monthIndex == 4 | monthIndex == 5)
springYear <- yearIndex[springIndex]
inputTS <- inputTS[springIndex]
seasonalPreci <- tapply(inputTS, INDEX = springYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci, na.rm = omitNA)
} else if (method == 'summer') {
summerIndex <- which(monthIndex == 6 | monthIndex == 7 | monthIndex == 8)
summerYear <- yearIndex[summerIndex]
inputTS <- inputTS[summerIndex]
seasonalPreci <- tapply(inputTS, INDEX = summerYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci, na.rm = omitNA)
} else if (method == 'autumn') {
autumnIndex <- which(monthIndex == 9 | monthIndex == 10 | monthIndex == 11)
autumnYear <- yearIndex[autumnIndex]
inputTS <- inputTS[autumnIndex]
seasonalPreci <- tapply(inputTS, INDEX = autumnYear, FUN = sum, na.rm = omitNA)
if (fullResults == TRUE) output <- seasonalPreci else output <- mean(seasonalPreci, na.rm = omitNA)
} else if (is.numeric(method)) {
month <- method
monthlyPreci <- tapply(inputTS, INDEX = list(yearIndex, monthIndex),
FUN = sum, na.rm = omitNA)[, month]
if (fullResults == TRUE) output <- monthlyPreci else output <- mean(monthlyPreci, na.rm = omitNA)
}
} else {
output <- NA
}
return(output)
}
