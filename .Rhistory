#'
#' \item A. Amengual, V. Homar, R. Romero, S. Alonso, and C. Ramis (2012) A Statistical Adjustment of Regional Climate Model Outputs to Local Scales: Application to Platja de Palma, Spain. J. Clim., 25, 939-957
#'
#' \item C. Piani, J. O. Haerter and E. Coppola (2009) Statistical bias correction for daily precipitation in regional climate models over Europe, Theoretical and Applied Climatology, 99, 187-192
#'
#' \item O. Gutjahr and G. Heinemann (2013) Comparing precipitation bias correction methods for high-resolution regional climate simulations using COSMO-CLM, Theoretical and Applied Climatology, 114, 511-529
#' }
getBiasFactor_core <- function(hindcast, obs, method , scaleType, preci, prThreshold, extrapolate){
# If the variable is precipitation, some further process needs to be added.
# The process is taken from downscaleR, to provide a more reasonable hindcast, used in the calibration.
# check if frc, hindcast or obs are all na values
if (!any(!is.na(obs)) | !any(!is.na(hindcast))) {
warning('In this cell, hindcast or obs data is missing. No biasCorrection for this cell.')
return(NA)
}
if (preci == TRUE) {
preprocessHindcast_res <- preprocessHindcast(hindcast = hindcast, obs = obs, prThreshold = prThreshold)
hindcast <- preprocessHindcast_res[[1]]
minHindcastPreci <- preprocessHindcast_res[[2]]
}
# default is the simplest method in biascorrection, just do simple addition and subtraction.
if (method == 'delta') {
biasFactor <- getBiasFactor_core_delta(hindcast)
} else if (method == 'scaling') {
biasFactor <- getBiasFactor_core_scaling(hindcast, obs, scaleType)
} else if (method == 'eqm') {
# In this method, the value is bounded by the observation
# Preci or not both have the same biasFactor
if (preci == FALSE) {
biasFactor <- getBiasFactor_core_eqm_nonPreci(hindcast, obs, extrapolate)
} else {
biasFactor <- getBiasFactor_core_eqm_preci(hindcast, obs, minHindcastPreci, extrapolate, prThreshold)
}
} else if (method == 'gqm') {
if (preci == FALSE) stop ('gqm method only applys to precipitation, please set preci = T')
biasFactor <- getBiasFactor_core_gqm(hindcast, obs, prThreshold, minHindcastPreci)
}
if (preci == TRUE) biasFactor$minHindcastPreci <- minHindcastPreci
return(biasFactor)
}
applyBiasFactor_core <- function(frc, biasFactor, method, preci, prThreshold, scaleType,
extrapolate, obs = NULL) {
if (!any(!is.na(biasFactor))) {
warning('In this cell, biasFactor is missing.No biasCorrection for this cell.')
# here return NA or return the unprocessed frc, both are OK. But return NA is more
# obvious for user.
return(NA)
}
if (method == 'delta') {
if (is.null(obs)) stop('This method needs obs input.')
if (length(frc) != length(obs)) stop('This method needs frc data have the same length as obs data.')
frc <- applyBiasFactor_core_delta(frc = frc, biasFactor = biasFactor, obs = obs)
} else if (method == 'scaling') {
frc <- applyBiasFactor_core_scaling(frc = frc, biasFactor = biasFactor, scaleType = scaleType)
} else if (method == 'eqm') {
if (is.null(obs)) stop('This method needs obs input.')
if (preci == FALSE) {
frc <- applyBiasFactor_core_eqm_nonPreci(frc = frc, biasFactor = biasFactor, extrapolate = extrapolate,
obs = obs)
} else {
frc <- applyBiasFactor_core_eqm_preci(frc = frc, biasFactor = biasFactor, extrapolate = extrapolate,
prThreshold = prThreshold, obs = obs)
}
} else if (method == 'gqm') {
frc <- applyBiasFactor_core_gqm(frc = frc, biasFactor = biasFactor)
}
return(frc)
}
getBiasFactor_core_delta <- function(hindcast) {
biasFactor <- list()
biasFactor$hindcastMean <- mean(hindcast, na.rm = TRUE)
return(biasFactor)
}
applyBiasFactor_core_delta <- function(frc, biasFactor, obs) {
hindcastMean <- biasFactor$hindcastMean
frcMean <- mean(frc, na.rm = TRUE)
return(obs - hindcastMean + frcMean)
}
getBiasFactor_core_scaling <- function(hindcast, obs, scaleType) {
biasFactor <- list()
hindcastMean <- mean(hindcast, na.rm = TRUE)
obsMean <- mean(obs, na.rm = TRUE)
if (scaleType == 'multi') {
biasFactor$scale <- obsMean / hindcastMean
} else if (scaleType == 'add') {
biasFactor$scale <- obsMean - hindcastMean
}
return(biasFactor)
}
applyBiasFactor_core_scaling <- function(frc, biasFactor, scaleType) {
if (scaleType == 'multi') {
frc <- frc * biasFactor$scale
} else if (scaleType == 'add') {
frc <- frc + biasFactor$scale
}
return(frc)
}
getBiasFactor_core_eqm_nonPreci <- function(hindcast, obs, extrapolate) {
biasFactor <- list()
biasFactor$ecdfHindcast <- ecdf(hindcast)
if (extrapolate == 'constant') {
biasFactor$maxHindcast <- max(hindcast, na.rm = TRUE)
biasFactor$minHindcast <- min(hindcast, na.rm = TRUE)
biasFactor$higherIndex_dif <- biasFactor$maxHindcast - max(obs, na.rm = TRUE)
biasFactor$lowerIndex_dif <- biasFactor$minHindcast - min(obs, na.rm = TRUE)
}
return(biasFactor)
}
getBiasFactor_core_eqm_preci <- function(hindcast, obs, minHindcastPreci, extrapolate,
prThreshold) {
biasFactor <- list()
biasFactor$ecdfHindcast <- ecdf(hindcast[hindcast > minHindcastPreci])
if (extrapolate == 'constant') {
biasFactor$maxHindcast <- max(hindcast, na.rm = TRUE)
biasFactor$minHindcast <- min(hindcast, na.rm = TRUE)
biasFactor$higherIndex_dif <- biasFactor$maxHindcast - max(obs, na.rm = TRUE)
biasFactor$lowerIndex_dif <- biasFactor$minHindcast - min(obs, nna.rm = TRUE)
}
biasFactor$availableHindcastLength <- length(which(hindcast > minHindcastPreci))
# drizzle parameter 1
biasFactor$drizzleP1 <- min(hindcast[hindcast > minHindcastPreci], na.rm = TRUE)
# biasFactor$prThreshold <- prThreshold
return(biasFactor)
}
applyBiasFactor_core_eqm_nonPreci <- function(frc, biasFactor, extrapolate, obs) {
ecdfHindcast <- biasFactor$ecdfHindcast
if (extrapolate == 'constant') {
higherIndex <- which(frc > biasFactor$maxHindcast)
lowerIndex <- which(frc < biasFactor$minHindcast)
extrapolateIndex <- c(higherIndex, lowerIndex)
non_extrapolateIndex <- setdiff(1:length(frc), extrapolateIndex)
# In case extrapolateIndex is of length zero, than extrapolate cannot be used afterwards
# So use setdiff(1:length(sim), extrapolateIndex), if extrapolateIndex == 0, than it will
# return 1:length(sim)
if (length(higherIndex) > 0) {
frc[higherIndex] <- frc[higherIndex] - biasFactor$higherIndex_dif
}
if (length(lowerIndex) > 0) {
frc[lowerIndex] <- frc[lowerIndex] - biasFactor$lowerIndex_dif
}
frc[non_extrapolateIndex] <- quantile(obs, probs = ecdfHindcast(frc[non_extrapolateIndex]),
na.rm = TRUE, type = 4)
} else {
frc <- quantile(obs, probs = ecdfHindcast(frc), na.rm = TRUE, type = 4)
}
return(frc)
}
#' @importFrom stats quantile
applyBiasFactor_core_eqm_preci <- function(frc, biasFactor, extrapolate, prThreshold, obs) {
# Most of time this condition seems useless because minHindcastPreci comes from hindcast, so there will be
# always hindcast > minHindcastPreci exists.
# Unless one condition that minHindcastPreci is the max in the hindcast, than on hindcast > minHindcastPreci
if (biasFactor$availableHindcastLength > 0) {
ecdfHindcast <- biasFactor$ecdfHindcast
noRain <- which(frc <= biasFactor$minHindcastPreci & !is.na(frc))
rain <- which(frc > biasFactor$minHindcastPreci & !is.na(frc))
# drizzle is to see whether there are some precipitation between the min frc (over threshold) and
# min hindcast (over threshold).
drizzle <- which(frc > biasFactor$minHindcastPreci & frc <= biasFactor$drizzleP1 & !is.na(frc))
if (length(rain) > 0) {
ecdfFrc <- ecdf(frc[rain])
if (extrapolate == 'constant') {
# This higher and lower index mean the extrapolation part
higherIndex <- which(frc[rain] > biasFactor$maxHindcast)
lowerIndex <- which(frc[rain] < biasFactor$minHindcast)
extrapolateIndex <- c(higherIndex, lowerIndex)
non_extrapolateIndex <- setdiff(1:length(rain), extrapolateIndex)
if (length(higherIndex) > 0) {
frc[rain[higherIndex]] <- frc[higherIndex] - biasFactor$higherIndex_dif
}
if (length(lowerIndex) > 0) {
frc[rain[lowerIndex]] <- frc[lowerIndex] - biasFactor$lowerIndex_dif
}
# Here the original function doesn't accout for the situation that extraploateIndex is 0
# if it is 0, rain[-extraploateIndex] would be nothing
# Above has been solved by using setdiff.
frc[rain[non_extrapolateIndex]] <- quantile(obs[which(obs > prThreshold & !is.na(obs))],
probs = ecdfHindcast(frc[rain[non_extrapolateIndex]]),
na.rm = TRUE, type = 4)
} else {
frc[rain] <- quantile(obs[which(obs > prThreshold & !is.na(obs))],
probs = ecdfHindcast(frc[rain]), na.rm = TRUE, type = 4)
}
}
if (length(drizzle) > 0){
# drizzle part is a seperate part. it use the ecdf of frc (larger than minHindcastPreci) to
# biascorrect the original drizzle part
frc[drizzle] <- quantile(frc[which(frc > biasFactor$drizzleP1 & !is.na(frc))],
probs = ecdfFrc(frc[drizzle]), na.rm = TRUE,
type = 4)
}
frc[noRain] <- 0
} else {
# in this condition minHindcastPreci is the max of hindcast, so all hindcast <= minHindcastPreci
# And frc distribution is used then.
noRain <- which(frc <= biasFactor$minHindcastPreci & !is.na(frc))
rain <- which(frc > biasFactor$minHindcastPreci & !is.na(frc))
if (length(rain) > 0) {
ecdfFrc <- ecdf(frc[rain])
frc[rain] <- quantile(obs[which(obs > prThreshold & !is.na(obs))], probs = ecdfFrc(frc[rain]),
na.rm = TRUE, type = 4)
}
frc[noRain]<-0
}
return(frc)
}
#' @importFrom MASS fitdistr
getBiasFactor_core_gqm <- function(hindcast, obs, prThreshold, minHindcastPreci) {
if (any(obs > prThreshold)) {
biasFactor <- list()
ind <- which(obs > prThreshold & !is.na(obs))
obsGamma <- fitdistr(obs[ind],"gamma")
biasFactor$obsShape <- obsGamma$estimate[1]
biasFactor$obsRate <- obsGamma$estimate[2]
ind <- which(hindcast > 0 & !is.na(hindcast))
hindcastGamma <- fitdistr(hindcast[ind],"gamma")
biasFactor$hindcastShape <- hindcastGamma$estimate[1]
biasFactor$hindcastRate <- hindcastGamma$estimate[2]
biasFactor$minHindcastPreci <- minHindcastPreci
} else {
warning('All the observations of this cell(station) are lower than the threshold,
no biasFactor returned.')
biasFactor <- NA
}
return(biasFactor)
}
#' @importFrom stats pgamma qgamma
applyBiasFactor_core_gqm <- function(frc, biasFactor) {
rain <- which(frc > biasFactor$minHindcastPreci & !is.na(frc))
noRain <- which(frc <= biasFactor$minHindcastPreci & !is.na(frc))
probF <- pgamma(frc[rain], biasFactor$hindcastShape, rate = biasFactor$hindcastRate)
frc[rain] <- qgamma(probF, biasFactor$obsShape, rate = biasFactor$obsRate)
frc[noRain] <- 0
return(frc)
}
biasFactor <- getBiasFactor(hindcast, obs)
frc_new <- applyBiasFactor(frc, biasFactor)
frc_new1 <- biasCorrect(frc, hindcast, obs)
frc_new1 <- biasCorrect(frc, hindcast, obs, input = 'TS')
identical(frc_new, frc_new1)
frc_new - frc_new1
ploTS(frc_new, frc_new1)
ploTS(frc_new, frc_new1)
?plotTS
plot.ts(frc_new)
plot.ts(frc_new, frc_new1)
plot.ts(frc_new1, add = T)
plot(frc_new1)
plotTS(frc_new1)
plotTS(frc_new1, frc_new)
plotTS(frc_new1, frc_new, plot='cu')
plotTS(frc_new1, frc_new, plot='cum')
biasFactor <- getBiasFactor(hindcast, obs, preci = TRUE)
#' @importFrom MASS fitdistr
#' @importFrom stats rgamma
preprocessHindcast <- function(hindcast, obs, prThreshold) {
lowerIndex <- length(which(obs < prThreshold))
# In the original function, this minHindcastPreci is Pth[,i,j] in downscaleR, and it is originally
# set to NA, which is not so appropriate for all the precipitations.
# In the original function, there are only two conditions, 1. all the obs less than threshold
# 2. there are some obs less than threshold.
# While, if we set threshold to 0, there could be a 3rd condition, all the obs no less than threshold.
# Here I set this situation, firstly set minHindcastPreci to the min of the hindcast. Because in future
# use, 'eqm' method is going to use this value.
# The problem above has been solved.
if (lowerIndex >= 0 & lowerIndex < length(obs)) {
index <- sort(hindcast, decreasing = FALSE, na.last = NA, index.return = TRUE)$ix
hindcast_sorted <- sort(hindcast, decreasing = FALSE, na.last = NA)
# minHindcastPreci is the min preci over threshold FOR ***HINDCAST***
# But use obs to get the lowerIndex, so obs_sorted[lowerIndex + 1] > prThreshold, but
# hindcast_sorted[lowerIndex + 1] may greater than or smaller than ptThreshold
# It would be better to understand if you draw two lines: hindcast_sorted and obs_sorted
# with y = prThreshold, you will find the difference of the two.
# In principle, the value under the threshold needs to be replaced by some other reasonable value.
# simplest way
minHindcastPreci <- hindcast_sorted[lowerIndex + 1]
# Also here if minHindcastPreci is 0 and prThreshold is 0, will cause problem, bettter set
# I set it prThreshold != 0
if (minHindcastPreci <= prThreshold & prThreshold != 0) {
obs_sorted <- sort(obs, decreasing = FALSE, na.last = NA)
# higherIndex is based on hindcast
higherIndex <- which(hindcast_sorted > prThreshold & !is.na(hindcast_sorted))
if (length(higherIndex) == 0) {
higherIndex <- max(which(!is.na(hindcast_sorted)))
higherIndex <- min(length(obs_sorted), higherIndex)
} else {
higherIndex <- min(higherIndex)
}
# here I don't know why choose 6.
# Written # [Shape parameter Scale parameter] in original package
# according to the reference and gamma distribution, at least 6 values needed to fit gamma
# distribution.
if (length(unique(obs_sorted[(lowerIndex + 1):higherIndex])) < 6) {
hindcast_sorted[(lowerIndex + 1):higherIndex] <- mean(obs_sorted[(lowerIndex + 1):higherIndex],
na.rm = TRUE)
} else {
obsGamma <- fitdistr(obs_sorted[(lowerIndex + 1):higherIndex], "gamma")
# this is to replace the original hindcast value between lowerIndex and higherIndex with
# some value taken from gamma distribution just generated.
hindcast_sorted[(lowerIndex + 1):higherIndex] <- rgamma(higherIndex - lowerIndex, obsGamma$estimate[1],
rate = obsGamma$estimate[2])
}
hindcast_sorted <- sort(hindcast_sorted, decreasing = FALSE, na.last = NA)
}
minIndex <- min(lowerIndex, length(hindcast))
hindcast_sorted[1:minIndex] <- 0
hindcast[index] <- hindcast_sorted
} else if (lowerIndex == length(obs)) {
index <- sort(hindcast, decreasing = FALSE, na.last = NA, index.return = TRUE)$ix
hindcast_sorted <- sort(hindcast, decreasing = FALSE, na.last = NA)
minHindcastPreci <- hindcast_sorted[lowerIndex]
# here is to compare with hindcast, not obs
minIndex <- min(lowerIndex, length(hindcast))
hindcast_sorted[1:minIndex] <- 0
hindcast[index] <- hindcast_sorted
}
return(list(hindcast, minHindcastPreci))
}
biasFactor <- getBiasFactor(hindcast, obs, preci = TRUE)
frc_new <- applyBiasFactor(frc, biasFactor)
frc_new1 <- biasCorrect(frc, hindcast, obs, input = 'TS', preci = TRUE)
plotTS(frc_new1, frc_new, plot='cum')
frc_new == frc_new1
biasFactor <- getBiasFactor(hindcast, obs, method = 'delta')
frc_new <- applyBiasFactor(frc, biasFactor, obs = obs)
frc_new1 <- biasCorrect(frc, hindcast, obs, method = 'delta', input = 'TS')
plotTS(frc_new1, frc_new, plot='cum')
frc_new == frc_new1
any(frc_new != frc_new1)
biasFactor <- getBiasFactor(hindcast, obs, method = 'eqm', preci = TRUE)
frc_new <- applyBiasFactor(frc, biasFactor, obs = obs)
frc_new1 <- biasCorrect(frc, hindcast, obs, method = 'eqm', input = 'TS', preci = TRUE)
any(frc_new != frc_new1)
any(frc_new != frc_new1, na.rm=T)
biasFactor <- getBiasFactor(hindcast, obs, sclaeType = 'add', preci = TRUE)
biasFactor <- getBiasFactor(hindcast, obs, scaleType = 'add', preci = TRUE)
frc_new <- applyBiasFactor(frc, biasFactor, obs = obs)
frc_new <- applyBiasFactor(frc, biasFactor)
frc_new1 <- biasCorrect(frc, hindcast, obs, scaleType = 'add', input = 'TS', preci = TRUE)
any(frc_new != frc_new1, na.rm=T)
plotTS(frc_new1, frc_new, plot='cum')
biasFactor <- getBiasFactor(hindcast, obs, method = 'gqm', preci = TRUE)
library(MASS)
biasFactor <- getBiasFactor(hindcast, obs, method = 'gqm', preci = TRUE)
frc_new <- applyBiasFactor(frc, biasFactor)
frc_new1 <- biasCorrect(frc, hindcast, obs, method = 'gqm', input = 'TS', preci = TRUE)
any(frc_new != frc_new1, na.rm=T)
biasFactor <- getBiasFactor(hindcast, obs, method = 'eqm',extrapolate = 'constant', preci = TRUE)
frc_new <- applyBiasFactor(frc, biasFactor)
frc_new <- applyBiasFactor(frc, biasFactor, obs = obs)
frc_new1 <- biasCorrect(frc, hindcast, obs, method = 'eqm',extrapolate = 'constant', input = 'TS', preci = TRUE)
any(frc_new != frc_new1, na.rm=T)
str(nc)
nc1 <- nc
nc1$Data <- chooseDim(nc$Data, dim = 4, value = 1, drop = T)
str(nc1)
nc$Members <- NULL
nc1
str(nc1)
nc$Members <- NULL
str(nc1)
nc1$Members <- NULL
nc$Members <- c(1,2)
str(nc1)
str(nc)
biasFactor <- getBiasFactor(nc, tgridData)
newFrc <- applyBiasFactor(nc, biasFactor)
newFrc1 <- biasCorrect(nc, nc, tgridData)
identical(newFrc, newFrc1)
biasFactor <- getBiasFactor(nc, tgridData, method = 'eqm', extrapolate = 'constant',
preci = TRUE)
# This method needs obs input.
newFrc <- applyBiasFactor(nc, biasFactor, obs = tgridData)
newFrc1 <- biasCorrect(nc, nc, tgridData, method = 'eqm', extrapolate = 'constant',
preci = TRUE)
identical(newFrc, newFrc1)
str(newFrc)
biasFactor <- getBiasFactor(nc1, tgridData, method = 'gqm', preci = TRUE)
str(biasFactor)
newFrc <- applyBiasFactor(nc, biasFactor)
newFrc <- applyBiasFactor(nc1, biasFactor)
str(newFrc)
newFrc1 <- biasCorrect(nc, nc, tgridData, method = 'gqm', preci = TRUE)
identical(newFrc, newFrc1)
newFrc1 <- biasCorrect(nc1, nc1, tgridData, method = 'gqm', preci = TRUE)
identical(newFrc, newFrc1)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
?setAs
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
?method
??method
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
?size
?size
??size
?size
class(biasFactor)
size(frc)
devtools::document()
devtools::document()
devtools::check()
show(biasFactor)
devtools::document()
devtools::document()
devtools::check()
method(biasFactor)
methods('biasFactor')
methods(biasFactor)
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::build()
