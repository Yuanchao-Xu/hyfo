devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
?size
?size
??size
?size
class(biasFactor)
size(frc)
devtools::document()
devtools::document()
devtools::check()
show(biasFactor)
devtools::document()
devtools::document()
devtools::check()
method(biasFactor)
methods('biasFactor')
methods(biasFactor)
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::build()
?applyBiasFactor
library(hyfo)
?applyBiasFactor
devtools::document()
devtools::document()
?setGeneric
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
?resample
??resample
devtools::document()
devtools::check()
install.packages('gridExtra')
data(testdl)
datalist <- extractPeriod(testdl, startDate = '1994-1-1', endDate = '1995-10-1')
frc <- datalist[[1]]
hindcast <- datalist[[2]]
obs <- datalist[[3]]
frc_new <- biasCorrect(frc, hindcast, obs, input = 'TS')
frc_new <- biasCorrect(frc, hindcast, obs)
frc_new1 <- biasCorrect(frc, hindcast, obs, preci = TRUE)
frc_new2 <- biasCorrect(frc, hindcast, obs, scaleType = 'add')
frc_new3 <- biasCorrect(frc, hindcast, obs, method = 'eqm', preci = TRUE)
frc_new4 <- biasCorrect(frc, hindcast, obs, method = 'gqm', preci = TRUE)
plotTS(obs, frc, frc_new, frc_new1, frc_new2, frc_new3, frc_new4, plot = 'cum')
TSlist <- list(obs, frc, frc_new, frc_new1, frc_new2, frc_new3, frc_new4)
names(TSlist) <- c('obs', 'frc', 'delta', 'delta_preci', 'scale', 'eqm', 'gqm')
plotTS(list = TSlist, plot = 'cum')
biasFactor <- getBiasFactor(hindcast, obs, method = 'eqm', preci = TRUE)
frc_new33 <- applyBiasFactor(frc, biasFactor, obs = obs)
identical(frc_new3, frc_new33)
str(biasFactor)
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
AAA <- data.frame(
# date column
Date = seq(as.Date('1990-10-28'),as.Date('1997-4-1'),1),
# value column
AAA = sample(1:100,length(seq(as.Date('1990-10-28'),as.Date('1997-4-1'),1)), repl = TRUE))
BBB <- data.frame(
Date = seq(as.Date('1993-3-28'),as.Date('1999-1-1'),1),
BBB = sample(1:100,length(seq(as.Date('1993-3-28'),as.Date('1999-1-1'),1)), repl = TRUE))
CCC <- data.frame(
Date = seq(as.Date('1988-2-2'),as.Date('1996-1-1'),1),
CCC = sample(1:100,length(seq(as.Date('1988-2-2'),as.Date('1996-1-1'),1)), repl = TRUE))
list <- list(AAA, BBB, CCC)# dput() and dget() can be used to save and load list file.
list_com <- extractPeriod(list, commonPeriod = TRUE)
list_com1 <- extractPeriod(list, commonPeriod = TRUE)
identical(list_com, list_com1)
data(testdl)
datalist_com1 <- extractPeriod(testdl, startDate = '1994-1-1', endDate = '1995-10-1')
datalist_com2 <- extractPeriod(testdl, startDate = '1994-1-1', endDate = '1995-10-1')
identical(datalist_com1, datalist_com2)
dataframe <- list2Dataframe(datalist_com1)
dataframe_new <- extractPeriod(dataframe, month = c(1,2,3))
dataframe_new1 <- extractPeriod(dataframe = dataframe, month = c(1,2,3))
dataframe_new <- extractPeriod(dataframe, month = c(12,1,2), year = 1995)
#' Extract period from list or dataframe.
#'
#' Extract common period or certain period from a list of different dataframes of time series, or from a
#' dataframe.
#' NOTE: all the dates in the datalist should follow the format in ?as.Date{base}.
#' @param datalist A list of different dataframes of time series .
#' @param startDate A Date showing the start of the extract period, default as NULL, check details.
#' @param endDate A Date showing the end of the extract period, default as NULL, check details.
#' @param commonPeriod A boolean showing whether the common period is extracted. If chosen, startDate and endDate
#' should be NULL.
#' @param dataframe A dataframe with first column Date, the rest columns value. If your input is a
#' dataframe, not time series list, you can put \code{dataframe = yourdataframe}. And certain period will be
#' extracted. Note: if your input is a time series, that means all the columns share the same period of date.
#' @param year extract certain year in the entire time series. if you want to extract year 2000, set \code{year = 2000}
#' @param month extract certain months in a year. e.g. if you want to extract Jan, Feb of each year,
#' set \code{month = c(1, 2)}.
#' @details
#' \strong{startDate and endDate}
#'
#' If startDate and endDate are assigned, then certain period between startDate and endDate will be returned,
#' for both datalist input and dataframe input.
#'
#' If startDate and endDate are NOT assigned, then,
#'
#'    if input is a datalist, the startDate and endDate of the common period of different datalists will be assigned
#'    to the startDate and endDate.
#'
#'    if input is a dataframe, the startDate and endDate of the input dataframe will be assigned to the startDate
#'    and endDate . Since different value columns share a common Date column in a dataframe input.
#'
#' \strong{year and month}
#'
#' For year crossing month input, hyfo will take from the year before. E.g. if \code{month = c(10, 11, 12, 1)},
#' and \code{year = 1999}, hyfo will take month 10, 11 and 12 from year 1998, and month 1 from 1999.You DO NOT
#' have to set \code{year = 1998 : 1999}.
#'
#' Well, if you set \code{year = 1998 : 1999}, hyfo will take month 10, 11 and 12 from year 1997, and month 1 from 1998,
#' then, take month 10, 11 and 12 from year 1998, month 1 from 1999. So you only have to care about the latter year.
#'
#'
#'
#' @return A list or a dataframe with all the time series inside containing the same period.
#' @examples
#' # Generate timeseries datalist. Each data frame consists of a Date and a value.
#'
#' AAA <- data.frame(
#' # date column
#' Date = seq(as.Date('1990-10-28'),as.Date('1997-4-1'),1),
#'  # value column
#' AAA = sample(1:100,length(seq(as.Date('1990-10-28'),as.Date('1997-4-1'),1)), repl = TRUE))
#'
#' BBB <- data.frame(
#' Date = seq(as.Date('1993-3-28'),as.Date('1999-1-1'),1),
#' BBB = sample(1:100,length(seq(as.Date('1993-3-28'),as.Date('1999-1-1'),1)), repl = TRUE))
#'
#' CCC <- data.frame(
#' Date = seq(as.Date('1988-2-2'),as.Date('1996-1-1'),1),
#' CCC = sample(1:100,length(seq(as.Date('1988-2-2'),as.Date('1996-1-1'),1)), repl = TRUE))
#'
#' list <- list(AAA, BBB, CCC)# dput() and dget() can be used to save and load list file.
#'
#' list_com <- extractPeriod(list, commonPeriod = TRUE)
#'
#' # list_com is the extracted datalist.
#' str(list_com)
#'
#' # If startDate and endDate is provided, the record between them will be extracted.
#' # make sure startDate is later than any startDate in each dataframe and endDate is
#' # earlier than any endDate in each dataframe.
#'
#' data(testdl)
#' datalist_com1 <- extractPeriod(testdl, startDate = '1994-1-1', endDate = '1995-10-1')
#'
#'
#' dataframe <- list2Dataframe(datalist_com1)
#' # now we have a dataframe to extract certain months and years.
#' dataframe_new <- extractPeriod(dataframe = dataframe, month = c(1,2,3))
#' dataframe_new <- extractPeriod(dataframe = dataframe, month = c(12,1,2), year = 1995)
#'
#'
#' # More examples can be found in the user manual on http://yuanchao-xu.github.io/hyfo/
#'
#' @importFrom zoo as.Date
#' @references
#'
#' \itemize{
#' \item Achim Zeileis and Gabor Grothendieck (2005). zoo: S3 Infrastructure for Regular and Irregular Time
#' Series. Journal of Statistical Software, 14(6), 1-27. URL http://www.jstatsoft.org/v14/i06/
#' }
#'
#' @export
extractPeriod <- function(datalist, startDate = NULL, endDate = NULL, commonPeriod = FALSE,
dataframe = NULL, year = NULL, month = NULL) {
if (!is.null(dataframe)) {
dataset <- extractPeriod_dataframe(dataframe, startDate = startDate, endDate = endDate, year = year,
month = month)
} else {
if (!is.null(startDate) & !is.null(endDate) & commonPeriod == FALSE) {
dataset <- lapply(datalist, extractPeriod_dataframe, startDate = startDate, endDate = endDate, year = year,
month = month)
} else if (is.null(startDate) & is.null(endDate) & commonPeriod == TRUE) {
Dates <- lapply(datalist, extractPeriod_getDate)
Dates <- do.call('rbind', Dates)
startDate <- as.Date(max(Dates[, 1]))
endDate <- as.Date(min(Dates[, 2]))
dataset <- lapply(datalist, extractPeriod_dataframe, startDate = startDate, endDate = endDate, year = year,
month = month)
} else {
stop('Enter startDate and endDate, set commonPeriod as False, or simply set commonPeriod as TRUE')
}
}
return(dataset)
}
extractPeriod_dataframe <- function(dataframe, startDate, endDate, year = NULL, month = NULL) {
# to check whether first column is a date format
if (!grepl('-|/', dataframe[1, 1])) {
stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base}
and use as.Date to convert.')
}
dataframe[, 1] <- as.Date(dataframe[, 1])
if (is.null(startDate)) startDate <- dataframe[1, 1]
if (is.null(endDate)) endDate <- tail(dataframe[, 1], 1)
startIndex <- which(dataframe[, 1] == startDate)
endIndex <- which(dataframe[, 1] == endDate)
if (length(startIndex) == 0 | length(endIndex) == 0) {
stop('startDate and endDate exceeds the date limits in dataframe. Check datalsit please.')
}
output <- dataframe[startIndex:endIndex, ]
if (!is.null(year)) {
Date <- as.POSIXlt(output[, 1])
yea <- Date$year + 1900
mon <- Date$mon + 1
if (is.null(month) || !any(sort(month) != month)) {
DateIndex <- which(yea %in% year)
if (length(DateIndex) == 0) stop('No input years in the input ts, check your input.')
output <- output[DateIndex, ]
# if year crossing  than sort(month) != month, in this case we need to
# take months from last year.
} else {
startIndex <- intersect(which(yea == year[1] - 1), which(mon == month[1]))[1]
endIndex <- tail(intersect(which(yea == tail(year, 1)), which(mon == tail(month, 1))), 1)
if (is.na(startIndex) || length(endIndex) == 0 || startIndex > endIndex) {
stop('Cannot find input months and input years in the input time series.')
}
output <- output[startIndex:endIndex, ]
if (any(diff(year) != 1)) {
# if year is not continuous, like 1999, 2003, 2005, than we have to sift again.
Date <- as.POSIXlt(output[, 1])
yea <- Date$year + 1900
mon <- Date$mon + 1
DateIndex <- unlist(sapply(year, function(x) {
startIndex <- intersect(which(yea == x - 1), which(mon == month[1]))[1]
endIndex <- tail(intersect(which(yea == x), which(mon == tail(month, 1))), 1)
index <- startIndex:endIndex
return(index)
}))
output <- output[DateIndex, ]
# cannot directly return output here, because sometimes, month can be incontinuous,
# we still need the next process to sift month.
}
}
}
if (!is.null(month)) {
Date <- as.POSIXlt(output[, 1])
mon <- Date$mon + 1
# %in% can deal with multiple equalities
DateIndex <- which(mon %in% month)
if (length(DateIndex) == 0) stop('No input months in the input ts, check your input.')
output <- output[DateIndex, ]
}
return(output)
}
#' @importFrom utils tail
#' @references
#'
#' \itemize{
#' \item R Core Team (2015). R: A language and environment for statistical computing. R Foundation for
#' Statistical Computing, Vienna, Austria. URL http://www.R-project.org/.
#' }
#'
#'
extractPeriod_getDate <- function(dataset) {
if (!grepl('-|/', dataset[1, 1])) {
stop('First column is not date or Wrong Date formate, check the format in ?as.Date{base},
and use as.Date to convert.')
}
start <- as.Date(dataset[1, 1])
end <- as.Date(tail(dataset[, 1], 1))
return(c(start, end))
}
dataframe_new1 <- extractPeriod(dataframe = dataframe, month = c(12,1,2), year = 1995)
identical(dataframe_new1, dataframe_new)
devtools::document()
devtools::document()
devtools::check()
data(tgridData)
getSpatialMap(tgridData, method = 'meanAnnual')
getSpatialMap(tgridData, method = 'winter')
getSpatialMap(tgridData, method = 'winter', catchment = testCat)
a1 <- getSpatialMap(tgridData, method = 'mean')
a2 <- getSpatialMap(tgridData, method = 'max')
a3 <- getSpatialMap(tgridData, method = 'winter')
a4 <- getSpatialMap(tgridData, method = 'summer')
a5 <- a2 - a1
getSpatialMap_mat(a4)
a1 <- getSpatialMap(tgridData, method = 'summer', output = 'ggplot', name = 'a1')
a2 <- getSpatialMap(tgridData, method = 'winter', output = 'ggplot', name = 'a2')
# a3 <- getSpatialMap(tgridData, method = 'mean', output = 'ggplot', name = 'a3')
# a4 <- getSpatialMap(tgridData, method = 'max', output = 'ggplot', name = 'a4')
getSpatialMap_comb(a1, a2)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
nc
filePath <- system.file("extdata", "tnc.nc", package = "hyfo")
varname <- getNcdfVar(filePath)
nc <- loadNcdf(filePath, varname)
hyfo <- nc
checkHyfo(hyfo)
str(hyfo)
data(testdl)
TS <- testdl[[2]] # Get daily data
TS
TS_new <- resample(TS, method = 'day2mon')
TS_new
hyfoData <- hyfo$Data
str(hyfoData)
memberIndex <- match('member', attributes(hyfoData)$dimensions)
memberIndex
hyfoData <- adjustDim(hyfoData, ref = c('lon', 'lat', 'time', 'member'))
str(hyfoData)
timeIndex <- match('time', attributes(hyfoData)$dimensions)
timeIndex
Date <- hyfo$Dates
str(Date)
Date <- as.POSIXlt(hyfo$Dates)
Date <- as.POSIXlt(hyfo$Dates$start)
mon <- Date$mon
mon
year <- Date$year
year
year <- Date$year + 1900
year
mon <- Date$mon + 1
mon
dimIndex <- 1:length(attributes(hyfoData)$dimensions)
dimIndex
dimArray <- 1:length(attributes(hyfoData)$dimensions)
dimArray[-timeIndex]
debug(resample)
TS_new <- resample(TS, method = 'day2mon')
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
debug(biasCorrect.TS)
frc_new1 <- biasCorrect(frc, hindcast, obs, preci = TRUE)
debug(resample.TS)
TS_new <- resample(TS, method = 'mon2day')
TS_new <- resample(TS, method = 'day2mon')
TS
data
?tapply
tapply(TS, INDEX = list(year, mon))
str(year)
str(mon)
tapply(TS, INDEX = list(year, mon), FUN = mean)
TS
year
mon
a <- tapply(TS, INDEX = list(year, mon), FUN = mean)
list(year, mon)
str(list(year, mon))
Date <- as.POSIXlt(TS[,1])
year <- Date$year + 1900
year
mon <- Date$mon + 1
mon
a <- tapply(TS, INDEX = list(year, mon), FUN = mean)
str(list(year, mon))
a <- tapply(TS, INDEX = list(year, mon), FUN = mean)
traceback
traceback()
aa <- aggregate(TS, by = list(year, mon), FUN = mean, na.rm = TRUE)
str(a)
str(aa)
aa <- aggregate(TS[,2], by = list(year, mon), FUN = mean, na.rm = TRUE)
str(aa)
a <- tapply(TS[, 2], INDEX = list(year, mon), FUN = mean)
a
a <- getMeanPreci(TS[, 2], yearIndex = year, monthIndex = mon)
a <- getMeanPreci(TS[, 2], yearIndex = year, monthIndex = mon, method = 'meanMonthly')
str(year)
str(mon)
str(TS)
str(TS[,2])
year <- as.POSIXlt(TS[,1])$year + 1900
year
mon <- as.POSIXlt(TS[,1])$mon + 1
a <- getMeanPreci(TS[, 2], yearIndex = year, monthIndex = mon, method = 'meanMonthly')
a
a <- getMeanPreci(TS[, 2], yearIndex = year, monthIndex = mon, method = 'meanMonthly', fullR = T)
A
a
a <- aggregate(TS[, 2], list(year, mon))
a
a <- aggregate(TS[, 2], list(year, mon), FUN = mean, na.rm = T)
a
str(a)
aa <- aggregate(TS[, 2], list(mon, year), FUN = mean, na.rm = T)
str(aa)
debug(resample.TS)
TS_new <- resample(TS, method = 'day2mon')
undebug(resample)
TS_new <- resample(TS, method = 'day2mon')
a <- aggregate(TS, by = list(mon, year), FUN = mean, na.rm = TRUE)
data
a
data == a [,3:4]
order(data$Date)
A <- aggregate(TS, by = list(year, mon), FUN = mean, na.rm = TRUE)
A
order(A$Date)
a$Date
aa <- aggregate(TS[, 2], list(mon, year), FUN = mean, na.rm = T)
aa
aa <- aggregate(TS[, 2], list(mon, year), FUN = mean, na.rm = T)[, 3]
aa
dim(TS)
aa <- aggregate(TS, list(mon, year), FUN = mean, na.rm = T)[, 3]
aa
?aggregate
str(hyfo)
devtools::document()
devtools::check()
str(nc)
nc_new <- resample(nc, 'day2mon')
devtools::document()
devtools::check()
nc_new <- resample(nc, 'day2mon')
debug(resample.list)
nc_new <- resample(nc, 'day2mon')
dimArray[-timeIndex]
apply(hyfoData, MARGIN = dimArray[-timeIndex],
function(x) aggregate(x, by = list(mon, year), FUN = mean, na.rm = TRUE))[, 3]
str(hyfoData)
apply(hyfoData, MARGIN = dimArray[-timeIndex],
function(x) aggregate(x, by = list(mon, year), FUN = mean, na.rm = TRUE)Q)
devtools::document()
devtools::check()
debug(resample.list)
nc_new <- resample(nc, 'day2mon')
nn
str(hyfoData)
str(hyfoData)
Date
Date
str(nc_new)
nc_new <- resample(nc, 'day2mon')
str(nc_new)
?resample
devtools::build()
